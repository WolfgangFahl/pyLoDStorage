{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyLodStorage API Documentation","text":""},{"location":"#lodstorage.docstring_parser","title":"<code>docstring_parser</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.docstring_parser.DocstringParser","title":"<code>DocstringParser</code>","text":"<p>A Python docstring parser.</p> Source code in <code>lodstorage/docstring_parser.py</code> <pre><code>class DocstringParser:\n    \"\"\"\n    A Python docstring parser.\n    \"\"\"\n\n    def __init__(self):\n        # Define basic elements\n        identifier = Word(alphas, alphanums + \"_\")\n        type_identifier = Word(alphas, alphanums + \"_.[]\")\n        description = restOfLine\n\n        # Define patterns for capturing attributes\n        attribute_start = Suppress(Literal(\"Attributes:\"))\n        self.attribute = Group(\n            identifier(\"name\")\n            + Suppress(\"(\")\n            + Optional(type_identifier(\"type\"))\n            + Suppress(\"):\")\n            + description(\"description\")\n        )\n\n        # Define pattern for class docstring\n        class_docstring = restOfLine(\"class_description\") + Optional(\n            attribute_start + OneOrMore(self.attribute)(\"attributes\")\n        )\n\n        # Updated class_docstring pattern to correctly handle multi-line class descriptions\n        self.class_docstring = class_docstring + Optional(\n            OneOrMore(~attribute_start + restOfLine)(\"class_description\")\n            + attribute_start\n            + OneOrMore(self.attribute)(\"attributes\")\n        )\n\n    def parse(self, docstring: str):\n        \"\"\"\n        Parse the given docstring.\n        \"\"\"\n        result = self.class_docstring.parseString(docstring, parseAll=True)\n        class_description = \" \".join(result.class_description).strip()\n        attributes = {\n            attr.name: {\"type\": attr.type, \"description\": attr.description.strip()}\n            for attr in result.attributes\n        }\n        return class_description, attributes\n</code></pre>"},{"location":"#lodstorage.docstring_parser.DocstringParser.parse","title":"<code>parse(docstring)</code>","text":"<p>Parse the given docstring.</p> Source code in <code>lodstorage/docstring_parser.py</code> <pre><code>def parse(self, docstring: str):\n    \"\"\"\n    Parse the given docstring.\n    \"\"\"\n    result = self.class_docstring.parseString(docstring, parseAll=True)\n    class_description = \" \".join(result.class_description).strip()\n    attributes = {\n        attr.name: {\"type\": attr.type, \"description\": attr.description.strip()}\n        for attr in result.attributes\n    }\n    return class_description, attributes\n</code></pre>"},{"location":"#lodstorage.exception_handler","title":"<code>exception_handler</code>","text":"<p>Created on 2025-12-01</p> <p>@author: wf</p>"},{"location":"#lodstorage.exception_handler.ExceptionHandler","title":"<code>ExceptionHandler</code>","text":"<p>handle exceptions</p> Source code in <code>lodstorage/exception_handler.py</code> <pre><code>class ExceptionHandler:\n    \"\"\"\n    handle exceptions\n    \"\"\"\n\n    @classmethod\n    def handle(\n        cls, msg: str, ex: Exception, debug: bool = False\n    ):\n        \"\"\"Centralized exception logging (non-fatal).\n\n        Args:\n            msg: context message\n            ex: the exception caught\n            debug: if True, print full traceback\n        \"\"\"\n        full_msg = f\"{msg}: {str(ex)}\"\n        logging.warning(full_msg)\n        if debug:\n            traceback.print_exc()\n</code></pre>"},{"location":"#lodstorage.exception_handler.ExceptionHandler.handle","title":"<code>handle(msg, ex, debug=False)</code>  <code>classmethod</code>","text":"<p>Centralized exception logging (non-fatal).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>context message</p> required <code>ex</code> <code>Exception</code> <p>the exception caught</p> required <code>debug</code> <code>bool</code> <p>if True, print full traceback</p> <code>False</code> Source code in <code>lodstorage/exception_handler.py</code> <pre><code>@classmethod\ndef handle(\n    cls, msg: str, ex: Exception, debug: bool = False\n):\n    \"\"\"Centralized exception logging (non-fatal).\n\n    Args:\n        msg: context message\n        ex: the exception caught\n        debug: if True, print full traceback\n    \"\"\"\n    full_msg = f\"{msg}: {str(ex)}\"\n    logging.warning(full_msg)\n    if debug:\n        traceback.print_exc()\n</code></pre>"},{"location":"#lodstorage.linkml","title":"<code>linkml</code>","text":"<p>Created on 2024-01-28</p> <p>@author: wf</p>"},{"location":"#lodstorage.linkml.Class","title":"<code>Class</code>","text":"<p>Represents a class in the LinkML schema.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Class:\n    \"\"\"\n    Represents a class in the LinkML schema.\n    \"\"\"\n\n    description: str\n    slots: List[Slot]\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes","title":"<code>PythonTypes</code>","text":"<p>python type handling</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>class PythonTypes:\n    \"\"\"\n    python type handling\n    \"\"\"\n\n    # Define a mapping from Python types to LinkML ranges\n    to_linkml_ranges = {\n        str: \"string\",\n        int: \"integer\",\n        float: \"float\",\n        bool: \"boolean\",\n        list: \"list\",\n        dict: \"dictionary\",\n    }\n    # Mapping from Python types to RDF (XSD) datatypes\n    to_rdf_datatypes = {\n        str: XSD.string,\n        int: XSD.integer,\n        float: XSD.float,\n        bool: XSD.boolean,\n        # Add more mappings if needed\n    }\n\n    @classmethod\n    def get_linkml_range(cls, ptype: Type) -&gt; str:\n        \"\"\"\n        Determines the LinkML range for a given Python type.\n\n        Args:\n            ptype (Type): The Python type for which the LinkML range is required.\n\n        Returns:\n            str: The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.\n        \"\"\"\n        return cls.to_linkml_ranges.get(ptype, \"string\")\n\n    @classmethod\n    def get_rdf_datatype(cls, ptype: Type) -&gt; Optional[XSD]:\n        \"\"\"\n        Determines the RDF (XSD) datatype for a given Python type.\n\n        Args:\n            ptype (Type): The Python type for which the RDF (XSD) datatype is required.\n\n        Returns:\n            XSD: The corresponding RDF (XSD) datatype. Returns None if the type is not found.\n        \"\"\"\n        return cls.to_rdf_datatypes.get(ptype)\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes.get_linkml_range","title":"<code>get_linkml_range(ptype)</code>  <code>classmethod</code>","text":"<p>Determines the LinkML range for a given Python type.</p> <p>Parameters:</p> Name Type Description Default <code>ptype</code> <code>Type</code> <p>The Python type for which the LinkML range is required.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@classmethod\ndef get_linkml_range(cls, ptype: Type) -&gt; str:\n    \"\"\"\n    Determines the LinkML range for a given Python type.\n\n    Args:\n        ptype (Type): The Python type for which the LinkML range is required.\n\n    Returns:\n        str: The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.\n    \"\"\"\n    return cls.to_linkml_ranges.get(ptype, \"string\")\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes.get_rdf_datatype","title":"<code>get_rdf_datatype(ptype)</code>  <code>classmethod</code>","text":"<p>Determines the RDF (XSD) datatype for a given Python type.</p> <p>Parameters:</p> Name Type Description Default <code>ptype</code> <code>Type</code> <p>The Python type for which the RDF (XSD) datatype is required.</p> required <p>Returns:</p> Name Type Description <code>XSD</code> <code>Optional[XSD]</code> <p>The corresponding RDF (XSD) datatype. Returns None if the type is not found.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@classmethod\ndef get_rdf_datatype(cls, ptype: Type) -&gt; Optional[XSD]:\n    \"\"\"\n    Determines the RDF (XSD) datatype for a given Python type.\n\n    Args:\n        ptype (Type): The Python type for which the RDF (XSD) datatype is required.\n\n    Returns:\n        XSD: The corresponding RDF (XSD) datatype. Returns None if the type is not found.\n    \"\"\"\n    return cls.to_rdf_datatypes.get(ptype)\n</code></pre>"},{"location":"#lodstorage.linkml.Schema","title":"<code>Schema</code>","text":"<p>Represents the entire LinkML schema.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Schema:\n    \"\"\"\n    Represents the entire LinkML schema.\n    \"\"\"\n\n    name: str\n    id: str\n    description: str\n    title: Optional[str] = None\n    version: Optional[str] = None\n    license: Optional[str] = None\n\n    default_prefix: Optional[str] = None\n\n    prefixes: Dict[str, str] = field(default_factory=dict)\n    imports: List[str] = field(default_factory=list)\n    default_range: str = \"string\"\n    classes: Dict[str, Class] = field(default_factory=dict)\n    slots: Dict[str, Slot] = field(default_factory=dict)\n    types: Dict[str, Type] = field(default_factory=dict)\n\n    def __post_init__(self):\n        if not self.title:\n            self.title = self.name\n</code></pre>"},{"location":"#lodstorage.linkml.Slot","title":"<code>Slot</code>","text":"<p>Represents a slot in the LinkML schema, equivalent to a field or property.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Slot:\n    \"\"\"\n    Represents a slot in the LinkML schema, equivalent to a field or property.\n    \"\"\"\n\n    description: str\n    range: str = \"string\"\n    multivalued: bool = False\n    identifier: bool = False\n</code></pre>"},{"location":"#lodstorage.linkml_gen","title":"<code>linkml_gen</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.linkml_gen.LinkMLGen","title":"<code>LinkMLGen</code>","text":"<p>Class for generating LinkML YAML schema from Python data models using dataclasses.</p> Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>class LinkMLGen:\n    \"\"\"\n    Class for generating LinkML YAML schema from Python data models using dataclasses.\n    \"\"\"\n\n    def __init__(self, schema: Schema):\n        \"\"\"\n        Initialize the LinkMLGen.\n\n        Args:\n            schema (Schema): The LinkML schema to be generated.\n        \"\"\"\n        self.schema = schema\n\n    def gen_schema(self, data_model_class) -&gt; Schema:\n        # Use DocstringParser to extract class description\n        parser = DocstringParser()\n        class_description, doc_attributes = parser.parse(data_model_class.__doc__)\n\n        class_name = data_model_class.__name__\n        new_class = Class(description=class_description, slots=[])\n\n        # Iterate over the fields of the dataclass\n        for field_info in fields(data_model_class):\n            attr_name = field_info.name\n            attr_type = field_info.type\n\n            # Handle Optional and List types\n            is_optional = False\n            is_list = False\n            content_type = None\n            if hasattr(attr_type, \"__origin__\"):\n                if attr_type.__origin__ is Union and type(None) in attr_type.__args__:\n                    is_optional = True\n                    attr_type = [t for t in attr_type.__args__ if t is not type(None)][\n                        0\n                    ]  # unwrap Optional type\n                elif attr_type.__origin__ is list:\n                    is_list = True\n                    content_type = attr_type.__args__[0]  # unwrap List type\n                elif attr_type.__origin__ is dict:\n                    # Assuming dictionary values are of interest, keys are strings\n                    content_type = attr_type.__args__[\n                        1\n                    ]  # unwrap Dict type, focusing on value type\n\n            # Check and handle nested dataclasses for lists or dicts\n            if is_dataclass(content_type):\n                # Recursive call to handle nested dataclass\n                self.gen_schema(content_type)\n                # Set the range to the name of the dataclass\n                linkml_range = (\n                    content_type.__name__\n                )  # Use the name of the dataclass as the range\n            elif is_list:\n                # If it's a list, get the LinkML range for the base type\n                # Use self.get_linkml_range to ensure consistent type mapping\n                linkml_range = PythonTypes.get_linkml_range(content_type)\n            else:\n                # For non-list and non-dataclass types, use self.get_linkml_range for consistent type mapping\n                linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n            # Extract description from doc_attributes\n            description = doc_attributes.get(attr_name, {}).get(\n                \"description\", f\"{attr_name} - missing description\"\n            )\n\n            # Create a new slot for the field\n            new_slot = Slot(\n                description=description, range=linkml_range, multivalued=is_list\n            )\n            self.schema.slots[attr_name] = new_slot\n            new_class.slots.append(attr_name)\n\n        self.schema.classes[class_name] = new_class\n        return self.schema\n\n    def gen_schema_from_instance(self, data_model_instance) -&gt; Schema:\n        \"\"\"\n        Generate a LinkML YAML schema from a Python data model using dataclasses.\n\n        Args:\n            data_model_instance: An instance of the Python data model.\n\n        Returns:\n            Schema: The LinkML schema generated from the data model.\n        \"\"\"\n        # Use DocstringParser to extract class description and attributes\n        parser = DocstringParser()\n        class_description, doc_attributes = parser.parse(data_model_instance.__doc__)\n\n        class_name = data_model_instance.__class__.__name__\n        new_class = Class(description=class_description, slots=[])\n\n        for field_info in fields(data_model_instance):\n            attr_name = field_info.name\n            attr_type = field_info.type\n\n            # Extract field type/range\n            linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n            # Check values for multivalued and type consistency\n            attr_value = getattr(data_model_instance, attr_name)\n            multivalued, actual_type = self.check_value(attr_value)\n\n            # Ensure documentation, declaration, and value type are consistent\n            self.ensure_consistency(\n                attr_name, linkml_range, actual_type, doc_attributes\n            )\n\n            # Prepare slot\n            description = doc_attributes.get(attr_name, {}).get(\n                \"description\", f\"{attr_name} - missing description\"\n            )\n            if attr_name not in self.schema.slots:\n                new_slot = Slot(\n                    description=description, range=linkml_range, multivalued=multivalued\n                )\n                self.schema.slots[attr_name] = new_slot\n                new_class.slots.append(attr_name)\n\n            if multivalued:\n                # recursive call if type of list or dict is a dataclass\n                if hasattr(attr_type, \"__args__\"):\n                    content_type = attr_type.__args__[\n                        0\n                    ]  # Get the declared content type\n                    if is_dataclass(content_type):\n                        self.gen_schema(content_type)\n\n        self.schema.classes[class_name] = new_class\n        return self.schema\n\n    def check_value(self, value):\n        # Method to check if the value is multivalued and determine its type\n        multivalued = isinstance(value, (Iterable, Mapping)) and not isinstance(\n            value, (str, bytes)\n        )\n        value_type = type(value).__name__\n        return multivalued, value_type\n\n    def ensure_consistency(self, name, declared_type, actual_type, doc_attributes):\n        # Adjust this method to handle complex types like list, dict, etc.\n\n        # Check if the actual type is a list or dict, and if so, get the type of its elements\n        if actual_type == \"list\" or actual_type == \"dict\":\n            # You may need a more complex logic here to handle lists of custom dataclasses\n            # For simplicity, let's assume it's a list of strings for now\n            actual_type = \"string\"\n\n        # Now compare the adjusted actual type with the declared type\n        if declared_type != actual_type:\n            raise ValueError(\n                f\"Type mismatch for '{name}': declared as '{declared_type}', actual type is '{actual_type}'\"\n            )\n\n        # Check for documentation\n        if name not in doc_attributes:\n            raise ValueError(f\"Missing documentation for field '{name}'\")\n</code></pre>"},{"location":"#lodstorage.linkml_gen.LinkMLGen.__init__","title":"<code>__init__(schema)</code>","text":"<p>Initialize the LinkMLGen.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The LinkML schema to be generated.</p> required Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>def __init__(self, schema: Schema):\n    \"\"\"\n    Initialize the LinkMLGen.\n\n    Args:\n        schema (Schema): The LinkML schema to be generated.\n    \"\"\"\n    self.schema = schema\n</code></pre>"},{"location":"#lodstorage.linkml_gen.LinkMLGen.gen_schema_from_instance","title":"<code>gen_schema_from_instance(data_model_instance)</code>","text":"<p>Generate a LinkML YAML schema from a Python data model using dataclasses.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_instance</code> <p>An instance of the Python data model.</p> required <p>Returns:</p> Name Type Description <code>Schema</code> <code>Schema</code> <p>The LinkML schema generated from the data model.</p> Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>def gen_schema_from_instance(self, data_model_instance) -&gt; Schema:\n    \"\"\"\n    Generate a LinkML YAML schema from a Python data model using dataclasses.\n\n    Args:\n        data_model_instance: An instance of the Python data model.\n\n    Returns:\n        Schema: The LinkML schema generated from the data model.\n    \"\"\"\n    # Use DocstringParser to extract class description and attributes\n    parser = DocstringParser()\n    class_description, doc_attributes = parser.parse(data_model_instance.__doc__)\n\n    class_name = data_model_instance.__class__.__name__\n    new_class = Class(description=class_description, slots=[])\n\n    for field_info in fields(data_model_instance):\n        attr_name = field_info.name\n        attr_type = field_info.type\n\n        # Extract field type/range\n        linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n        # Check values for multivalued and type consistency\n        attr_value = getattr(data_model_instance, attr_name)\n        multivalued, actual_type = self.check_value(attr_value)\n\n        # Ensure documentation, declaration, and value type are consistent\n        self.ensure_consistency(\n            attr_name, linkml_range, actual_type, doc_attributes\n        )\n\n        # Prepare slot\n        description = doc_attributes.get(attr_name, {}).get(\n            \"description\", f\"{attr_name} - missing description\"\n        )\n        if attr_name not in self.schema.slots:\n            new_slot = Slot(\n                description=description, range=linkml_range, multivalued=multivalued\n            )\n            self.schema.slots[attr_name] = new_slot\n            new_class.slots.append(attr_name)\n\n        if multivalued:\n            # recursive call if type of list or dict is a dataclass\n            if hasattr(attr_type, \"__args__\"):\n                content_type = attr_type.__args__[\n                    0\n                ]  # Get the declared content type\n                if is_dataclass(content_type):\n                    self.gen_schema(content_type)\n\n    self.schema.classes[class_name] = new_class\n    return self.schema\n</code></pre>"},{"location":"#lodstorage.lod","title":"<code>lod</code>","text":"<p>Created on 2021-01-31</p> <p>@author: wf</p>"},{"location":"#lodstorage.lod.LOD","title":"<code>LOD</code>","text":"<p>               Bases: <code>object</code></p> <p>list of Dict aka Table</p> Source code in <code>lodstorage/lod.py</code> <pre><code>class LOD(object):\n    \"\"\"\n    list of Dict aka Table\n    \"\"\"\n\n    def __init__(self, name):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.name = name\n        pass\n\n    @staticmethod\n    def getFields(listOfDicts, sampleCount: int = None):\n        \"\"\"\n        Extract field names from a list of dictionaries.\n\n        Args:\n            listOfDicts: List of dictionaries to extract field names from\n            sampleCount: Number of dictionaries to sample. If None, all are sampled\n\n        Returns:\n            list: Field names found in the dictionaries, or None if listOfDicts is None\n        \"\"\"\n        if listOfDicts is None:\n            return None\n        if sampleCount is None:\n            sampleCount = len(listOfDicts)\n\n        fields = []\n        for i, row in enumerate(listOfDicts):\n            if i &gt;= sampleCount:\n                break\n            for key in row.keys():\n                if key not in fields:\n                    fields.append(key)\n        return fields\n\n    @staticmethod\n    def setNone4List(listOfDicts, fields):\n        \"\"\"\n        set the given fields to None for the records in the given listOfDicts\n        if they are not set\n        Args:\n            listOfDicts(list): the list of records to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        for record in listOfDicts:\n            LOD.setNone(record, fields)\n\n    @staticmethod\n    def setNone(record, fields):\n        \"\"\"\n        make sure the given fields in the given record are set to none\n        Args:\n            record(dict): the record to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        for field in fields:\n            if not field in record:\n                record[field] = None\n\n    \"\"\"\n    https://stackoverflow.com/questions/33542997/python-intersection-of-2-lists-of-dictionaries/33543164\n    \"\"\"\n\n    @staticmethod\n    def sortKey(d, key=None):\n        \"\"\"get the sort key for the given dict d with the given key\"\"\"\n        if key is None:\n            # https://stackoverflow.com/a/60765557/1497139\n            return hash(tuple(d.items()))\n        else:\n            return d[key]\n\n    @staticmethod\n    def intersect(listOfDict1, listOfDict2, key=None):\n        \"\"\"\n        get the  intersection of the two lists of Dicts by the given key\n        \"\"\"\n        i1 = iter(sorted(listOfDict1, key=lambda k: LOD.sortKey(k, key)))\n        i2 = iter(sorted(listOfDict2, key=lambda k: LOD.sortKey(k, key)))\n        c1 = next(i1)\n        c2 = next(i2)\n        lr = []\n        while True:\n            try:\n                val1 = LOD.sortKey(c1, key)\n                val2 = LOD.sortKey(c2, key)\n                if val1 &lt; val2:\n                    c1 = next(i1)\n                elif val1 &gt; val2:\n                    c2 = next(i2)\n                else:\n                    lr.append(c1)\n                    c1 = next(i1)\n                    c2 = next(i2)\n            except StopIteration:\n                break\n        return lr\n\n    @staticmethod\n    def addLookup(lookup, duplicates, record, value, withDuplicates: bool):\n        \"\"\"\n        add a single lookup result\n\n        Args:\n            lookup(dict): the lookup map\n            duplicates(list): the list of duplicates\n            record(dict): the current record\n            value(object): the current value to lookup\n            withDuplicates(bool): if True duplicates should be allowed and lists returned if False a separate duplicates\n            list is created\n        \"\"\"\n        if value in lookup:\n            if withDuplicates:\n                lookupResult = lookup[value]\n                lookupResult.append(record)\n            else:\n                duplicates.append(record)\n                return\n        else:\n            if withDuplicates:\n                lookupResult = [record]\n            else:\n                lookupResult = record\n        lookup[value] = lookupResult\n\n    @staticmethod\n    def getLookup(lod: list, attrName: str, withDuplicates: bool = False):\n        \"\"\"\n        create a lookup dictionary by the given attribute name for the given list of dicts\n\n        Args:\n            lod(list): the list of dicts to get the lookup dictionary for\n            attrName(str): the attribute to lookup\n            withDuplicates(bool): whether to retain single values or lists\n\n        Return:\n            a dictionary for lookup\n        \"\"\"\n        lookup = {}\n        duplicates = []\n        for record in lod:\n            value = None\n            if isinstance(record, dict):\n                if attrName in record:\n                    value = record[attrName]\n            else:\n                if hasattr(record, attrName):\n                    value = getattr(record, attrName)\n            if value is not None:\n                if isinstance(value, list):\n                    for listValue in value:\n                        LOD.addLookup(\n                            lookup, duplicates, record, listValue, withDuplicates\n                        )\n                else:\n                    LOD.addLookup(lookup, duplicates, record, value, withDuplicates)\n        if withDuplicates:\n            return lookup\n        else:\n            return lookup, duplicates\n\n    @classmethod\n    def handleListTypes(cls, lod, doFilter=False, separator=\",\"):\n        \"\"\"\n        handle list types in the given list of dicts\n\n        Args:\n            cls: this class\n            lod(list): a list of dicts\n            doFilter(bool): True if records containing lists value items should be filtered\n            separator(str): the separator to use when converting lists\n        \"\"\"\n        # see https://stackoverflow.com/a/1207485/1497139\n        for i in range(len(lod) - 1, -1, -1):\n            record = lod[i]\n            if isinstance(record, dict):\n                for key in record:\n                    value = record[key]\n                    if isinstance(value, list):\n                        if doFilter:\n                            del lod[i]\n                            continue\n                        else:\n                            newValue = separator.join(filter(None, value))\n                            record[key] = newValue\n\n    @staticmethod\n    def filterFields(lod: list, fields: list, reverse: bool = False):\n        \"\"\"\n        filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the\n        fields contained in the list depending on the state of the reverse parameter\n\n        Args:\n            lod(list): list of dicts from which the fields should be excluded\n            fields(list): list of fields that should be excluded from the lod\n            reverse(bool): If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.\n\n        Returns:\n            LoD\n        \"\"\"\n        res = []\n        for record in lod:\n            if reverse:\n                recordReduced = {d: record[d] for d in record if d in fields}\n            else:\n                recordReduced = {d: record[d] for d in record if d not in fields}\n            res.append(recordReduced)\n        return res\n</code></pre>"},{"location":"#lodstorage.lod.LOD.__init__","title":"<code>__init__(name)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/lod.py</code> <pre><code>def __init__(self, name):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.name = name\n    pass\n</code></pre>"},{"location":"#lodstorage.lod.LOD.addLookup","title":"<code>addLookup(lookup, duplicates, record, value, withDuplicates)</code>  <code>staticmethod</code>","text":"<p>add a single lookup result</p> <p>Parameters:</p> Name Type Description Default <code>lookup(dict)</code> <p>the lookup map</p> required <code>duplicates(list)</code> <p>the list of duplicates</p> required <code>record(dict)</code> <p>the current record</p> required <code>value(object)</code> <p>the current value to lookup</p> required <code>withDuplicates(bool)</code> <p>if True duplicates should be allowed and lists returned if False a separate duplicates</p> required Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef addLookup(lookup, duplicates, record, value, withDuplicates: bool):\n    \"\"\"\n    add a single lookup result\n\n    Args:\n        lookup(dict): the lookup map\n        duplicates(list): the list of duplicates\n        record(dict): the current record\n        value(object): the current value to lookup\n        withDuplicates(bool): if True duplicates should be allowed and lists returned if False a separate duplicates\n        list is created\n    \"\"\"\n    if value in lookup:\n        if withDuplicates:\n            lookupResult = lookup[value]\n            lookupResult.append(record)\n        else:\n            duplicates.append(record)\n            return\n    else:\n        if withDuplicates:\n            lookupResult = [record]\n        else:\n            lookupResult = record\n    lookup[value] = lookupResult\n</code></pre>"},{"location":"#lodstorage.lod.LOD.filterFields","title":"<code>filterFields(lod, fields, reverse=False)</code>  <code>staticmethod</code>","text":"<p>filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the fields contained in the list depending on the state of the reverse parameter</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>list of dicts from which the fields should be excluded</p> required <code>fields(list)</code> <p>list of fields that should be excluded from the lod</p> required <code>reverse(bool)</code> <p>If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.</p> required <p>Returns:</p> Type Description <p>LoD</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef filterFields(lod: list, fields: list, reverse: bool = False):\n    \"\"\"\n    filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the\n    fields contained in the list depending on the state of the reverse parameter\n\n    Args:\n        lod(list): list of dicts from which the fields should be excluded\n        fields(list): list of fields that should be excluded from the lod\n        reverse(bool): If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.\n\n    Returns:\n        LoD\n    \"\"\"\n    res = []\n    for record in lod:\n        if reverse:\n            recordReduced = {d: record[d] for d in record if d in fields}\n        else:\n            recordReduced = {d: record[d] for d in record if d not in fields}\n        res.append(recordReduced)\n    return res\n</code></pre>"},{"location":"#lodstorage.lod.LOD.getFields","title":"<code>getFields(listOfDicts, sampleCount=None)</code>  <code>staticmethod</code>","text":"<p>Extract field names from a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts</code> <p>List of dictionaries to extract field names from</p> required <code>sampleCount</code> <code>int</code> <p>Number of dictionaries to sample. If None, all are sampled</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Field names found in the dictionaries, or None if listOfDicts is None</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef getFields(listOfDicts, sampleCount: int = None):\n    \"\"\"\n    Extract field names from a list of dictionaries.\n\n    Args:\n        listOfDicts: List of dictionaries to extract field names from\n        sampleCount: Number of dictionaries to sample. If None, all are sampled\n\n    Returns:\n        list: Field names found in the dictionaries, or None if listOfDicts is None\n    \"\"\"\n    if listOfDicts is None:\n        return None\n    if sampleCount is None:\n        sampleCount = len(listOfDicts)\n\n    fields = []\n    for i, row in enumerate(listOfDicts):\n        if i &gt;= sampleCount:\n            break\n        for key in row.keys():\n            if key not in fields:\n                fields.append(key)\n    return fields\n</code></pre>"},{"location":"#lodstorage.lod.LOD.getLookup","title":"<code>getLookup(lod, attrName, withDuplicates=False)</code>  <code>staticmethod</code>","text":"<p>create a lookup dictionary by the given attribute name for the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to get the lookup dictionary for</p> required <code>attrName(str)</code> <p>the attribute to lookup</p> required <code>withDuplicates(bool)</code> <p>whether to retain single values or lists</p> required Return <p>a dictionary for lookup</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef getLookup(lod: list, attrName: str, withDuplicates: bool = False):\n    \"\"\"\n    create a lookup dictionary by the given attribute name for the given list of dicts\n\n    Args:\n        lod(list): the list of dicts to get the lookup dictionary for\n        attrName(str): the attribute to lookup\n        withDuplicates(bool): whether to retain single values or lists\n\n    Return:\n        a dictionary for lookup\n    \"\"\"\n    lookup = {}\n    duplicates = []\n    for record in lod:\n        value = None\n        if isinstance(record, dict):\n            if attrName in record:\n                value = record[attrName]\n        else:\n            if hasattr(record, attrName):\n                value = getattr(record, attrName)\n        if value is not None:\n            if isinstance(value, list):\n                for listValue in value:\n                    LOD.addLookup(\n                        lookup, duplicates, record, listValue, withDuplicates\n                    )\n            else:\n                LOD.addLookup(lookup, duplicates, record, value, withDuplicates)\n    if withDuplicates:\n        return lookup\n    else:\n        return lookup, duplicates\n</code></pre>"},{"location":"#lodstorage.lod.LOD.handleListTypes","title":"<code>handleListTypes(lod, doFilter=False, separator=',')</code>  <code>classmethod</code>","text":"<p>handle list types in the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>this class</p> required <code>lod(list)</code> <p>a list of dicts</p> required <code>doFilter(bool)</code> <p>True if records containing lists value items should be filtered</p> required <code>separator(str)</code> <p>the separator to use when converting lists</p> required Source code in <code>lodstorage/lod.py</code> <pre><code>@classmethod\ndef handleListTypes(cls, lod, doFilter=False, separator=\",\"):\n    \"\"\"\n    handle list types in the given list of dicts\n\n    Args:\n        cls: this class\n        lod(list): a list of dicts\n        doFilter(bool): True if records containing lists value items should be filtered\n        separator(str): the separator to use when converting lists\n    \"\"\"\n    # see https://stackoverflow.com/a/1207485/1497139\n    for i in range(len(lod) - 1, -1, -1):\n        record = lod[i]\n        if isinstance(record, dict):\n            for key in record:\n                value = record[key]\n                if isinstance(value, list):\n                    if doFilter:\n                        del lod[i]\n                        continue\n                    else:\n                        newValue = separator.join(filter(None, value))\n                        record[key] = newValue\n</code></pre>"},{"location":"#lodstorage.lod.LOD.intersect","title":"<code>intersect(listOfDict1, listOfDict2, key=None)</code>  <code>staticmethod</code>","text":"<p>get the  intersection of the two lists of Dicts by the given key</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef intersect(listOfDict1, listOfDict2, key=None):\n    \"\"\"\n    get the  intersection of the two lists of Dicts by the given key\n    \"\"\"\n    i1 = iter(sorted(listOfDict1, key=lambda k: LOD.sortKey(k, key)))\n    i2 = iter(sorted(listOfDict2, key=lambda k: LOD.sortKey(k, key)))\n    c1 = next(i1)\n    c2 = next(i2)\n    lr = []\n    while True:\n        try:\n            val1 = LOD.sortKey(c1, key)\n            val2 = LOD.sortKey(c2, key)\n            if val1 &lt; val2:\n                c1 = next(i1)\n            elif val1 &gt; val2:\n                c2 = next(i2)\n            else:\n                lr.append(c1)\n                c1 = next(i1)\n                c2 = next(i2)\n        except StopIteration:\n            break\n    return lr\n</code></pre>"},{"location":"#lodstorage.lod.LOD.setNone","title":"<code>setNone(record, fields)</code>  <code>staticmethod</code>","text":"<p>make sure the given fields in the given record are set to none Args:     record(dict): the record to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef setNone(record, fields):\n    \"\"\"\n    make sure the given fields in the given record are set to none\n    Args:\n        record(dict): the record to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    for field in fields:\n        if not field in record:\n            record[field] = None\n</code></pre>"},{"location":"#lodstorage.lod.LOD.setNone4List","title":"<code>setNone4List(listOfDicts, fields)</code>  <code>staticmethod</code>","text":"<p>set the given fields to None for the records in the given listOfDicts if they are not set Args:     listOfDicts(list): the list of records to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef setNone4List(listOfDicts, fields):\n    \"\"\"\n    set the given fields to None for the records in the given listOfDicts\n    if they are not set\n    Args:\n        listOfDicts(list): the list of records to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    for record in listOfDicts:\n        LOD.setNone(record, fields)\n</code></pre>"},{"location":"#lodstorage.lod.LOD.sortKey","title":"<code>sortKey(d, key=None)</code>  <code>staticmethod</code>","text":"<p>get the sort key for the given dict d with the given key</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef sortKey(d, key=None):\n    \"\"\"get the sort key for the given dict d with the given key\"\"\"\n    if key is None:\n        # https://stackoverflow.com/a/60765557/1497139\n        return hash(tuple(d.items()))\n    else:\n        return d[key]\n</code></pre>"},{"location":"#lodstorage.lod2xml","title":"<code>lod2xml</code>","text":"<p>Created on 2022-06-20</p> <p>see     https://github.com/tyleradams/json-toolkit     https://stackoverflow.com/questions/36021526/converting-an-array-dict-to-xml-in-python</p> <p>@author: tyleradams @author: wf</p>"},{"location":"#lodstorage.lod2xml.Lod2Xml","title":"<code>Lod2Xml</code>","text":"<p>convert a list of dicts to XML</p> Source code in <code>lodstorage/lod2xml.py</code> <pre><code>class Lod2Xml:\n    \"\"\"\n    convert a list of dicts to XML\n    \"\"\"\n\n    def __init__(\n        self, lod, root: str = \"root\", node_name: callable = (lambda x: \"node\")\n    ):\n        \"\"\"\n        construct me with the given list of dicts\n\n        Args:\n            lod (list): the list of dicts to convert to XML\n            root (str): the name of the root nod\n            item_name (func): the function to use to calculate node names\n        \"\"\"\n        self.lod = lod\n        self.root = root\n        self.item_name = node_name\n\n    def asXml(self, pretty: bool = True):\n        \"\"\"\n        convert result to XML\n\n        Args:\n            pretty (bool): if True pretty print the result\n\n        \"\"\"\n        xml = dicttoxml(\n            self.lod, custom_root=self.root, item_func=self.item_name, attr_type=False\n        )\n        if pretty:\n            dom = parseString(xml)\n            prettyXml = dom.toprettyxml()\n        else:\n            prettyXml = xml\n        return prettyXml\n</code></pre>"},{"location":"#lodstorage.lod2xml.Lod2Xml.__init__","title":"<code>__init__(lod, root='root', node_name=lambda x: 'node')</code>","text":"<p>construct me with the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>lod</code> <code>list</code> <p>the list of dicts to convert to XML</p> required <code>root</code> <code>str</code> <p>the name of the root nod</p> <code>'root'</code> <code>item_name</code> <code>func</code> <p>the function to use to calculate node names</p> required Source code in <code>lodstorage/lod2xml.py</code> <pre><code>def __init__(\n    self, lod, root: str = \"root\", node_name: callable = (lambda x: \"node\")\n):\n    \"\"\"\n    construct me with the given list of dicts\n\n    Args:\n        lod (list): the list of dicts to convert to XML\n        root (str): the name of the root nod\n        item_name (func): the function to use to calculate node names\n    \"\"\"\n    self.lod = lod\n    self.root = root\n    self.item_name = node_name\n</code></pre>"},{"location":"#lodstorage.lod2xml.Lod2Xml.asXml","title":"<code>asXml(pretty=True)</code>","text":"<p>convert result to XML</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>if True pretty print the result</p> <code>True</code> Source code in <code>lodstorage/lod2xml.py</code> <pre><code>def asXml(self, pretty: bool = True):\n    \"\"\"\n    convert result to XML\n\n    Args:\n        pretty (bool): if True pretty print the result\n\n    \"\"\"\n    xml = dicttoxml(\n        self.lod, custom_root=self.root, item_func=self.item_name, attr_type=False\n    )\n    if pretty:\n        dom = parseString(xml)\n        prettyXml = dom.toprettyxml()\n    else:\n        prettyXml = xml\n    return prettyXml\n</code></pre>"},{"location":"#lodstorage.lod_csv","title":"<code>lod_csv</code>","text":"<p>Created 2021</p> <p>@author: wf</p>"},{"location":"#lodstorage.lod_csv.CSV","title":"<code>CSV</code>","text":"<p>helper for converting data in csv format to list of dicts (LoD) and vice versa</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>class CSV:\n    \"\"\"\n    helper for converting data in csv format to list of dicts (LoD) and vice versa\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, dialect: str = \"excel\", quoting: int = csv.QUOTE_NONNUMERIC):\n        \"\"\"\n        constructor to set dialect and quoting defaults\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.dialect = dialect\n            cls._instance.quoting = quoting\n        return cls._instance\n\n    @classmethod\n    def get_instance(cls, dialect: str = \"excel\", quoting: int = csv.QUOTE_NONNUMERIC):\n        \"\"\"Get singleton instance of CSV class\"\"\"\n        return cls(dialect, quoting)\n\n    def restoreFromCSVFile(\n        self, filePath: str, headerNames: List[str] = None, withPostfix: bool = False\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        restore LOD from given csv file\n\n        Args:\n            filePath(str): file name\n            headerNames(List[str]): Names of the headers that should be used. If None it is assumed that the header is given.\n            withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n\n        Returns:\n            List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv file\n        \"\"\"\n        if not withPostfix:\n            filePath += \".csv\"\n        csvStr = self.readFile(filePath)\n        lod = self.fromCSV(csvStr, headerNames)\n        return lod\n\n    def fromCSV(\n        self,\n        csvString: str,\n        fields: List[str] = None,\n        dialect: str = None,\n        quoting: int = None,\n        **kwargs,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        convert given csv string to list of dicts (LOD)\n\n        Args:\n            csvString(str): csv string that should be converted to LOD\n            fields(List[str]): Names of the headers that should be used. If None it is assumed that the header is given.\n            dialect(str): CSV dialect to use\n            quoting(int): CSV quoting behavior\n\n        Returns:\n            List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv string\n        \"\"\"\n        if dialect is None:\n            dialect = self.dialect\n        if quoting is None:\n            quoting = self.quoting\n        csvStream = io.StringIO(csvString)\n        reader = csv.DictReader(\n            csvStream, fieldnames=fields, dialect=dialect, quoting=quoting, **kwargs\n        )\n        lod = list(reader)\n        self.fixTypes(lod)\n        return lod\n\n    def storeToCSVFile(\n        self, lod: List[Dict[str, Any]], filePath: str, withPostfix: bool = False\n    ):\n        \"\"\"\n        converts the given lod to CSV file.\n\n        Args:\n            lod(List[Dict[str, Any]]): lod that should be converted to csv file\n            filePath(str): file name the csv should be stored to\n            withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n        \"\"\"\n        if not withPostfix:\n            filePath += \".csv\"\n        csvStr = self.toCSV(lod)\n        self.writeFile(csvStr, filePath)\n\n    def toCSV(\n        self,\n        lod: List[Dict[str, Any]],\n        includeFields: List[str] = None,\n        excludeFields: List[str] = None,\n        dialect: str = None,\n        quoting: int = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"\n        converts the given lod to CSV string.\n\n        Args:\n            lod(List[Dict[str, Any]]): lod that should be converted to csv string\n            includeFields(List[str]): list of fields that should be included in the csv\n            excludeFields(List[str]): list of fields that should be excluded from the csv\n            dialect(str): CSV dialect to use\n            quoting(int): CSV quoting behavior\n\n        Returns:\n            str: csv string of the given lod\n        \"\"\"\n        if dialect is None:\n            dialect = self.dialect\n        if quoting is None:\n            quoting = self.quoting\n        if lod is None:\n            return \"\"\n        if excludeFields is not None:\n            lod = LOD.filterFields(lod, excludeFields)\n        if includeFields is None:\n            fields = LOD.getFields(lod)\n        else:\n            fields = includeFields\n            lod = LOD.filterFields(lod, includeFields, reverse=True)\n        csvStream = io.StringIO()\n        dict_writer = csv.DictWriter(\n            csvStream, fieldnames=fields, dialect=dialect, quoting=quoting, **kwargs\n        )\n        dict_writer.writeheader()\n        dict_writer.writerows(lod)\n        csvString = csvStream.getvalue()\n        return csvString\n\n    def readFile(self, filename: str) -&gt; str:\n        \"\"\"\n        Reads the given filename and returns it as string\n\n        Args:\n            filename(str): Name of the file that should be returned as string\n\n        Returns:\n            str: Content of the file as string\n        \"\"\"\n        with open(filename, \"r\") as file:\n            content = file.read()\n        return content\n\n    def writeFile(self, content: str, filename: str):\n        \"\"\"\n        Write the given str to the given filename\n\n        Args:\n            content(str): string that should be written into the file\n            filename(str): Name of the file the given str should be written to\n        \"\"\"\n        with open(filename, \"w\") as file:\n            file.write(content)\n\n    def fixTypes(self, lod: List[Dict[str, Any]]) -&gt; None:\n        \"\"\"\n        fixes the types of the given LoD.\n\n        Args:\n            lod(List[Dict[str, Any]]): List of dictionaries to fix types for\n        \"\"\"\n        for record in lod:\n            for key, value in record.items():\n                if value == \"\":\n                    record[key] = None\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.__new__","title":"<code>__new__(dialect='excel', quoting=csv.QUOTE_NONNUMERIC)</code>","text":"<p>constructor to set dialect and quoting defaults</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def __new__(cls, dialect: str = \"excel\", quoting: int = csv.QUOTE_NONNUMERIC):\n    \"\"\"\n    constructor to set dialect and quoting defaults\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance.dialect = dialect\n        cls._instance.quoting = quoting\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.fixTypes","title":"<code>fixTypes(lod)</code>","text":"<p>fixes the types of the given LoD.</p> <p>Parameters:</p> Name Type Description Default <code>lod(List[Dict[str,</code> <code>Any]]</code> <p>List of dictionaries to fix types for</p> required Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def fixTypes(self, lod: List[Dict[str, Any]]) -&gt; None:\n    \"\"\"\n    fixes the types of the given LoD.\n\n    Args:\n        lod(List[Dict[str, Any]]): List of dictionaries to fix types for\n    \"\"\"\n    for record in lod:\n        for key, value in record.items():\n            if value == \"\":\n                record[key] = None\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.fromCSV","title":"<code>fromCSV(csvString, fields=None, dialect=None, quoting=None, **kwargs)</code>","text":"<p>convert given csv string to list of dicts (LOD)</p> <p>Parameters:</p> Name Type Description Default <code>csvString(str)</code> <p>csv string that should be converted to LOD</p> required <code>fields(List[str])</code> <p>Names of the headers that should be used. If None it is assumed that the header is given.</p> required <code>dialect(str)</code> <p>CSV dialect to use</p> required <code>quoting(int)</code> <p>CSV quoting behavior</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv string</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def fromCSV(\n    self,\n    csvString: str,\n    fields: List[str] = None,\n    dialect: str = None,\n    quoting: int = None,\n    **kwargs,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    convert given csv string to list of dicts (LOD)\n\n    Args:\n        csvString(str): csv string that should be converted to LOD\n        fields(List[str]): Names of the headers that should be used. If None it is assumed that the header is given.\n        dialect(str): CSV dialect to use\n        quoting(int): CSV quoting behavior\n\n    Returns:\n        List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv string\n    \"\"\"\n    if dialect is None:\n        dialect = self.dialect\n    if quoting is None:\n        quoting = self.quoting\n    csvStream = io.StringIO(csvString)\n    reader = csv.DictReader(\n        csvStream, fieldnames=fields, dialect=dialect, quoting=quoting, **kwargs\n    )\n    lod = list(reader)\n    self.fixTypes(lod)\n    return lod\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.get_instance","title":"<code>get_instance(dialect='excel', quoting=csv.QUOTE_NONNUMERIC)</code>  <code>classmethod</code>","text":"<p>Get singleton instance of CSV class</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@classmethod\ndef get_instance(cls, dialect: str = \"excel\", quoting: int = csv.QUOTE_NONNUMERIC):\n    \"\"\"Get singleton instance of CSV class\"\"\"\n    return cls(dialect, quoting)\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.readFile","title":"<code>readFile(filename)</code>","text":"<p>Reads the given filename and returns it as string</p> <p>Parameters:</p> Name Type Description Default <code>filename(str)</code> <p>Name of the file that should be returned as string</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Content of the file as string</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def readFile(self, filename: str) -&gt; str:\n    \"\"\"\n    Reads the given filename and returns it as string\n\n    Args:\n        filename(str): Name of the file that should be returned as string\n\n    Returns:\n        str: Content of the file as string\n    \"\"\"\n    with open(filename, \"r\") as file:\n        content = file.read()\n    return content\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.restoreFromCSVFile","title":"<code>restoreFromCSVFile(filePath, headerNames=None, withPostfix=False)</code>","text":"<p>restore LOD from given csv file</p> <p>Parameters:</p> Name Type Description Default <code>filePath(str)</code> <p>file name</p> required <code>headerNames(List[str])</code> <p>Names of the headers that should be used. If None it is assumed that the header is given.</p> required <code>withPostfix(bool)</code> <p>If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv file</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def restoreFromCSVFile(\n    self, filePath: str, headerNames: List[str] = None, withPostfix: bool = False\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    restore LOD from given csv file\n\n    Args:\n        filePath(str): file name\n        headerNames(List[str]): Names of the headers that should be used. If None it is assumed that the header is given.\n        withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n\n    Returns:\n        List[Dict[str, Any]]: list of dicts (LoD) containing the content of the given csv file\n    \"\"\"\n    if not withPostfix:\n        filePath += \".csv\"\n    csvStr = self.readFile(filePath)\n    lod = self.fromCSV(csvStr, headerNames)\n    return lod\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.storeToCSVFile","title":"<code>storeToCSVFile(lod, filePath, withPostfix=False)</code>","text":"<p>converts the given lod to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>lod(List[Dict[str,</code> <code>Any]]</code> <p>lod that should be converted to csv file</p> required <code>filePath(str)</code> <p>file name the csv should be stored to</p> required <code>withPostfix(bool)</code> <p>If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.</p> required Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def storeToCSVFile(\n    self, lod: List[Dict[str, Any]], filePath: str, withPostfix: bool = False\n):\n    \"\"\"\n    converts the given lod to CSV file.\n\n    Args:\n        lod(List[Dict[str, Any]]): lod that should be converted to csv file\n        filePath(str): file name the csv should be stored to\n        withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n    \"\"\"\n    if not withPostfix:\n        filePath += \".csv\"\n    csvStr = self.toCSV(lod)\n    self.writeFile(csvStr, filePath)\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.toCSV","title":"<code>toCSV(lod, includeFields=None, excludeFields=None, dialect=None, quoting=None, **kwargs)</code>","text":"<p>converts the given lod to CSV string.</p> <p>Parameters:</p> Name Type Description Default <code>lod(List[Dict[str,</code> <code>Any]]</code> <p>lod that should be converted to csv string</p> required <code>includeFields(List[str])</code> <p>list of fields that should be included in the csv</p> required <code>excludeFields(List[str])</code> <p>list of fields that should be excluded from the csv</p> required <code>dialect(str)</code> <p>CSV dialect to use</p> required <code>quoting(int)</code> <p>CSV quoting behavior</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>csv string of the given lod</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def toCSV(\n    self,\n    lod: List[Dict[str, Any]],\n    includeFields: List[str] = None,\n    excludeFields: List[str] = None,\n    dialect: str = None,\n    quoting: int = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"\n    converts the given lod to CSV string.\n\n    Args:\n        lod(List[Dict[str, Any]]): lod that should be converted to csv string\n        includeFields(List[str]): list of fields that should be included in the csv\n        excludeFields(List[str]): list of fields that should be excluded from the csv\n        dialect(str): CSV dialect to use\n        quoting(int): CSV quoting behavior\n\n    Returns:\n        str: csv string of the given lod\n    \"\"\"\n    if dialect is None:\n        dialect = self.dialect\n    if quoting is None:\n        quoting = self.quoting\n    if lod is None:\n        return \"\"\n    if excludeFields is not None:\n        lod = LOD.filterFields(lod, excludeFields)\n    if includeFields is None:\n        fields = LOD.getFields(lod)\n    else:\n        fields = includeFields\n        lod = LOD.filterFields(lod, includeFields, reverse=True)\n    csvStream = io.StringIO()\n    dict_writer = csv.DictWriter(\n        csvStream, fieldnames=fields, dialect=dialect, quoting=quoting, **kwargs\n    )\n    dict_writer.writeheader()\n    dict_writer.writerows(lod)\n    csvString = csvStream.getvalue()\n    return csvString\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.writeFile","title":"<code>writeFile(content, filename)</code>","text":"<p>Write the given str to the given filename</p> <p>Parameters:</p> Name Type Description Default <code>content(str)</code> <p>string that should be written into the file</p> required <code>filename(str)</code> <p>Name of the file the given str should be written to</p> required Source code in <code>lodstorage/lod_csv.py</code> <pre><code>def writeFile(self, content: str, filename: str):\n    \"\"\"\n    Write the given str to the given filename\n\n    Args:\n        content(str): string that should be written into the file\n        filename(str): Name of the file the given str should be written to\n    \"\"\"\n    with open(filename, \"w\") as file:\n        file.write(content)\n</code></pre>"},{"location":"#lodstorage.mwTable","title":"<code>mwTable</code>","text":"<p>Created on 2020-08-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.mwTable.MediaWikiTable","title":"<code>MediaWikiTable</code>","text":"<p>               Bases: <code>object</code></p> <p>helper for https://www.mediawiki.org/wiki/Help:Tables</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>class MediaWikiTable(object):\n    \"\"\"\n    helper for https://www.mediawiki.org/wiki/Help:Tables\n    \"\"\"\n\n    def __init__(\n        self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.colFormats = colFormats\n        cssDelim = \"\"\n        if wikiTable:\n            cWikiTable = \"wikitable\"\n            cssDelim = \" \"\n        else:\n            cWikiTable = \"\"\n        if sortable:\n            cSortable = \"sortable\"\n        else:\n            cSortable = \"\"\n\n        self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n        self.header = None\n        self.content = \"\"\n        self.end = \"\\n|}\\n\"\n        self.withNewLines = withNewLines\n        pass\n\n    def addHeader(self, record):\n        \"\"\"\n        add the given record as a \"sample\" header\n        \"\"\"\n        if self.withNewLines:\n            headerStart = \"|+\"\n            firstColDelim = \"\\n!\"\n            colDelim = firstColDelim\n        else:\n            headerStart = \"|+\\n\"\n            firstColDelim = \"!\"\n            colDelim = \"!!\"\n        self.header = headerStart\n        first = True\n        for key in record.keys():\n            if first:\n                delim = firstColDelim\n                first = False\n            else:\n                delim = colDelim\n            self.header += \"%s%s\" % (delim, key)\n\n    def addRow4Dict(self, record):\n        if self.header is None:\n            self.addHeader(record)\n        if self.withNewLines:\n            rowStart = \"\\n|-\"\n            colDelim = \"\\n|\"\n        else:\n            rowStart = \"\\n|-\\n\"\n            colDelim = \"||\"\n        self.content += rowStart\n        for key in record.keys():\n            value = record[key]\n            if self.colFormats is not None and key in self.colFormats:\n                colFormat = self.colFormats[key]\n            else:\n                colFormat = \"%s\"\n            self.content += (\"%s\" + colFormat) % (colDelim, value)\n\n    def fromListOfDicts(self, listOfDicts):\n        for record in listOfDicts:\n            self.addRow4Dict(record)\n        pass\n\n    def noneReplace(self, value):\n        return \"\" if value is None else value\n\n    def asWikiMarkup(self):\n        \"\"\"\n        convert me to MediaWiki markup\n\n        Returns:\n            string: the MediWiki Markup for this table\n        \"\"\"\n        markup = (\n            self.noneReplace(self.start)\n            + self.noneReplace(self.header)\n            + self.noneReplace(self.content)\n            + self.noneReplace(self.end)\n        )\n        return markup\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.__init__","title":"<code>__init__(wikiTable=True, colFormats=None, sortable=True, withNewLines=False)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def __init__(\n    self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.colFormats = colFormats\n    cssDelim = \"\"\n    if wikiTable:\n        cWikiTable = \"wikitable\"\n        cssDelim = \" \"\n    else:\n        cWikiTable = \"\"\n    if sortable:\n        cSortable = \"sortable\"\n    else:\n        cSortable = \"\"\n\n    self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n    self.header = None\n    self.content = \"\"\n    self.end = \"\\n|}\\n\"\n    self.withNewLines = withNewLines\n    pass\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.addHeader","title":"<code>addHeader(record)</code>","text":"<p>add the given record as a \"sample\" header</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def addHeader(self, record):\n    \"\"\"\n    add the given record as a \"sample\" header\n    \"\"\"\n    if self.withNewLines:\n        headerStart = \"|+\"\n        firstColDelim = \"\\n!\"\n        colDelim = firstColDelim\n    else:\n        headerStart = \"|+\\n\"\n        firstColDelim = \"!\"\n        colDelim = \"!!\"\n    self.header = headerStart\n    first = True\n    for key in record.keys():\n        if first:\n            delim = firstColDelim\n            first = False\n        else:\n            delim = colDelim\n        self.header += \"%s%s\" % (delim, key)\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>convert me to MediaWiki markup</p> <p>Returns:</p> Name Type Description <code>string</code> <p>the MediWiki Markup for this table</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def asWikiMarkup(self):\n    \"\"\"\n    convert me to MediaWiki markup\n\n    Returns:\n        string: the MediWiki Markup for this table\n    \"\"\"\n    markup = (\n        self.noneReplace(self.start)\n        + self.noneReplace(self.header)\n        + self.noneReplace(self.content)\n        + self.noneReplace(self.end)\n    )\n    return markup\n</code></pre>"},{"location":"#lodstorage.mysql","title":"<code>mysql</code>","text":"<p>mysql.py:</p> <p>MySQL and MariaDB support</p>"},{"location":"#lodstorage.mysql.MySqlQuery","title":"<code>MySqlQuery</code>","text":"<p>A class to manage and execute mySQL queries with optional debugging.</p> <p>Attributes:</p> Name Type Description <code>endpoint_info</code> <code>Endpoint</code> <p>endpoint configuration.</p> <code>debug</code> <code>bool</code> <p>Flag to enable debugging.</p> Source code in <code>lodstorage/mysql.py</code> <pre><code>class MySqlQuery:\n    \"\"\"\n    A class to manage and execute mySQL queries with optional debugging.\n\n    Attributes:\n        endpoint_info (Endpoint): endpoint configuration.\n        debug (bool): Flag to enable debugging.\n    \"\"\"\n\n    def __init__(self, endpoint: Endpoint, debug: bool = False):\n        \"\"\"\n        Initializes the Query class with command-line arguments.\n\n        Args:\n            endpoint (Endpoint): endpoint configuration.\n            debug (bool): Flag to enable debugging.\n        \"\"\"\n        self.db_params = {\n            \"host\": endpoint.host or \"localhost\",\n            \"port\": endpoint.port or 3306,\n            \"user\": endpoint.user or \"root\",\n            \"password\": endpoint.password,\n            \"database\": endpoint.database,\n            \"charset\": endpoint.charset or \"utf8mb4\",\n            \"use_unicode\": True,  # ensure proper unicode handling\n        }\n\n        self.debug = debug\n\n    def get_cursor(self, query: str):\n        if self.debug:\n            logging.debug(f\"Executing query: {query}\")\n            logging.debug(f\"With connection parameters: {self.db_params}\")\n\n        connection = pymysql.connect(**self.db_params)\n        cursor = connection.cursor(pymysql.cursors.DictCursor)\n        return connection, cursor\n\n    def decode_record(self, record: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts binary values to UTF-8 strings.\n\n        Args:\n            data (Dict[str, Any]): Raw database row data\n\n        Returns:\n            Dict[str, Any]: Data with binary values decoded to strings\n        \"\"\"\n        decoded_record = {}\n        for key, value in record.items():\n            if isinstance(value, bytes):\n                decoded_record[key] = value.decode(\"utf-8\", errors=\"replace\")\n            else:\n                decoded_record[key] = value\n        return decoded_record\n\n    def execute_sql_query(self, query: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Executes an SQL query using the provided connection parameters.\n\n        Args:\n            query (str): The SQL query to execute.\n            connection_params (dict): Database connection parameters.\n\n        Returns:\n            list: A list of dictionaries representing the query results.\n        \"\"\"\n        connection, cursor = self.get_cursor(query)\n        cursor.execute(query)\n        raw_lod = cursor.fetchall()\n        connection.close()\n        lod = []\n        for raw_row in raw_lod:\n            row = self.decode_record(raw_row)\n            lod.append(row)\n        return lod\n\n    def query_generator(self, query: str) -&gt; Generator[Dict[str, Any], None, None]:\n        \"\"\"\n        Generator for fetching records one by one from a SQL query.\n        \"\"\"\n        connection, cursor = self.get_cursor(query)\n        try:\n            cursor.execute(query)\n            while True:\n                raw_record = cursor.fetchone()\n                if not raw_record:\n                    break\n                record = self.decode_record(raw_record)\n                yield record\n\n        finally:\n            cursor.close()\n            connection.close()\n</code></pre>"},{"location":"#lodstorage.mysql.MySqlQuery.__init__","title":"<code>__init__(endpoint, debug=False)</code>","text":"<p>Initializes the Query class with command-line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Endpoint</code> <p>endpoint configuration.</p> required <code>debug</code> <code>bool</code> <p>Flag to enable debugging.</p> <code>False</code> Source code in <code>lodstorage/mysql.py</code> <pre><code>def __init__(self, endpoint: Endpoint, debug: bool = False):\n    \"\"\"\n    Initializes the Query class with command-line arguments.\n\n    Args:\n        endpoint (Endpoint): endpoint configuration.\n        debug (bool): Flag to enable debugging.\n    \"\"\"\n    self.db_params = {\n        \"host\": endpoint.host or \"localhost\",\n        \"port\": endpoint.port or 3306,\n        \"user\": endpoint.user or \"root\",\n        \"password\": endpoint.password,\n        \"database\": endpoint.database,\n        \"charset\": endpoint.charset or \"utf8mb4\",\n        \"use_unicode\": True,  # ensure proper unicode handling\n    }\n\n    self.debug = debug\n</code></pre>"},{"location":"#lodstorage.mysql.MySqlQuery.decode_record","title":"<code>decode_record(record)</code>","text":"<p>Converts binary values to UTF-8 strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Raw database row data</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Data with binary values decoded to strings</p> Source code in <code>lodstorage/mysql.py</code> <pre><code>def decode_record(self, record: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts binary values to UTF-8 strings.\n\n    Args:\n        data (Dict[str, Any]): Raw database row data\n\n    Returns:\n        Dict[str, Any]: Data with binary values decoded to strings\n    \"\"\"\n    decoded_record = {}\n    for key, value in record.items():\n        if isinstance(value, bytes):\n            decoded_record[key] = value.decode(\"utf-8\", errors=\"replace\")\n        else:\n            decoded_record[key] = value\n    return decoded_record\n</code></pre>"},{"location":"#lodstorage.mysql.MySqlQuery.execute_sql_query","title":"<code>execute_sql_query(query)</code>","text":"<p>Executes an SQL query using the provided connection parameters.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to execute.</p> required <code>connection_params</code> <code>dict</code> <p>Database connection parameters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>List[Dict[str, Any]]</code> <p>A list of dictionaries representing the query results.</p> Source code in <code>lodstorage/mysql.py</code> <pre><code>def execute_sql_query(self, query: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Executes an SQL query using the provided connection parameters.\n\n    Args:\n        query (str): The SQL query to execute.\n        connection_params (dict): Database connection parameters.\n\n    Returns:\n        list: A list of dictionaries representing the query results.\n    \"\"\"\n    connection, cursor = self.get_cursor(query)\n    cursor.execute(query)\n    raw_lod = cursor.fetchall()\n    connection.close()\n    lod = []\n    for raw_row in raw_lod:\n        row = self.decode_record(raw_row)\n        lod.append(row)\n    return lod\n</code></pre>"},{"location":"#lodstorage.mysql.MySqlQuery.query_generator","title":"<code>query_generator(query)</code>","text":"<p>Generator for fetching records one by one from a SQL query.</p> Source code in <code>lodstorage/mysql.py</code> <pre><code>def query_generator(self, query: str) -&gt; Generator[Dict[str, Any], None, None]:\n    \"\"\"\n    Generator for fetching records one by one from a SQL query.\n    \"\"\"\n    connection, cursor = self.get_cursor(query)\n    try:\n        cursor.execute(query)\n        while True:\n            raw_record = cursor.fetchone()\n            if not raw_record:\n                break\n            record = self.decode_record(raw_record)\n            yield record\n\n    finally:\n        cursor.close()\n        connection.close()\n</code></pre>"},{"location":"#lodstorage.params","title":"<code>params</code>","text":"<p>Created on 2024-05-06</p> <p>@author: wf</p>"},{"location":"#lodstorage.params.Param","title":"<code>Param</code>","text":"<p>a parameter  (input or output) for a query</p> Source code in <code>lodstorage/params.py</code> <pre><code>@lod_storable\nclass Param:\n    \"\"\"\n    a parameter  (input or output) for a query\n    \"\"\"\n\n    name: str\n    type: str  # python type\n    default_value: Optional[str] = None  # for input parameters only\n    range: Optional[list] = field(default=None)  # for output only\n    description: Optional[str] = None  # optional for doc/UI\n</code></pre>"},{"location":"#lodstorage.params.Params","title":"<code>Params</code>","text":"<p>parameter handling</p> Source code in <code>lodstorage/params.py</code> <pre><code>class Params:\n    \"\"\"\n    parameter handling\n    \"\"\"\n\n    def __init__(\n        self, query: str, illegal_chars: str = \"\"\"\"[;&lt;&gt;&amp;|]\"'\"\"\", with_audit: bool = True\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            query (str): the query to analyze for parameters\n            illegal_chars (str): chars that may not be in the values\n            with_audit (bool): if True audit parameters\n        \"\"\"\n        self.illegal_chars = illegal_chars\n        self.query = query\n        self.with_audit = with_audit\n        self.pattern = re.compile(r\"{{\\s*(\\w+)\\s*}}\")\n        self.params = self.pattern.findall(query)\n        self.params_dict = {param: \"\" for param in self.params}\n        self.has_params = len(self.params) &gt; 0\n\n    def set(self, params_dict: Dict):\n        \"\"\"\n        set my params\n        \"\"\"\n        self.params_dict = params_dict\n\n    def audit(self) -&gt; None:\n        \"\"\"\n        Audit the usage of parameters in the query.\n\n        Raises:\n            ValueError: If potentially malicious values are detected in the parameter dictionary.\n        \"\"\"\n        for param, value in self.params_dict.items():\n            if isinstance(value, str):\n                for char in self.illegal_chars:\n                    if char in value:\n                        raise ValueError(\n                            f\"Potentially malicious value detected for parameter '{param}'\"\n                        )\n\n    def apply_parameters(self) -&gt; str:\n        \"\"\"\n        Replace Jinja templates in the query with corresponding parameter values.\n\n        Returns:\n            str: The query with Jinja templates replaced by parameter values.\n        \"\"\"\n        if self.with_audit:\n            self.audit()\n        query = self.query\n        for param, value in self.params_dict.items():\n            pattern = re.compile(r\"{{\\s*\" + re.escape(param) + r\"\\s*\\}\\}\")\n            value_str = str(value)\n            query = re.sub(pattern, value_str, query)\n        return query\n\n    def apply_parameters_with_check(self, param_dict: dict = None) -&gt; str:\n        \"\"\"\n        Apply parameters to the query string with parameter checking.\n\n        This method checks if the query requires parameters. If parameters are required\n        but not provided, it raises an exception with a descriptive message. If parameters\n        are provided, it applies them to the query.\n\n        Args:\n            param_dict (dict, optional): A dictionary of parameter names and values.\n\n        Returns:\n            str: The query string with parameters applied, if applicable.\n\n        Raises:\n            Exception: If parameters are required but not provided.\n        \"\"\"\n        query = self.query\n        if self.has_params:\n            if not param_dict:\n                param_names = list(\n                    dict.fromkeys(self.params)\n                )  # remove duplicates while preserving order\n                if len(param_names) &gt; 3:\n                    displayed_params = \", \".join(param_names[:3]) + \", ...\"\n                else:\n                    displayed_params = \", \".join(param_names)\n                plural_suffix = \"s\" if len(param_names) &gt; 1 else \"\"\n                msg = f\"Query needs {len(param_names)} parameter{plural_suffix}: {displayed_params}\"\n                raise Exception(msg)\n            else:\n                self.set(param_dict)\n                query = self.apply_parameters()\n        return query\n</code></pre>"},{"location":"#lodstorage.params.Params.__init__","title":"<code>__init__(query, illegal_chars='\"[;&lt;&gt;&amp;|]\"\\'', with_audit=True)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>the query to analyze for parameters</p> required <code>illegal_chars</code> <code>str</code> <p>chars that may not be in the values</p> <code>'\"[;&lt;&gt;&amp;|]\"\\''</code> <code>with_audit</code> <code>bool</code> <p>if True audit parameters</p> <code>True</code> Source code in <code>lodstorage/params.py</code> <pre><code>def __init__(\n    self, query: str, illegal_chars: str = \"\"\"\"[;&lt;&gt;&amp;|]\"'\"\"\", with_audit: bool = True\n):\n    \"\"\"\n    constructor\n\n    Args:\n        query (str): the query to analyze for parameters\n        illegal_chars (str): chars that may not be in the values\n        with_audit (bool): if True audit parameters\n    \"\"\"\n    self.illegal_chars = illegal_chars\n    self.query = query\n    self.with_audit = with_audit\n    self.pattern = re.compile(r\"{{\\s*(\\w+)\\s*}}\")\n    self.params = self.pattern.findall(query)\n    self.params_dict = {param: \"\" for param in self.params}\n    self.has_params = len(self.params) &gt; 0\n</code></pre>"},{"location":"#lodstorage.params.Params.apply_parameters","title":"<code>apply_parameters()</code>","text":"<p>Replace Jinja templates in the query with corresponding parameter values.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The query with Jinja templates replaced by parameter values.</p> Source code in <code>lodstorage/params.py</code> <pre><code>def apply_parameters(self) -&gt; str:\n    \"\"\"\n    Replace Jinja templates in the query with corresponding parameter values.\n\n    Returns:\n        str: The query with Jinja templates replaced by parameter values.\n    \"\"\"\n    if self.with_audit:\n        self.audit()\n    query = self.query\n    for param, value in self.params_dict.items():\n        pattern = re.compile(r\"{{\\s*\" + re.escape(param) + r\"\\s*\\}\\}\")\n        value_str = str(value)\n        query = re.sub(pattern, value_str, query)\n    return query\n</code></pre>"},{"location":"#lodstorage.params.Params.apply_parameters_with_check","title":"<code>apply_parameters_with_check(param_dict=None)</code>","text":"<p>Apply parameters to the query string with parameter checking.</p> <p>This method checks if the query requires parameters. If parameters are required but not provided, it raises an exception with a descriptive message. If parameters are provided, it applies them to the query.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>dict</code> <p>A dictionary of parameter names and values.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The query string with parameters applied, if applicable.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If parameters are required but not provided.</p> Source code in <code>lodstorage/params.py</code> <pre><code>def apply_parameters_with_check(self, param_dict: dict = None) -&gt; str:\n    \"\"\"\n    Apply parameters to the query string with parameter checking.\n\n    This method checks if the query requires parameters. If parameters are required\n    but not provided, it raises an exception with a descriptive message. If parameters\n    are provided, it applies them to the query.\n\n    Args:\n        param_dict (dict, optional): A dictionary of parameter names and values.\n\n    Returns:\n        str: The query string with parameters applied, if applicable.\n\n    Raises:\n        Exception: If parameters are required but not provided.\n    \"\"\"\n    query = self.query\n    if self.has_params:\n        if not param_dict:\n            param_names = list(\n                dict.fromkeys(self.params)\n            )  # remove duplicates while preserving order\n            if len(param_names) &gt; 3:\n                displayed_params = \", \".join(param_names[:3]) + \", ...\"\n            else:\n                displayed_params = \", \".join(param_names)\n            plural_suffix = \"s\" if len(param_names) &gt; 1 else \"\"\n            msg = f\"Query needs {len(param_names)} parameter{plural_suffix}: {displayed_params}\"\n            raise Exception(msg)\n        else:\n            self.set(param_dict)\n            query = self.apply_parameters()\n    return query\n</code></pre>"},{"location":"#lodstorage.params.Params.audit","title":"<code>audit()</code>","text":"<p>Audit the usage of parameters in the query.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If potentially malicious values are detected in the parameter dictionary.</p> Source code in <code>lodstorage/params.py</code> <pre><code>def audit(self) -&gt; None:\n    \"\"\"\n    Audit the usage of parameters in the query.\n\n    Raises:\n        ValueError: If potentially malicious values are detected in the parameter dictionary.\n    \"\"\"\n    for param, value in self.params_dict.items():\n        if isinstance(value, str):\n            for char in self.illegal_chars:\n                if char in value:\n                    raise ValueError(\n                        f\"Potentially malicious value detected for parameter '{param}'\"\n                    )\n</code></pre>"},{"location":"#lodstorage.params.Params.set","title":"<code>set(params_dict)</code>","text":"<p>set my params</p> Source code in <code>lodstorage/params.py</code> <pre><code>def set(self, params_dict: Dict):\n    \"\"\"\n    set my params\n    \"\"\"\n    self.params_dict = params_dict\n</code></pre>"},{"location":"#lodstorage.params.StoreDictKeyPair","title":"<code>StoreDictKeyPair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Custom argparse action to store key-value pairs as a dictionary.</p> <p>This class implements an argparse action to parse and store command-line arguments in the form of key-value pairs. The pairs should be separated by a comma and each key-value pair should be separated by an equals sign.</p> Example <p>--option key1=value1,key2=value2,key3=value3</p> Reference <p>https://stackoverflow.com/a/42355279/1497139</p> Source code in <code>lodstorage/params.py</code> <pre><code>class StoreDictKeyPair(argparse.Action):\n    \"\"\"\n    Custom argparse action to store key-value pairs as a dictionary.\n\n    This class implements an argparse action to parse and store command-line\n    arguments in the form of key-value pairs. The pairs should be separated by\n    a comma and each key-value pair should be separated by an equals sign.\n\n    Example:\n        --option key1=value1,key2=value2,key3=value3\n\n    Reference:\n        https://stackoverflow.com/a/42355279/1497139\n    \"\"\"\n\n    def __call__(\n        self,\n        _parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str,\n        _option_string: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Parse key-value pairs and store them as a dictionary in the namespace.\n\n        Args:\n            parser (argparse.ArgumentParser): The argument parser object.\n            namespace (argparse.Namespace): The namespace to store the parsed values.\n            values (str): The string containing key-value pairs separated by commas.\n            option_string (Optional[str]): The option string, if provided.\n        \"\"\"\n        my_dict = {}\n        for kv in values.split(\",\"):\n            k, v = kv.split(\"=\")\n            my_dict[k] = v\n        setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#lodstorage.params.StoreDictKeyPair.__call__","title":"<code>__call__(_parser, namespace, values, _option_string=None)</code>","text":"<p>Parse key-value pairs and store them as a dictionary in the namespace.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The argument parser object.</p> required <code>namespace</code> <code>Namespace</code> <p>The namespace to store the parsed values.</p> required <code>values</code> <code>str</code> <p>The string containing key-value pairs separated by commas.</p> required <code>option_string</code> <code>Optional[str]</code> <p>The option string, if provided.</p> required Source code in <code>lodstorage/params.py</code> <pre><code>def __call__(\n    self,\n    _parser: argparse.ArgumentParser,\n    namespace: argparse.Namespace,\n    values: str,\n    _option_string: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Parse key-value pairs and store them as a dictionary in the namespace.\n\n    Args:\n        parser (argparse.ArgumentParser): The argument parser object.\n        namespace (argparse.Namespace): The namespace to store the parsed values.\n        values (str): The string containing key-value pairs separated by commas.\n        option_string (Optional[str]): The option string, if provided.\n    \"\"\"\n    my_dict = {}\n    for kv in values.split(\",\"):\n        k, v = kv.split(\"=\")\n        my_dict[k] = v\n    setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#lodstorage.plot","title":"<code>plot</code>","text":"<p>Created on 2020-07-05</p> <p>@author: wf</p>"},{"location":"#lodstorage.plot.Plot","title":"<code>Plot</code>","text":"<p>               Bases: <code>object</code></p> <p>create Plot based on counters see https://stackoverflow.com/questions/19198920/using-counter-in-python-to-build-histogram</p> Source code in <code>lodstorage/plot.py</code> <pre><code>class Plot(object):\n    \"\"\"\n    create Plot based on counters\n    see https://stackoverflow.com/questions/19198920/using-counter-in-python-to-build-histogram\n    \"\"\"\n\n    def __init__(\n        self,\n        valueList,\n        title,\n        xlabel=None,\n        ylabel=None,\n        gformat=\".png\",\n        fontsize=12,\n        plotdir=None,\n        debug=False,\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.counter = Counter(valueList)\n        self.valueList = valueList\n        self.title = title\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n        self.fontsize = fontsize\n        self.gformat = gformat\n        self.debug = debug\n        path = os.path.dirname(__file__)\n        if plotdir is not None:\n            self.plotdir = plotdir\n        else:\n            self.plotdir = path + \"/../plots/\"\n            os.makedirs(self.plotdir, exist_ok=True)\n\n    def titleMe(self):\n        \"\"\"set my title and labels\"\"\"\n        plt.title(self.title, fontsize=self.fontsize)\n        if self.xlabel is not None:\n            plt.xlabel(self.xlabel)\n        if self.ylabel is not None:\n            plt.ylabel(self.ylabel)\n\n    def showMe(self, mode=\"show\", close=True):\n        \"\"\"show me in the given mode\"\"\"\n        if mode == \"show\":\n            plt.show()\n        else:\n            plt.savefig(self.plotdir + self.title + self.gformat)\n        if close:\n            plt.close()\n\n    def barchart(self, mode=\"show\"):\n        \"\"\"barchart based histogram for the given counter\"\"\"\n        labels, values = zip(*self.counter.items())\n        indexes = np.arange(len(labels))\n        width = 1\n        self.titleMe()\n        plt.bar(indexes, values, width)\n        plt.xticks(indexes + width * 0.5, labels)\n        plt.yticks(np.arange(1, max(values) + 1, step=1))\n        self.showMe(mode)\n\n    def showDebug(self):\n        print(\"   value  list: \", self.valueList)\n        print(\"counter  items: \", self.counter.items())\n        print(\"counter values: \", self.counter.values())\n        print(\"counter   keys: \", self.counter.keys())\n\n    def hist(self, mode=\"show\"):\n        \"\"\"create histogram for the given counter\"\"\"\n        if self.debug:\n            self.showDebug()\n        self.titleMe()\n        # see https://stackoverflow.com/a/2162045/1497139\n        plt.hist(self.valueList, bins=len(self.counter.keys()))\n        self.showMe(mode)\n        pass\n</code></pre>"},{"location":"#lodstorage.plot.Plot.__init__","title":"<code>__init__(valueList, title, xlabel=None, ylabel=None, gformat='.png', fontsize=12, plotdir=None, debug=False)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def __init__(\n    self,\n    valueList,\n    title,\n    xlabel=None,\n    ylabel=None,\n    gformat=\".png\",\n    fontsize=12,\n    plotdir=None,\n    debug=False,\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.counter = Counter(valueList)\n    self.valueList = valueList\n    self.title = title\n    self.xlabel = xlabel\n    self.ylabel = ylabel\n    self.fontsize = fontsize\n    self.gformat = gformat\n    self.debug = debug\n    path = os.path.dirname(__file__)\n    if plotdir is not None:\n        self.plotdir = plotdir\n    else:\n        self.plotdir = path + \"/../plots/\"\n        os.makedirs(self.plotdir, exist_ok=True)\n</code></pre>"},{"location":"#lodstorage.plot.Plot.barchart","title":"<code>barchart(mode='show')</code>","text":"<p>barchart based histogram for the given counter</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def barchart(self, mode=\"show\"):\n    \"\"\"barchart based histogram for the given counter\"\"\"\n    labels, values = zip(*self.counter.items())\n    indexes = np.arange(len(labels))\n    width = 1\n    self.titleMe()\n    plt.bar(indexes, values, width)\n    plt.xticks(indexes + width * 0.5, labels)\n    plt.yticks(np.arange(1, max(values) + 1, step=1))\n    self.showMe(mode)\n</code></pre>"},{"location":"#lodstorage.plot.Plot.hist","title":"<code>hist(mode='show')</code>","text":"<p>create histogram for the given counter</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def hist(self, mode=\"show\"):\n    \"\"\"create histogram for the given counter\"\"\"\n    if self.debug:\n        self.showDebug()\n    self.titleMe()\n    # see https://stackoverflow.com/a/2162045/1497139\n    plt.hist(self.valueList, bins=len(self.counter.keys()))\n    self.showMe(mode)\n    pass\n</code></pre>"},{"location":"#lodstorage.plot.Plot.showMe","title":"<code>showMe(mode='show', close=True)</code>","text":"<p>show me in the given mode</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def showMe(self, mode=\"show\", close=True):\n    \"\"\"show me in the given mode\"\"\"\n    if mode == \"show\":\n        plt.show()\n    else:\n        plt.savefig(self.plotdir + self.title + self.gformat)\n    if close:\n        plt.close()\n</code></pre>"},{"location":"#lodstorage.plot.Plot.titleMe","title":"<code>titleMe()</code>","text":"<p>set my title and labels</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def titleMe(self):\n    \"\"\"set my title and labels\"\"\"\n    plt.title(self.title, fontsize=self.fontsize)\n    if self.xlabel is not None:\n        plt.xlabel(self.xlabel)\n    if self.ylabel is not None:\n        plt.ylabel(self.ylabel)\n</code></pre>"},{"location":"#lodstorage.prefix_config","title":"<code>prefix_config</code>","text":"<p>Created on 2025-06-04</p> <p>@author: wf</p>"},{"location":"#lodstorage.prefix_config.PrefixConfig","title":"<code>PrefixConfig</code>  <code>dataclass</code>","text":"<p>Configuration for SPARQL prefixes</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>@dataclass\nclass PrefixConfig:\n    \"\"\"\n    Configuration for SPARQL prefixes\n    \"\"\"\n\n    name: str\n    wikidata_id: Optional[str] = None\n    url: Optional[str] = None\n    prefix_prefix: Optional[str] = None\n\n    description: Optional[str] = None\n    prefixes: Dict[str, str] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"\n        Set default values after initialization\n        \"\"\"\n        # nothing to do yet\n        pass\n\n    def as_text(self) -&gt; str:\n        \"\"\"\n        Get prefixes as formatted text block.\n\n        Returns:\n            str: Newline-separated prefix declarations\n        \"\"\"\n        text = \"\\n\".join(self.prefixes.values())\n        return text\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set default values after initialization</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Set default values after initialization\n    \"\"\"\n    # nothing to do yet\n    pass\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfig.as_text","title":"<code>as_text()</code>","text":"<p>Get prefixes as formatted text block.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Newline-separated prefix declarations</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>def as_text(self) -&gt; str:\n    \"\"\"\n    Get prefixes as formatted text block.\n\n    Returns:\n        str: Newline-separated prefix declarations\n    \"\"\"\n    text = \"\\n\".join(self.prefixes.values())\n    return text\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs","title":"<code>PrefixConfigs</code>","text":"<p>Collection of prefix configurations loaded from YAML.</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>@lod_storable\nclass PrefixConfigs:\n    \"\"\"Collection of prefix configurations loaded from YAML.\"\"\"\n\n    # ClassVars: IGNORED by @dataclass\n    # Enables singleton\n    _instance: ClassVar[Optional[\"PrefixConfigs\"]] = None\n    _prefixes_path: ClassVar[Optional[str]] = None\n\n    prefix_sets: Dict[str, PrefixConfig] = field(default_factory=dict)\n\n    @classmethod\n    def get_instance(cls) -&gt; \"PrefixConfigs\":\n        \"\"\"Get singleton PrefixConfigs (loads prefixes.yaml via YamlPath if needed).\"\"\"\n        if cls._instance is None:\n            cls._instance = cls.of_yaml()\n        return cls._instance\n\n    @classmethod\n    def preload(cls, prefixes_path: str) -&gt; \"PrefixConfigs\":\n        \"\"\"Preload singleton with specific prefixes path.\"\"\"\n        cls._instance = cls.of_yaml(prefixes_path)\n        cls._prefixes_path = prefixes_path\n        return cls._instance\n\n    @classmethod\n    def of_yaml(cls, yaml_path: str = None) -&gt; \"PrefixConfigs\":\n        \"\"\"Load from YAML (uses prefixes.yaml via YamlPath if yaml_path=None).\"\"\"\n        if yaml_path is None:\n            paths = YamlPath.getPaths(\"prefixes.yaml\")\n            yaml_path = paths[0] if paths else None\n        if yaml_path and os.path.exists(yaml_path):\n            prefix_configs = cls.load_from_yaml_file(yaml_path)\n        else:\n            prefix_configs = cls()  # Empty if no file\n        return prefix_configs\n\n    def __post_init__(self):\n        \"\"\"\n        initialize all prefixes and test prefix prefix for all prefix configs\n        \"\"\"\n        self.all_prefixes = {}\n        for key, prefix_config in self.prefix_sets.items():\n            if prefix_config.prefix_prefix is None:\n                prefix_config.prefix_prefix = key\n        self.all_prefixes.update(prefix_config.prefixes)\n        pass\n\n    def get_selected_declarations(self, prefix_set: List[str]) -&gt; str:\n        \"\"\"\n        Get PREFIX declarations for selected prefix sets.\n\n        Args:\n            prefix_set: List of prefix set names to include\n\n        Returns:\n            str: Combined PREFIX declarations\n        \"\"\"\n        selected_prefixes = {}\n        for prefix_set_name in prefix_set:\n            if prefix_set_name in self.prefix_sets:\n                prefix_config = self.prefix_sets[prefix_set_name]\n                selected_prefixes.update(prefix_config.prefixes)\n        declarations = self.get_prefix_declarations(selected_prefixes)\n        return declarations\n\n    def get_prefix_declarations(self, prefixes: Dict[str, str] = None) -&gt; str:\n        \"\"\"\n        Convert prefixes to PREFIX declarations.\n\n        Args:\n            prefixes: Dictionary of prefix mappings, defaults to all_prefixes\n\n        Returns:\n            str: Newline-separated PREFIX declarations\n        \"\"\"\n        if prefixes is None:\n            prefixes = self.all_prefixes\n        prefix_lines = []\n        for prefix_name, prefix_uri in prefixes.items():\n            prefix_lines.append(f\"PREFIX {prefix_name}: &lt;{prefix_uri}&gt;\")\n            declarations = \"\\n\".join(prefix_lines)\n        return declarations\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.__post_init__","title":"<code>__post_init__()</code>","text":"<p>initialize all prefixes and test prefix prefix for all prefix configs</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    initialize all prefixes and test prefix prefix for all prefix configs\n    \"\"\"\n    self.all_prefixes = {}\n    for key, prefix_config in self.prefix_sets.items():\n        if prefix_config.prefix_prefix is None:\n            prefix_config.prefix_prefix = key\n    self.all_prefixes.update(prefix_config.prefixes)\n    pass\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.get_instance","title":"<code>get_instance()</code>  <code>classmethod</code>","text":"<p>Get singleton PrefixConfigs (loads prefixes.yaml via YamlPath if needed).</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; \"PrefixConfigs\":\n    \"\"\"Get singleton PrefixConfigs (loads prefixes.yaml via YamlPath if needed).\"\"\"\n    if cls._instance is None:\n        cls._instance = cls.of_yaml()\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.get_prefix_declarations","title":"<code>get_prefix_declarations(prefixes=None)</code>","text":"<p>Convert prefixes to PREFIX declarations.</p> <p>Parameters:</p> Name Type Description Default <code>prefixes</code> <code>Dict[str, str]</code> <p>Dictionary of prefix mappings, defaults to all_prefixes</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Newline-separated PREFIX declarations</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>def get_prefix_declarations(self, prefixes: Dict[str, str] = None) -&gt; str:\n    \"\"\"\n    Convert prefixes to PREFIX declarations.\n\n    Args:\n        prefixes: Dictionary of prefix mappings, defaults to all_prefixes\n\n    Returns:\n        str: Newline-separated PREFIX declarations\n    \"\"\"\n    if prefixes is None:\n        prefixes = self.all_prefixes\n    prefix_lines = []\n    for prefix_name, prefix_uri in prefixes.items():\n        prefix_lines.append(f\"PREFIX {prefix_name}: &lt;{prefix_uri}&gt;\")\n        declarations = \"\\n\".join(prefix_lines)\n    return declarations\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.get_selected_declarations","title":"<code>get_selected_declarations(prefix_set)</code>","text":"<p>Get PREFIX declarations for selected prefix sets.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_set</code> <code>List[str]</code> <p>List of prefix set names to include</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Combined PREFIX declarations</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>def get_selected_declarations(self, prefix_set: List[str]) -&gt; str:\n    \"\"\"\n    Get PREFIX declarations for selected prefix sets.\n\n    Args:\n        prefix_set: List of prefix set names to include\n\n    Returns:\n        str: Combined PREFIX declarations\n    \"\"\"\n    selected_prefixes = {}\n    for prefix_set_name in prefix_set:\n        if prefix_set_name in self.prefix_sets:\n            prefix_config = self.prefix_sets[prefix_set_name]\n            selected_prefixes.update(prefix_config.prefixes)\n    declarations = self.get_prefix_declarations(selected_prefixes)\n    return declarations\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.of_yaml","title":"<code>of_yaml(yaml_path=None)</code>  <code>classmethod</code>","text":"<p>Load from YAML (uses prefixes.yaml via YamlPath if yaml_path=None).</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>@classmethod\ndef of_yaml(cls, yaml_path: str = None) -&gt; \"PrefixConfigs\":\n    \"\"\"Load from YAML (uses prefixes.yaml via YamlPath if yaml_path=None).\"\"\"\n    if yaml_path is None:\n        paths = YamlPath.getPaths(\"prefixes.yaml\")\n        yaml_path = paths[0] if paths else None\n    if yaml_path and os.path.exists(yaml_path):\n        prefix_configs = cls.load_from_yaml_file(yaml_path)\n    else:\n        prefix_configs = cls()  # Empty if no file\n    return prefix_configs\n</code></pre>"},{"location":"#lodstorage.prefix_config.PrefixConfigs.preload","title":"<code>preload(prefixes_path)</code>  <code>classmethod</code>","text":"<p>Preload singleton with specific prefixes path.</p> Source code in <code>lodstorage/prefix_config.py</code> <pre><code>@classmethod\ndef preload(cls, prefixes_path: str) -&gt; \"PrefixConfigs\":\n    \"\"\"Preload singleton with specific prefixes path.\"\"\"\n    cls._instance = cls.of_yaml(prefixes_path)\n    cls._prefixes_path = prefixes_path\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.prefixes","title":"<code>prefixes</code>","text":"<p>Created on 2024-03-02</p> <p>@author: wf</p>"},{"location":"#lodstorage.prefixes.Prefixes","title":"<code>Prefixes</code>","text":"<p>Handles the generation of standard SPARQL prefix declarations for queries. This utility class simplifies the inclusion of common prefixes used in SPARQL queries by providing a method to generate the necessary PREFIX lines based on a list of prefix keys.</p> <p>The class supports a wide range of prefixes relevant to Wikidata and general RDF/SPARQL usage, including RDF, RDFS, Wikibase, Schema.org, and more. It aims to reduce redundancy and improve clarity in SPARQL query construction by centralizing prefix management.</p> <p>Methods:</p> Name Description <code>getPrefixes</code> <p>Generates SPARQL PREFIX lines for a given list of prefix keys.</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>class Prefixes:\n    \"\"\"\n    Handles the generation of standard SPARQL prefix declarations for queries.\n    This utility class simplifies the inclusion of common prefixes used in SPARQL\n    queries by providing a method to generate the necessary PREFIX lines based on\n    a list of prefix keys.\n\n    The class supports a wide range of prefixes relevant to Wikidata and general RDF/SPARQL\n    usage, including RDF, RDFS, Wikibase, Schema.org, and more. It aims to reduce redundancy\n    and improve clarity in SPARQL query construction by centralizing prefix management.\n\n    Attributes:\n        None\n\n    Methods:\n        getPrefixes(prefixes): Generates SPARQL PREFIX lines for a given list of prefix keys.\n    \"\"\"\n\n    # see https://www.wikidata.org/wiki/EntitySchema:E49\n    prefixMap = {\n        \"bd\": \"&lt;http://www.bigdata.com/rdf#&gt;\",\n        \"cc\": \"&lt;http://creativecommons.org/ns#&gt;\",\n        \"dct\": \"&lt;http://purl.org/dc/terms/&gt;\",\n        \"geo\": \"&lt;http://www.opengis.net/ont/geosparql#&gt;\",\n        \"mwapi\": \"&lt;https://www.mediawiki.org/ontology#API/&gt;\",\n        \"ontolex\": \"&lt;http://www.w3.org/ns/lemon/ontolex#&gt;\",\n        \"owl\": \"&lt;http://www.w3.org/2002/07/owl#&gt;\",\n        \"p\": \"&lt;http://www.wikidata.org/prop/&gt;\",\n        \"pq\": \"&lt;http://www.wikidata.org/prop/qualifier/&gt;\",\n        \"pqn\": \"&lt;http://www.wikidata.org/prop/qualifier/value-normalized/&gt;\",\n        \"pqv\": \"&lt;http://www.wikidata.org/prop/qualifier/value/&gt;\",\n        \"pr\": \"&lt;http://www.wikidata.org/prop/reference/&gt;\",\n        \"prn\": \"&lt;http://www.wikidata.org/prop/reference/value-normalized/&gt;\",\n        \"prov\": \"&lt;http://www.w3.org/ns/prov#&gt;\",\n        \"prv\": \"&lt;http://www.wikidata.org/prop/reference/value/&gt;\",\n        \"ps\": \"&lt;http://www.wikidata.org/prop/statement/&gt;\",\n        \"psn\": \"&lt;http://www.wikidata.org/prop/statement/value-normalized/&gt;\",\n        \"psv\": \"&lt;http://www.wikidata.org/prop/statement/value/&gt;\",\n        \"rdf\": \"&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\",\n        \"rdfs\": \"&lt;http://www.w3.org/2000/01/rdf-schema#&gt;\",\n        \"schema\": \"&lt;http://schema.org/&gt;\",\n        \"skos\": \"&lt;http://www.w3.org/2004/02/skos/core#&gt;\",\n        \"wd\": \"&lt;http://www.wikidata.org/entity/&gt;\",\n        \"wdsubgraph\": \"&lt;https://query.wikidata.org/subgraph/&gt;\",\n        \"wdata\": \"&lt;http://www.wikidata.org/wiki/Special:EntityData/&gt;\",\n        \"wdno\": \"&lt;http://www.wikidata.org/prop/novalue/&gt;\",\n        \"wdref\": \"&lt;http://www.wikidata.org/reference/&gt;\",\n        \"wds\": \"&lt;http://www.wikidata.org/entity/statement/&gt;\",\n        \"wdt\": \"&lt;http://www.wikidata.org/prop/direct/&gt;\",\n        \"wdtn\": \"&lt;http://www.wikidata.org/prop/direct-normalized/&gt;\",\n        \"wdv\": \"&lt;http://www.wikidata.org/value/&gt;\",\n        \"wikibase\": \"&lt;http://wikiba.se/ontology#&gt;\",\n        \"xsd\": \"&lt;http://www.w3.org/2001/XMLSchema#&gt;\",\n    }\n\n    @classmethod\n    def getPrefixes(\n        cls, prefixes=[\"rdf\", \"rdfs\", \"schema\", \"wd\", \"wdt\", \"wikibase\", \"xsd\"]\n    ) -&gt; str:\n        \"\"\"Generates SPARQL PREFIX lines for a given list of prefix keys.\n\n        This method looks up URIs for the specified prefixes from a predefined map and constructs\n        PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n        and flexible specification of the prefixes needed for a particular query.\n\n        Args:\n            prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n                Defaults to a common set of prefixes used in Wikidata queries.\n\n        Returns:\n            str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n                with a newline character. If a prefix key is not recognized, it is ignored.\n\n        Example:\n            &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n            'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\\n'\n        \"\"\"\n\n        # see also https://www.wikidata.org/wiki/EntitySchema:E49\n        prefixes = cls.prefix_string(cls.prefixMap, prefixes)\n        return prefixes\n\n    @classmethod\n    def prefix_string(cls, prefix_dict: dict, prefix_keys: list[str]):\n        prefixes = \"\"\n        for prefix in prefix_keys:\n            if prefix in prefix_dict:\n                prefixes += cls.prefix_line(prefix_dict, prefix)\n        return prefixes\n\n    @classmethod\n    def prefix_line(cls, prefix_dict: dict, prefix: str) -&gt; str:\n        line = f\"PREFIX {prefix}: {prefix_dict[prefix]}\\n\"\n        return line\n\n    @classmethod\n    def extract_prefixes(cls, sparql_query: str) -&gt; dict:\n        \"\"\"\n        Extract only the explicitly declared prefixes from a SPARQL query string.\n        Simple regex-based extraction that finds PREFIX declarations in the query text.\n\n        Args:\n            sparql_query (str): The SPARQL query containing PREFIX declarations\n\n        Returns:\n            dict: Dictionary mapping prefix names to their URI strings\n        \"\"\"\n        declared_prefixes = {}\n\n        # Simple pattern to match PREFIX declarations: PREFIX name: &lt;uri&gt;\n        prefix_pattern = r\"PREFIX\\s+(\\w+):\\s*&lt;([^&gt;]+)&gt;\"\n\n        # Find all PREFIX declarations (case insensitive)\n        matches = re.findall(prefix_pattern, sparql_query, re.IGNORECASE)\n\n        # Convert matches to dictionary\n        for prefix_name, uri in matches:\n            declared_prefixes[prefix_name] = f\"&lt;{uri}&gt;\"\n\n        return declared_prefixes\n\n    @classmethod\n    def merge_prefix_dict(cls, query: str, prefix_dict: dict) -&gt; str:\n        \"\"\"\n        Merge prefixes from dict into SPARQL query by prepending missing prefix declarations.\n\n        Args:\n            query (str): The SPARQL query\n            prefix_dict (dict): Dictionary of prefixes to merge\n\n        Returns:\n            str: SPARQL query with missing prefixes prepended\n        \"\"\"\n        existing_prefixes = cls.extract_prefixes(query)\n        missing = set(prefix_dict.keys()) - set(existing_prefixes.keys())\n        prepend = cls.prefix_string(prefix_dict, list(missing))\n        query = prepend + query\n\n        return query\n\n    @classmethod\n    def merge_prefixes(cls, query: str, prefixes: str) -&gt; str:\n        \"\"\"\n        Merge prefixes from string into SPARQL query by prepending missing prefix declarations.\n\n        Args:\n            query (str): The SPARQL query\n            prefixes (str): String containing PREFIX declarations\n\n        Returns:\n            str: SPARQL query with missing prefixes prepended\n        \"\"\"\n        prefix_dict = cls.extract_prefixes(prefixes)\n        merged_query = cls.merge_prefix_dict(query, prefix_dict)\n        return merged_query\n</code></pre>"},{"location":"#lodstorage.prefixes.Prefixes.extract_prefixes","title":"<code>extract_prefixes(sparql_query)</code>  <code>classmethod</code>","text":"<p>Extract only the explicitly declared prefixes from a SPARQL query string. Simple regex-based extraction that finds PREFIX declarations in the query text.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The SPARQL query containing PREFIX declarations</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping prefix names to their URI strings</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>@classmethod\ndef extract_prefixes(cls, sparql_query: str) -&gt; dict:\n    \"\"\"\n    Extract only the explicitly declared prefixes from a SPARQL query string.\n    Simple regex-based extraction that finds PREFIX declarations in the query text.\n\n    Args:\n        sparql_query (str): The SPARQL query containing PREFIX declarations\n\n    Returns:\n        dict: Dictionary mapping prefix names to their URI strings\n    \"\"\"\n    declared_prefixes = {}\n\n    # Simple pattern to match PREFIX declarations: PREFIX name: &lt;uri&gt;\n    prefix_pattern = r\"PREFIX\\s+(\\w+):\\s*&lt;([^&gt;]+)&gt;\"\n\n    # Find all PREFIX declarations (case insensitive)\n    matches = re.findall(prefix_pattern, sparql_query, re.IGNORECASE)\n\n    # Convert matches to dictionary\n    for prefix_name, uri in matches:\n        declared_prefixes[prefix_name] = f\"&lt;{uri}&gt;\"\n\n    return declared_prefixes\n</code></pre>"},{"location":"#lodstorage.prefixes.Prefixes.getPrefixes","title":"<code>getPrefixes(prefixes=['rdf', 'rdfs', 'schema', 'wd', 'wdt', 'wikibase', 'xsd'])</code>  <code>classmethod</code>","text":"<p>Generates SPARQL PREFIX lines for a given list of prefix keys.</p> <pre><code>    This method looks up URIs for the specified prefixes from a predefined map and constructs\n    PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n    and flexible specification of the prefixes needed for a particular query.\n\n    Args:\n        prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n            Defaults to a common set of prefixes used in Wikidata queries.\n\n    Returns:\n        str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n            with a newline character. If a prefix key is not recognized, it is ignored.\n\n    Example:\n        &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n        'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n</code></pre> <p>PREFIX wdt: http://www.wikidata.org/prop/direct/ '</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>@classmethod\ndef getPrefixes(\n    cls, prefixes=[\"rdf\", \"rdfs\", \"schema\", \"wd\", \"wdt\", \"wikibase\", \"xsd\"]\n) -&gt; str:\n    \"\"\"Generates SPARQL PREFIX lines for a given list of prefix keys.\n\n    This method looks up URIs for the specified prefixes from a predefined map and constructs\n    PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n    and flexible specification of the prefixes needed for a particular query.\n\n    Args:\n        prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n            Defaults to a common set of prefixes used in Wikidata queries.\n\n    Returns:\n        str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n            with a newline character. If a prefix key is not recognized, it is ignored.\n\n    Example:\n        &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n        'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\\n'\n    \"\"\"\n\n    # see also https://www.wikidata.org/wiki/EntitySchema:E49\n    prefixes = cls.prefix_string(cls.prefixMap, prefixes)\n    return prefixes\n</code></pre>"},{"location":"#lodstorage.prefixes.Prefixes.merge_prefix_dict","title":"<code>merge_prefix_dict(query, prefix_dict)</code>  <code>classmethod</code>","text":"<p>Merge prefixes from dict into SPARQL query by prepending missing prefix declarations.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SPARQL query</p> required <code>prefix_dict</code> <code>dict</code> <p>Dictionary of prefixes to merge</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>SPARQL query with missing prefixes prepended</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>@classmethod\ndef merge_prefix_dict(cls, query: str, prefix_dict: dict) -&gt; str:\n    \"\"\"\n    Merge prefixes from dict into SPARQL query by prepending missing prefix declarations.\n\n    Args:\n        query (str): The SPARQL query\n        prefix_dict (dict): Dictionary of prefixes to merge\n\n    Returns:\n        str: SPARQL query with missing prefixes prepended\n    \"\"\"\n    existing_prefixes = cls.extract_prefixes(query)\n    missing = set(prefix_dict.keys()) - set(existing_prefixes.keys())\n    prepend = cls.prefix_string(prefix_dict, list(missing))\n    query = prepend + query\n\n    return query\n</code></pre>"},{"location":"#lodstorage.prefixes.Prefixes.merge_prefixes","title":"<code>merge_prefixes(query, prefixes)</code>  <code>classmethod</code>","text":"<p>Merge prefixes from string into SPARQL query by prepending missing prefix declarations.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SPARQL query</p> required <code>prefixes</code> <code>str</code> <p>String containing PREFIX declarations</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>SPARQL query with missing prefixes prepended</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>@classmethod\ndef merge_prefixes(cls, query: str, prefixes: str) -&gt; str:\n    \"\"\"\n    Merge prefixes from string into SPARQL query by prepending missing prefix declarations.\n\n    Args:\n        query (str): The SPARQL query\n        prefixes (str): String containing PREFIX declarations\n\n    Returns:\n        str: SPARQL query with missing prefixes prepended\n    \"\"\"\n    prefix_dict = cls.extract_prefixes(prefixes)\n    merged_query = cls.merge_prefix_dict(query, prefix_dict)\n    return merged_query\n</code></pre>"},{"location":"#lodstorage.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#lodstorage.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True, with_start: bool = True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        if with_start:\n            self.start()\n\n    def start(self):\n        \"\"\"\n        start profiling\n        \"\"\"\n        self.starttime = time.time()\n        if self.profile:\n            print(f\"Starting {self.msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True, with_start=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>lodstorage/profiler.py</code> <pre><code>def __init__(self, msg, profile=True, with_start: bool = True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    if with_start:\n        self.start()\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>def start(self):\n    \"\"\"\n    start profiling\n    \"\"\"\n    self.starttime = time.time()\n    if self.profile:\n        print(f\"Starting {self.msg} ...\")\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#lodstorage.query","title":"<code>query</code>","text":"<p>Created on 2020-08-22</p> <p>@author: wf</p>"},{"location":"#lodstorage.query.Endpoint","title":"<code>Endpoint</code>","text":"<p>a query endpoint</p> Source code in <code>lodstorage/query.py</code> <pre><code>@lod_storable\nclass Endpoint:\n    \"\"\"\n    a query endpoint\n    \"\"\"\n\n    # Basic identification\n    name: str = \"\"\n    description: Optional[str] = None\n\n    # Connection details\n    lang: str = \"SPARQL\"\n    endpoint: str = \"\"\n    website: Optional[str] = None\n    database: str = \"blazegraph\"\n    method: str = \"POST\"\n    # JDBC endpoints e.g. SQL\n    host: Optional[str] = \"localhost\"\n    port: Optional[int] = 3306\n    charset: Optional[str] = \"utf8mb4\"\n\n    # Authentication and rate limiting\n    calls_per_minute: Optional[int] = None\n    auth: Optional[str] = None\n    user: Optional[str] = None\n    password: Optional[str] = None\n\n    # Prefix handling\n    prefix_sets: Optional[List[str]] = None  # References to prefix set names\n    prefixes: Optional[str] = None  # Legacy: inline prefixes for backward compatibility\n\n    # Dataset characteristics\n    data_seeded: Optional[str] = (\n        None  # ISO date when data was initially seeded/imported: \"2012-10-29\"\n    )\n    auto_update: Optional[bool] = (\n        None  # if false data_seeded is the most recent state of data\n    )\n    mtriples: Optional[int] = None  # Dataset size in millions of triples\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"name\": \"wikidata\",\n                \"lang\": \"sparql\",\n                \"endpoint\": \"https://query.wikidata.org/sparql\",\n                \"website\": \"https://query.wikidata.org/\",\n                \"database\": \"blazegraph\",\n                \"method\": \"POST\",\n                \"calls_per_minute\": 30,\n                \"prefixes\": \"PREFIX bd: &lt;http://www.bigdata.com/rdf#&gt;\\nPREFIX cc: &lt;http://creativecommons.org/ns#&gt;\",\n            },\n            {\n                \"name\": \"dbis-jena\",\n                \"lang\": \"sparql\",\n                \"endpoint\": \"https://confident.dbis.rwth-aachen.de/jena/\",\n                \"website\": \"https://confident.dbis.rwth-aachen.de\",\n                \"auth\": \"BASIC\",\n                \"user\": \"secret\",\n                \"password\": \"#not public - example not usable for access#\",\n            },\n            {\n                \"name\": \"qlever-wikidata\",\n                \"lang\": \"sparql\",\n                \"method\": \"POST\",\n                \"database\": \"qlever\",\n                \"endpoint\": \"https://qlever.cs.uni-freiburg.de/api/wikidata\",\n                \"website\": \"https://qlever.cs.uni-freiburg.de/wikidata\",\n            },\n        ]\n        return samples\n\n    @classmethod\n    def getDefault(cls):\n        \"\"\"\n        get the default endpoint cofiguration\n        \"\"\"\n        sample_data = cls.getSamples()[0]\n        endpoint_conf = cls.from_dict(sample_data)\n        return endpoint_conf\n\n    def get_prefixes(self, prefix_configs: Optional[PrefixConfigs] = None) -&gt; str:\n        \"\"\"\n        Get prefix declarations for this endpoint.\n\n        Args:\n            prefix_configs: PrefixConfigs instance to resolve prefix_sets\n\n        Returns:\n            str: PREFIX declarations\n        \"\"\"\n        # default: empty\n        prefixes = \"\"\n        # Use inline prefixes if defined (legacy support)\n        if self.prefixes:\n            prefixes = self.prefixes\n\n        # Resolve from prefix_sets if available\n        if self.prefix_sets and prefix_configs:\n            prefixes = prefix_configs.get_selected_declarations(self.prefix_sets)\n\n        return prefixes\n\n    def __str__(self):\n        \"\"\"\n        Returns:\n            str: a string representation of this Endpoint\n        \"\"\"\n        text = f\"{self.name or ''}:{self.website or ''}:{self.endpoint or ''}({self.method or ''})\"\n        return text\n</code></pre>"},{"location":"#lodstorage.query.Endpoint.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>a string representation of this Endpoint</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns:\n        str: a string representation of this Endpoint\n    \"\"\"\n    text = f\"{self.name or ''}:{self.website or ''}:{self.endpoint or ''}({self.method or ''})\"\n    return text\n</code></pre>"},{"location":"#lodstorage.query.Endpoint.getDefault","title":"<code>getDefault()</code>  <code>classmethod</code>","text":"<p>get the default endpoint cofiguration</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef getDefault(cls):\n    \"\"\"\n    get the default endpoint cofiguration\n    \"\"\"\n    sample_data = cls.getSamples()[0]\n    endpoint_conf = cls.from_dict(sample_data)\n    return endpoint_conf\n</code></pre>"},{"location":"#lodstorage.query.Endpoint.get_prefixes","title":"<code>get_prefixes(prefix_configs=None)</code>","text":"<p>Get prefix declarations for this endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_configs</code> <code>Optional[PrefixConfigs]</code> <p>PrefixConfigs instance to resolve prefix_sets</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>PREFIX declarations</p> Source code in <code>lodstorage/query.py</code> <pre><code>def get_prefixes(self, prefix_configs: Optional[PrefixConfigs] = None) -&gt; str:\n    \"\"\"\n    Get prefix declarations for this endpoint.\n\n    Args:\n        prefix_configs: PrefixConfigs instance to resolve prefix_sets\n\n    Returns:\n        str: PREFIX declarations\n    \"\"\"\n    # default: empty\n    prefixes = \"\"\n    # Use inline prefixes if defined (legacy support)\n    if self.prefixes:\n        prefixes = self.prefixes\n\n    # Resolve from prefix_sets if available\n    if self.prefix_sets and prefix_configs:\n        prefixes = prefix_configs.get_selected_declarations(self.prefix_sets)\n\n    return prefixes\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager","title":"<code>EndpointManager</code>","text":"<p>               Bases: <code>object</code></p> <p>manages a set of SPARQL endpoints</p> Source code in <code>lodstorage/query.py</code> <pre><code>@lod_storable\nclass EndpointManager(object):\n    \"\"\"\n    manages a set of SPARQL endpoints\n    \"\"\"\n\n    endpoints: Dict[str, Endpoint] = field(default_factory=dict)\n\n    @classmethod\n    def ofYaml(cls, yaml_path: str) -&gt; \"EndpointManager\":\n        \"\"\"Load prefix configurations from YAML file.\"\"\"\n        em = cls.load_from_yaml_file(yaml_path)\n        return em\n\n    @classmethod\n    def getEndpoints(\n        cls, endpointPath: str = None, lang: str = None, with_default: bool = True\n    ):\n        \"\"\"\n        get the endpoints for the given endpointPath\n\n        Args:\n            endpointPath(str): the path to the yaml file with the endpoint configurations\n            lang(str): if lang is given filter by the given language\n            with_default(bool): if True include the default endpoints\n        \"\"\"\n        endpointPaths = YamlPath.getPaths(\n            \"endpoints.yaml\", endpointPath, with_default=with_default\n        )\n        endpoints = {}\n        for lEndpointPath in endpointPaths:\n            em = cls.ofYaml(lEndpointPath)\n            for name, endpoint in em.endpoints.items():\n                selected = lang is None or endpoint.lang == lang\n                if selected:\n                    endpoints[name] = endpoint\n                    endpoint.name = name\n        return endpoints\n\n    @staticmethod\n    def getEndpointNames(endpointPath=None, lang: str = None) -&gt; list:\n        \"\"\"\n        Returns a list of all available endpoint names\n        Args:\n            endpointPath(str): the path to the yaml file with the endpoint configurations\n            lang(str): if lang is given filter by the given language\n\n        \"\"\"\n        endpoints = EndpointManager.getEndpoints(endpointPath, lang=lang)\n        endpoint_names = list(endpoints.keys())\n        return endpoint_names\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager.getEndpointNames","title":"<code>getEndpointNames(endpointPath=None, lang=None)</code>  <code>staticmethod</code>","text":"<p>Returns a list of all available endpoint names Args:     endpointPath(str): the path to the yaml file with the endpoint configurations     lang(str): if lang is given filter by the given language</p> Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef getEndpointNames(endpointPath=None, lang: str = None) -&gt; list:\n    \"\"\"\n    Returns a list of all available endpoint names\n    Args:\n        endpointPath(str): the path to the yaml file with the endpoint configurations\n        lang(str): if lang is given filter by the given language\n\n    \"\"\"\n    endpoints = EndpointManager.getEndpoints(endpointPath, lang=lang)\n    endpoint_names = list(endpoints.keys())\n    return endpoint_names\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager.getEndpoints","title":"<code>getEndpoints(endpointPath=None, lang=None, with_default=True)</code>  <code>classmethod</code>","text":"<p>get the endpoints for the given endpointPath</p> <p>Parameters:</p> Name Type Description Default <code>endpointPath(str)</code> <p>the path to the yaml file with the endpoint configurations</p> required <code>lang(str)</code> <p>if lang is given filter by the given language</p> required <code>with_default(bool)</code> <p>if True include the default endpoints</p> required Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef getEndpoints(\n    cls, endpointPath: str = None, lang: str = None, with_default: bool = True\n):\n    \"\"\"\n    get the endpoints for the given endpointPath\n\n    Args:\n        endpointPath(str): the path to the yaml file with the endpoint configurations\n        lang(str): if lang is given filter by the given language\n        with_default(bool): if True include the default endpoints\n    \"\"\"\n    endpointPaths = YamlPath.getPaths(\n        \"endpoints.yaml\", endpointPath, with_default=with_default\n    )\n    endpoints = {}\n    for lEndpointPath in endpointPaths:\n        em = cls.ofYaml(lEndpointPath)\n        for name, endpoint in em.endpoints.items():\n            selected = lang is None or endpoint.lang == lang\n            if selected:\n                endpoints[name] = endpoint\n                endpoint.name = name\n    return endpoints\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager.ofYaml","title":"<code>ofYaml(yaml_path)</code>  <code>classmethod</code>","text":"<p>Load prefix configurations from YAML file.</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef ofYaml(cls, yaml_path: str) -&gt; \"EndpointManager\":\n    \"\"\"Load prefix configurations from YAML file.\"\"\"\n    em = cls.load_from_yaml_file(yaml_path)\n    return em\n</code></pre>"},{"location":"#lodstorage.query.Format","title":"<code>Format</code>","text":"<p>               Bases: <code>Enum</code></p> <p>the supported formats for the results to be delivered</p> Source code in <code>lodstorage/query.py</code> <pre><code>class Format(Enum):\n    \"\"\"\n    the supported formats for the results to be delivered\n    \"\"\"\n\n    csv = \"csv\"\n    json = \"json\"\n    html = \"html\"\n    xml = \"xml\"\n    tsv = \"tsv\"\n    latex = \"latex\"\n    mediawiki = \"mediawiki\"\n    raw = \"raw\"\n    github = \"github\"\n\n    def __str__(self):\n        return self.value\n</code></pre>"},{"location":"#lodstorage.query.Query","title":"<code>Query</code>","text":"<p>A Query e.g. for SPARQL</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>the name/label of the query</p> <code>query</code> <code>str</code> <p>the native Query text e.g. in SPARQL</p> <code>lang</code> <code>str</code> <p>the language of the query e.g. SPARQL</p> <code>sparql(str)</code> <code>str</code> <p>SPARQL querycode</p> <code>sql(str)</code> <code>str</code> <p>SQL query code</p> <code>ask(atr)</code> <code>str</code> <p>SMW ASK query code</p> <code>endpoint</code> <code>str</code> <p>the endpoint url to use</p> <code>database</code> <code>str</code> <p>the type of database e.g. \"blazegraph\"</p> <code>title</code> <code>str</code> <p>the header/title of the query</p> <code>description</code> <code>str</code> <p>the description of the query</p> <code>limit</code> <code>int</code> <p>the limit of the query</p> <code>prefixes</code> <code>list</code> <p>list of prefixes to be resolved</p> <code>tryItUrl</code> <code>str</code> <p>the url of a \"tryit\" webpage</p> <code>short_urls</code> <code>dict</code> <p>dictionary of short urls keyed by endpoint name</p> <code>formats</code> <code>list</code> <p>key,value pairs of ValueFormatters to be applied</p> <code>debug</code> <code>bool</code> <p>true if debug mode should be switched on</p> Source code in <code>lodstorage/query.py</code> <pre><code>@lod_storable\nclass Query:\n    \"\"\"\n    A Query e.g. for SPARQL\n\n    Attributes:\n        name (str): the name/label of the query\n        query (str): the native Query text e.g. in SPARQL\n        lang (str): the language of the query e.g. SPARQL\n\n        sparql(str): SPARQL querycode\n        sql(str): SQL query code\n        ask(atr): SMW ASK query code\n\n        endpoint (str): the endpoint url to use\n        database (str): the type of database e.g. \"blazegraph\"\n        title (str): the header/title of the query\n        description (str): the description of the query\n        limit (int): the limit of the query\n        prefixes (list): list of prefixes to be resolved\n        tryItUrl (str): the url of a \"tryit\" webpage\n        short_urls (dict): dictionary of short urls keyed by endpoint name\n        formats (list): key,value pairs of ValueFormatters to be applied\n        debug (bool): true if debug mode should be switched on\n    \"\"\"\n\n    name: str\n    query: str\n    lang: str = \"sparql\"\n    sparql: Optional[str] = None\n    sql: Optional[str] = None\n    ask: Optional[str] = None\n    endpoint: Optional[str] = None\n    database: str = \"blazegraph\"\n    title: Optional[str] = None\n    description: Optional[str] = \"\"\n    limit: Optional[int] = None\n    prefixes: Optional[List[str]] = None\n    tryItUrl: Optional[str] = None\n    short_urls: Dict[str, str] = field(default_factory=dict)\n    formats: Optional[List] = None\n    debug: bool = False\n    formatCallBacks: List = field(default_factory=list)\n    param_list: List[Param] = field(default_factory=list)  # input\n    output: List[Param] = field(default_factory=list)  # output\n\n    def __post_init__(self):\n        if self.title is None:\n            self.title = self.name\n        if self.query:\n            self.params = Params(self.query)\n\n    def __str__(self):\n        queryStr = \"\\n\".join(\n            [\n                f\"{key}:{value}\"\n                for key, value in self.__dict__.items()\n                if value is not None\n            ]\n        )\n        return f\"{queryStr}\"\n\n    def set_default_params(self, params_dict: Dict[str, Any]):\n        \"\"\"\n        set the default parameters for the given params_dict\n        \"\"\"\n        for param in self.param_list:\n            value = param.default_value\n            params_dict[param.name] = value\n\n    def apply_default_params(self):\n        \"\"\"\n        apply my default parameters\n        \"\"\"\n        self.set_default_params(self.params.params_dict)\n        self.params.apply_parameters()\n\n    def addFormatCallBack(self, callback):\n        self.formatCallBacks.append(callback)\n\n    def preFormatWithCallBacks(self, lod, tablefmt: str):\n        \"\"\"\n        run the configured call backs to pre-format the given list of dicts for the given tableformat\n\n        Args:\n            lod(list): the list of dicts to handle\n            tablefmt(str): the table format (according to tabulate) to apply\n\n        \"\"\"\n        for record in lod:\n            for key in record.keys():\n                value = record[key]\n                if value is not None:\n                    for formatCallBack in self.formatCallBacks:\n                        formatCallBack(record, key, value, tablefmt)\n\n    def formatWithValueFormatters(self, lod, tablefmt: str):\n        \"\"\"\n        format the given list of Dicts with the ValueFormatters\n        \"\"\"\n        # is there anything to do?\n        if self.formats is None:\n            # no\n            return\n        # get the value Formatters that might apply here\n        valueFormatters = ValueFormatters.get_instance()\n        formatsToApply = {}\n        for valueFormatSpec in self.formats:\n            parts = valueFormatSpec.split(\":\")\n            # e.g. president:wikidata\n            keytoformat = parts[0]\n            formatName = parts[1]\n            if formatName in valueFormatters.formatters:\n                formatsToApply[keytoformat] = valueFormatters.formatters[formatName]\n        for record in lod:\n            for keytoformat in formatsToApply:\n                valueFormatter = formatsToApply[keytoformat]\n                # format all key values\n                if keytoformat == \"*\":\n                    for key in record:\n                        valueFormatter.apply_format(record, key, tablefmt)\n                # or just a selected one\n                elif keytoformat in record:\n                    valueFormatter.apply_format(record, keytoformat, tablefmt)\n\n    def getTryItUrl(self, baseurl: str, database: str = \"blazegraph\"):\n        \"\"\"\n        return the \"try it!\" url for the given baseurl\n\n        Args:\n            baseurl(str): the baseurl to used\n\n        Returns:\n            str: the \"try it!\" url for the given query\n        \"\"\"\n        # https://stackoverflow.com/a/9345102/1497139\n        prefixed_query = str(self.query)\n        if self.prefixes:\n            prepend = \"\\n\".join(self.prefixes)\n            prefixed_query = prepend + prefixed_query\n        quoted = urllib.parse.quote(prefixed_query)\n        if database == \"blazegraph\":\n            delim = \"/#\"\n        else:\n            delim = \"?query=\"\n        url = f\"{baseurl}{delim}{quoted}\"\n        return url\n\n    def getLink(self, url, title, tablefmt):\n        \"\"\"\n        convert the given url and title to a link for the given tablefmt\n\n        Args:\n            url(str): the url to convert\n            title(str): the title to show\n            tablefmt(str): the table format to use\n        \"\"\"\n        # create a safe url\n        if url is None:\n            return \"\"\n        markup = f\"{title}:{url}\"\n        if tablefmt == \"mediawiki\":\n            markup = f\"[{url} {title}]\"\n        elif tablefmt == \"github\":\n            markup = f\"[{title}]({url})\"\n        elif tablefmt == \"latex\":\n            markup = r\"\\href{%s}{%s}\" % (url, title)\n        return markup\n\n    def add_endpoint_prefixes(\n        self, endpoint: \"Endpoint\", prefix_configs: PrefixConfigs\n    ) -&gt; None:\n        \"\"\"\n        Add endpoint-specific PREFIX declarations to this query (via prefix_sets or legacy prefixes).\n\n        Merges (deduplicates by prefix name) endpoint prefixes into self.query using Prefixes.merge_prefixes().\n        Updates self.prefixes to full unique PREFIX lines list. Safe/idempotent (no-op if prefixes_str empty).\n\n        Args:\n            endpoint (Endpoint): Endpoint config with prefix_sets or legacy prefixes.\n            prefix_configs (PrefixConfigs): Loaded prefix configurations resolver.\n        \"\"\"\n        prefixes_str = endpoint.get_prefixes(prefix_configs)\n        if not prefixes_str.strip():\n            return\n\n        # Merge: Prepend ONLY missing prefixes (no dups like 'rdfs')\n        self.query = Prefixes.merge_prefixes(self.query, prefixes_str)\n\n        # Update self.prefixes: Full unique lines from merged query\n        prefix_dict = Prefixes.extract_prefixes(self.query)\n        self.prefixes = [\n            Prefixes.prefix_line(prefix_dict, prefix) for prefix in sorted(prefix_dict)\n        ]\n\n    def prefixToLink(self, lod: list, prefix: str, tablefmt: str):\n        \"\"\"\n        convert url prefixes to link according to the given table format\n        TODO - refactor as preFormat callback\n\n        Args:\n            lod(list): the list of dicts to convert\n            prefix(str): the prefix to strip\n            tablefmt(str): the tabulate tableformat to use\n\n        \"\"\"\n        for record in lod:\n            for key in record.keys():\n                value = record[key]\n                if (\n                    value is not None\n                    and isinstance(value, str)\n                    and value.startswith(prefix)\n                ):\n                    item = value.replace(prefix, \"\")\n                    uqitem = urllib.parse.unquote(item)\n                    if tablefmt == \"latex\":\n                        link = uqitem\n                    else:\n                        link = self.getLink(value, uqitem, tablefmt)\n                    record[key] = link\n\n    def asWikiSourceMarkup(self):\n        \"\"\"\n        convert me to Mediawiki markup for syntax highlighting using the \"source\" tag\n\n\n        Returns:\n            string: the Markup\n        \"\"\"\n        markup = \"&lt;source lang='%s'&gt;\\n%s\\n&lt;/source&gt;\\n\" % (self.lang, self.query)\n        return markup\n\n    def asWikiMarkup(self, listOfDicts):\n        \"\"\"\n        convert the given listOfDicts result to MediaWiki markup\n\n        Args:\n            listOfDicts(list): the list of Dicts to convert to MediaWiki markup\n\n        Returns:\n            string: the markup\n        \"\"\"\n        if self.debug:\n            print(listOfDicts)\n        mwTable = MediaWikiTable()\n        mwTable.fromListOfDicts(listOfDicts)\n        markup = mwTable.asWikiMarkup()\n        return markup\n\n    def documentQueryResult(\n        self,\n        qlod: list,\n        limit=None,\n        tablefmt: str = \"mediawiki\",\n        tryItUrl: str = None,\n        withSourceCode=True,\n        **kwArgs,\n    ):\n        \"\"\"\n        document the given query results - note that a copy of the whole list is going to be created for being able to format\n\n        Args:\n            qlod: the list of dicts result\n            limit(int): the maximum number of records to display in result tabulate\n            tablefmt(str): the table format to use\n            tryItUrl: the \"try it!\" url to show\n            withSourceCode(bool): if True document the source code\n\n        Return:\n            str: the documentation tabular text for the given parameters\n        \"\"\"\n        sourceCode = self.query\n        tryItMarkup = \"\"\n        sourceCodeHeader = \"\"\n        resultHeader = \"\"\n        title = self.title\n        if limit is not None:\n            lod = copy.deepcopy(qlod[:limit])\n        else:\n            lod = copy.deepcopy(qlod)\n        self.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n        self.formatWithValueFormatters(lod, tablefmt=tablefmt)\n        result = tabulate(lod, headers=\"keys\", tablefmt=tablefmt, **kwArgs)\n        if tryItUrl is None and hasattr(self, \"tryItUrl\"):\n            tryItUrl = self.tryItUrl\n        if tablefmt == \"github\":\n            title = f\"## {self.title}\"\n            resultHeader = \"## result\"\n        elif tablefmt == \"mediawiki\":\n            title = f\"== {self.title} ==\"\n            resultHeader = \"=== result ===\"\n        elif tablefmt == \"latex\":\n            resultHeader = \"\"\n            result = r\"\"\"\\begin{table}\n            \\caption{%s}\n            \\label{tab:%s}\n            %s\n            \\end{table}\n            \"\"\" % (\n                self.title,\n                self.name,\n                result,\n            )\n        else:\n            title = f\"{self.title}\"\n            resultHeader = \"result:\"\n        if withSourceCode:\n            tryItUrlEncoded = self.getTryItUrl(tryItUrl, self.database)\n            tryItMarkup = self.getLink(tryItUrlEncoded, \"try it!\", tablefmt)\n            if tablefmt == \"github\":\n                sourceCodeHeader = \"### query\"\n                sourceCode = f\"\"\"```{self.lang}\n{self.query}\n```\"\"\"\n            elif tablefmt == \"mediawiki\":\n                sourceCodeHeader = \"=== query ===\"\n                sourceCode = f\"\"\"&lt;source lang='{self.lang}'&gt;\n{self.query}\n&lt;/source&gt;\n\"\"\"\n            elif tablefmt == \"latex\":\n                sourceCodeHeader = (\n                    r\"see query listing \\ref{listing:%s} and result table \\ref{tab:%s}\"\n                    % (self.name, self.name)\n                )\n                sourceCode = r\"\"\"\\begin{listing}[ht]\n\\caption{%s}\n\\label{listing:%s}\n\\begin{minted}{%s}\n%s\n\\end{minted}\n%s\n\\end{listing}\n\"\"\" % (\n                    self.title,\n                    self.name,\n                    self.lang.lower(),\n                    self.query,\n                    tryItMarkup,\n                )\n            else:\n                sourceCodeHeader = \"query:\"\n                sourceCode = f\"{self.query}\"\n        if self.lang != \"sparql\":\n            tryItMarkup = \"\"\n        queryResultDocumentation = QueryResultDocumentation(\n            query=self,\n            title=title,\n            tablefmt=tablefmt,\n            tryItMarkup=tryItMarkup,\n            sourceCodeHeader=sourceCodeHeader,\n            sourceCode=sourceCode,\n            resultHeader=resultHeader,\n            result=result,\n        )\n        return queryResultDocumentation\n</code></pre>"},{"location":"#lodstorage.query.Query.add_endpoint_prefixes","title":"<code>add_endpoint_prefixes(endpoint, prefix_configs)</code>","text":"<p>Add endpoint-specific PREFIX declarations to this query (via prefix_sets or legacy prefixes).</p> <p>Merges (deduplicates by prefix name) endpoint prefixes into self.query using Prefixes.merge_prefixes(). Updates self.prefixes to full unique PREFIX lines list. Safe/idempotent (no-op if prefixes_str empty).</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Endpoint</code> <p>Endpoint config with prefix_sets or legacy prefixes.</p> required <code>prefix_configs</code> <code>PrefixConfigs</code> <p>Loaded prefix configurations resolver.</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def add_endpoint_prefixes(\n    self, endpoint: \"Endpoint\", prefix_configs: PrefixConfigs\n) -&gt; None:\n    \"\"\"\n    Add endpoint-specific PREFIX declarations to this query (via prefix_sets or legacy prefixes).\n\n    Merges (deduplicates by prefix name) endpoint prefixes into self.query using Prefixes.merge_prefixes().\n    Updates self.prefixes to full unique PREFIX lines list. Safe/idempotent (no-op if prefixes_str empty).\n\n    Args:\n        endpoint (Endpoint): Endpoint config with prefix_sets or legacy prefixes.\n        prefix_configs (PrefixConfigs): Loaded prefix configurations resolver.\n    \"\"\"\n    prefixes_str = endpoint.get_prefixes(prefix_configs)\n    if not prefixes_str.strip():\n        return\n\n    # Merge: Prepend ONLY missing prefixes (no dups like 'rdfs')\n    self.query = Prefixes.merge_prefixes(self.query, prefixes_str)\n\n    # Update self.prefixes: Full unique lines from merged query\n    prefix_dict = Prefixes.extract_prefixes(self.query)\n    self.prefixes = [\n        Prefixes.prefix_line(prefix_dict, prefix) for prefix in sorted(prefix_dict)\n    ]\n</code></pre>"},{"location":"#lodstorage.query.Query.apply_default_params","title":"<code>apply_default_params()</code>","text":"<p>apply my default parameters</p> Source code in <code>lodstorage/query.py</code> <pre><code>def apply_default_params(self):\n    \"\"\"\n    apply my default parameters\n    \"\"\"\n    self.set_default_params(self.params.params_dict)\n    self.params.apply_parameters()\n</code></pre>"},{"location":"#lodstorage.query.Query.asWikiMarkup","title":"<code>asWikiMarkup(listOfDicts)</code>","text":"<p>convert the given listOfDicts result to MediaWiki markup</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of Dicts to convert to MediaWiki markup</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the markup</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asWikiMarkup(self, listOfDicts):\n    \"\"\"\n    convert the given listOfDicts result to MediaWiki markup\n\n    Args:\n        listOfDicts(list): the list of Dicts to convert to MediaWiki markup\n\n    Returns:\n        string: the markup\n    \"\"\"\n    if self.debug:\n        print(listOfDicts)\n    mwTable = MediaWikiTable()\n    mwTable.fromListOfDicts(listOfDicts)\n    markup = mwTable.asWikiMarkup()\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.asWikiSourceMarkup","title":"<code>asWikiSourceMarkup()</code>","text":"<p>convert me to Mediawiki markup for syntax highlighting using the \"source\" tag</p> <p>Returns:</p> Name Type Description <code>string</code> <p>the Markup</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asWikiSourceMarkup(self):\n    \"\"\"\n    convert me to Mediawiki markup for syntax highlighting using the \"source\" tag\n\n\n    Returns:\n        string: the Markup\n    \"\"\"\n    markup = \"&lt;source lang='%s'&gt;\\n%s\\n&lt;/source&gt;\\n\" % (self.lang, self.query)\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.documentQueryResult","title":"<code>documentQueryResult(qlod, limit=None, tablefmt='mediawiki', tryItUrl=None, withSourceCode=True, **kwArgs)</code>","text":"<p>document the given query results - note that a copy of the whole list is going to be created for being able to format</p> <p>Parameters:</p> Name Type Description Default <code>qlod</code> <code>list</code> <p>the list of dicts result</p> required <code>limit(int)</code> <p>the maximum number of records to display in result tabulate</p> required <code>tablefmt(str)</code> <p>the table format to use</p> required <code>tryItUrl</code> <code>str</code> <p>the \"try it!\" url to show</p> <code>None</code> <code>withSourceCode(bool)</code> <p>if True document the source code</p> required Return <p>str: the documentation tabular text for the given parameters</p> Source code in <code>lodstorage/query.py</code> <pre><code>    def documentQueryResult(\n        self,\n        qlod: list,\n        limit=None,\n        tablefmt: str = \"mediawiki\",\n        tryItUrl: str = None,\n        withSourceCode=True,\n        **kwArgs,\n    ):\n        \"\"\"\n        document the given query results - note that a copy of the whole list is going to be created for being able to format\n\n        Args:\n            qlod: the list of dicts result\n            limit(int): the maximum number of records to display in result tabulate\n            tablefmt(str): the table format to use\n            tryItUrl: the \"try it!\" url to show\n            withSourceCode(bool): if True document the source code\n\n        Return:\n            str: the documentation tabular text for the given parameters\n        \"\"\"\n        sourceCode = self.query\n        tryItMarkup = \"\"\n        sourceCodeHeader = \"\"\n        resultHeader = \"\"\n        title = self.title\n        if limit is not None:\n            lod = copy.deepcopy(qlod[:limit])\n        else:\n            lod = copy.deepcopy(qlod)\n        self.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n        self.formatWithValueFormatters(lod, tablefmt=tablefmt)\n        result = tabulate(lod, headers=\"keys\", tablefmt=tablefmt, **kwArgs)\n        if tryItUrl is None and hasattr(self, \"tryItUrl\"):\n            tryItUrl = self.tryItUrl\n        if tablefmt == \"github\":\n            title = f\"## {self.title}\"\n            resultHeader = \"## result\"\n        elif tablefmt == \"mediawiki\":\n            title = f\"== {self.title} ==\"\n            resultHeader = \"=== result ===\"\n        elif tablefmt == \"latex\":\n            resultHeader = \"\"\n            result = r\"\"\"\\begin{table}\n            \\caption{%s}\n            \\label{tab:%s}\n            %s\n            \\end{table}\n            \"\"\" % (\n                self.title,\n                self.name,\n                result,\n            )\n        else:\n            title = f\"{self.title}\"\n            resultHeader = \"result:\"\n        if withSourceCode:\n            tryItUrlEncoded = self.getTryItUrl(tryItUrl, self.database)\n            tryItMarkup = self.getLink(tryItUrlEncoded, \"try it!\", tablefmt)\n            if tablefmt == \"github\":\n                sourceCodeHeader = \"### query\"\n                sourceCode = f\"\"\"```{self.lang}\n{self.query}\n```\"\"\"\n            elif tablefmt == \"mediawiki\":\n                sourceCodeHeader = \"=== query ===\"\n                sourceCode = f\"\"\"&lt;source lang='{self.lang}'&gt;\n{self.query}\n&lt;/source&gt;\n\"\"\"\n            elif tablefmt == \"latex\":\n                sourceCodeHeader = (\n                    r\"see query listing \\ref{listing:%s} and result table \\ref{tab:%s}\"\n                    % (self.name, self.name)\n                )\n                sourceCode = r\"\"\"\\begin{listing}[ht]\n\\caption{%s}\n\\label{listing:%s}\n\\begin{minted}{%s}\n%s\n\\end{minted}\n%s\n\\end{listing}\n\"\"\" % (\n                    self.title,\n                    self.name,\n                    self.lang.lower(),\n                    self.query,\n                    tryItMarkup,\n                )\n            else:\n                sourceCodeHeader = \"query:\"\n                sourceCode = f\"{self.query}\"\n        if self.lang != \"sparql\":\n            tryItMarkup = \"\"\n        queryResultDocumentation = QueryResultDocumentation(\n            query=self,\n            title=title,\n            tablefmt=tablefmt,\n            tryItMarkup=tryItMarkup,\n            sourceCodeHeader=sourceCodeHeader,\n            sourceCode=sourceCode,\n            resultHeader=resultHeader,\n            result=result,\n        )\n        return queryResultDocumentation\n</code></pre>"},{"location":"#lodstorage.query.Query.formatWithValueFormatters","title":"<code>formatWithValueFormatters(lod, tablefmt)</code>","text":"<p>format the given list of Dicts with the ValueFormatters</p> Source code in <code>lodstorage/query.py</code> <pre><code>def formatWithValueFormatters(self, lod, tablefmt: str):\n    \"\"\"\n    format the given list of Dicts with the ValueFormatters\n    \"\"\"\n    # is there anything to do?\n    if self.formats is None:\n        # no\n        return\n    # get the value Formatters that might apply here\n    valueFormatters = ValueFormatters.get_instance()\n    formatsToApply = {}\n    for valueFormatSpec in self.formats:\n        parts = valueFormatSpec.split(\":\")\n        # e.g. president:wikidata\n        keytoformat = parts[0]\n        formatName = parts[1]\n        if formatName in valueFormatters.formatters:\n            formatsToApply[keytoformat] = valueFormatters.formatters[formatName]\n    for record in lod:\n        for keytoformat in formatsToApply:\n            valueFormatter = formatsToApply[keytoformat]\n            # format all key values\n            if keytoformat == \"*\":\n                for key in record:\n                    valueFormatter.apply_format(record, key, tablefmt)\n            # or just a selected one\n            elif keytoformat in record:\n                valueFormatter.apply_format(record, keytoformat, tablefmt)\n</code></pre>"},{"location":"#lodstorage.query.Query.getLink","title":"<code>getLink(url, title, tablefmt)</code>","text":"<p>convert the given url and title to a link for the given tablefmt</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to convert</p> required <code>title(str)</code> <p>the title to show</p> required <code>tablefmt(str)</code> <p>the table format to use</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def getLink(self, url, title, tablefmt):\n    \"\"\"\n    convert the given url and title to a link for the given tablefmt\n\n    Args:\n        url(str): the url to convert\n        title(str): the title to show\n        tablefmt(str): the table format to use\n    \"\"\"\n    # create a safe url\n    if url is None:\n        return \"\"\n    markup = f\"{title}:{url}\"\n    if tablefmt == \"mediawiki\":\n        markup = f\"[{url} {title}]\"\n    elif tablefmt == \"github\":\n        markup = f\"[{title}]({url})\"\n    elif tablefmt == \"latex\":\n        markup = r\"\\href{%s}{%s}\" % (url, title)\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.getTryItUrl","title":"<code>getTryItUrl(baseurl, database='blazegraph')</code>","text":"<p>return the \"try it!\" url for the given baseurl</p> <p>Parameters:</p> Name Type Description Default <code>baseurl(str)</code> <p>the baseurl to used</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the \"try it!\" url for the given query</p> Source code in <code>lodstorage/query.py</code> <pre><code>def getTryItUrl(self, baseurl: str, database: str = \"blazegraph\"):\n    \"\"\"\n    return the \"try it!\" url for the given baseurl\n\n    Args:\n        baseurl(str): the baseurl to used\n\n    Returns:\n        str: the \"try it!\" url for the given query\n    \"\"\"\n    # https://stackoverflow.com/a/9345102/1497139\n    prefixed_query = str(self.query)\n    if self.prefixes:\n        prepend = \"\\n\".join(self.prefixes)\n        prefixed_query = prepend + prefixed_query\n    quoted = urllib.parse.quote(prefixed_query)\n    if database == \"blazegraph\":\n        delim = \"/#\"\n    else:\n        delim = \"?query=\"\n    url = f\"{baseurl}{delim}{quoted}\"\n    return url\n</code></pre>"},{"location":"#lodstorage.query.Query.preFormatWithCallBacks","title":"<code>preFormatWithCallBacks(lod, tablefmt)</code>","text":"<p>run the configured call backs to pre-format the given list of dicts for the given tableformat</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to handle</p> required <code>tablefmt(str)</code> <p>the table format (according to tabulate) to apply</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def preFormatWithCallBacks(self, lod, tablefmt: str):\n    \"\"\"\n    run the configured call backs to pre-format the given list of dicts for the given tableformat\n\n    Args:\n        lod(list): the list of dicts to handle\n        tablefmt(str): the table format (according to tabulate) to apply\n\n    \"\"\"\n    for record in lod:\n        for key in record.keys():\n            value = record[key]\n            if value is not None:\n                for formatCallBack in self.formatCallBacks:\n                    formatCallBack(record, key, value, tablefmt)\n</code></pre>"},{"location":"#lodstorage.query.Query.prefixToLink","title":"<code>prefixToLink(lod, prefix, tablefmt)</code>","text":"<p>convert url prefixes to link according to the given table format TODO - refactor as preFormat callback</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to convert</p> required <code>prefix(str)</code> <p>the prefix to strip</p> required <code>tablefmt(str)</code> <p>the tabulate tableformat to use</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def prefixToLink(self, lod: list, prefix: str, tablefmt: str):\n    \"\"\"\n    convert url prefixes to link according to the given table format\n    TODO - refactor as preFormat callback\n\n    Args:\n        lod(list): the list of dicts to convert\n        prefix(str): the prefix to strip\n        tablefmt(str): the tabulate tableformat to use\n\n    \"\"\"\n    for record in lod:\n        for key in record.keys():\n            value = record[key]\n            if (\n                value is not None\n                and isinstance(value, str)\n                and value.startswith(prefix)\n            ):\n                item = value.replace(prefix, \"\")\n                uqitem = urllib.parse.unquote(item)\n                if tablefmt == \"latex\":\n                    link = uqitem\n                else:\n                    link = self.getLink(value, uqitem, tablefmt)\n                record[key] = link\n</code></pre>"},{"location":"#lodstorage.query.Query.set_default_params","title":"<code>set_default_params(params_dict)</code>","text":"<p>set the default parameters for the given params_dict</p> Source code in <code>lodstorage/query.py</code> <pre><code>def set_default_params(self, params_dict: Dict[str, Any]):\n    \"\"\"\n    set the default parameters for the given params_dict\n    \"\"\"\n    for param in self.param_list:\n        value = param.default_value\n        params_dict[param.name] = value\n</code></pre>"},{"location":"#lodstorage.query.QueryManager","title":"<code>QueryManager</code>","text":"<p>               Bases: <code>object</code></p> <p>manages pre packaged Queries</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QueryManager(object):\n    \"\"\"\n    manages pre packaged Queries\n    \"\"\"\n\n    def __init__(\n        self, lang: str = None, debug=False, queriesPath=None, with_default: bool = True\n    ):\n        \"\"\"\n        Constructor\n        Args:\n            lang(str): the language to use for the queries sql or sparql\n            queriesPath(str): the path of the yaml file to load queries from\n            debug(bool): True if debug information should be shown\n            with_default(bool): if True also load the default yaml file\n        \"\"\"\n        if lang is None:\n            lang = \"sql\"\n        self.queriesByName = {}\n        self.lang = lang\n        self.debug = debug\n        queries = self.getQueries(queriesPath=queriesPath, with_default=with_default)\n        for name, queryDict in queries.items():\n            if self.lang in queryDict:\n                queryDict[\"name\"] = name\n                queryDict[\"lang\"] = self.lang\n                if not \"query\" in queryDict:\n                    queryDict[\"query\"] = queryDict[self.lang]\n                try:\n                    query = Query.from_dict(queryDict)\n                    query.debug = self.debug\n                    self.queriesByName[name] = query\n                except Exception as ex:\n                    msg = f\"Failed to load query '{name}' ({self.lang})\"\n                    ExceptionHandler.handle(msg, ex, debug=self.debug)\n\n    def getQueries(self, queriesPath=None, with_default: bool = True):\n        \"\"\"\n        get the queries for the given queries Path\n\n        Args:\n            queriesPath(str): the path of the yaml file to load queries from\n            with_default(bool): if True also load the default yaml file\n\n        \"\"\"\n        queriesPaths = YamlPath.getPaths(\n            \"queries.yaml\", queriesPath, with_default=with_default\n        )\n        queries = {}\n        for queriesPath in queriesPaths:\n            if os.path.isfile(queriesPath):\n                with open(queriesPath, \"r\") as stream:\n                    lqueries = yaml.safe_load(stream)\n                    for key in lqueries:\n                        queries[key] = lqueries[key]\n        return queries\n</code></pre>"},{"location":"#lodstorage.query.QueryManager.__init__","title":"<code>__init__(lang=None, debug=False, queriesPath=None, with_default=True)</code>","text":"<p>Constructor Args:     lang(str): the language to use for the queries sql or sparql     queriesPath(str): the path of the yaml file to load queries from     debug(bool): True if debug information should be shown     with_default(bool): if True also load the default yaml file</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self, lang: str = None, debug=False, queriesPath=None, with_default: bool = True\n):\n    \"\"\"\n    Constructor\n    Args:\n        lang(str): the language to use for the queries sql or sparql\n        queriesPath(str): the path of the yaml file to load queries from\n        debug(bool): True if debug information should be shown\n        with_default(bool): if True also load the default yaml file\n    \"\"\"\n    if lang is None:\n        lang = \"sql\"\n    self.queriesByName = {}\n    self.lang = lang\n    self.debug = debug\n    queries = self.getQueries(queriesPath=queriesPath, with_default=with_default)\n    for name, queryDict in queries.items():\n        if self.lang in queryDict:\n            queryDict[\"name\"] = name\n            queryDict[\"lang\"] = self.lang\n            if not \"query\" in queryDict:\n                queryDict[\"query\"] = queryDict[self.lang]\n            try:\n                query = Query.from_dict(queryDict)\n                query.debug = self.debug\n                self.queriesByName[name] = query\n            except Exception as ex:\n                msg = f\"Failed to load query '{name}' ({self.lang})\"\n                ExceptionHandler.handle(msg, ex, debug=self.debug)\n</code></pre>"},{"location":"#lodstorage.query.QueryManager.getQueries","title":"<code>getQueries(queriesPath=None, with_default=True)</code>","text":"<p>get the queries for the given queries Path</p> <p>Parameters:</p> Name Type Description Default <code>queriesPath(str)</code> <p>the path of the yaml file to load queries from</p> required <code>with_default(bool)</code> <p>if True also load the default yaml file</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def getQueries(self, queriesPath=None, with_default: bool = True):\n    \"\"\"\n    get the queries for the given queries Path\n\n    Args:\n        queriesPath(str): the path of the yaml file to load queries from\n        with_default(bool): if True also load the default yaml file\n\n    \"\"\"\n    queriesPaths = YamlPath.getPaths(\n        \"queries.yaml\", queriesPath, with_default=with_default\n    )\n    queries = {}\n    for queriesPath in queriesPaths:\n        if os.path.isfile(queriesPath):\n            with open(queriesPath, \"r\") as stream:\n                lqueries = yaml.safe_load(stream)\n                for key in lqueries:\n                    queries[key] = lqueries[key]\n    return queries\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation","title":"<code>QueryResultDocumentation</code>","text":"<p>documentation of a query result</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QueryResultDocumentation:\n    \"\"\"\n    documentation of a query result\n    \"\"\"\n\n    def __init__(\n        self,\n        query,\n        title: str,\n        tablefmt: str,\n        tryItMarkup: str,\n        sourceCodeHeader: str,\n        sourceCode: str,\n        resultHeader: str,\n        result: str,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            query(Query): the query to be documented\n            title(str): the title markup\n            tablefmt(str): the tableformat that has been used\n            tryItMarkup: the \"try it!\" markup to show\n            sourceCodeHeader(str): the header title to use for the sourceCode\n            sourceCode(str): the sourceCode\n            resultCodeHeader(str): the header title to use for the result\n            result(str): the result header\n\n        \"\"\"\n        self.query = query\n        self.title = title\n        self.tablefmt = tablefmt\n        self.tryItMarkup = f\"\\n{tryItMarkup}\"\n        self.sourceCodeHeader = sourceCodeHeader\n        self.sourceCode = sourceCode\n        self.resultHeader = resultHeader\n        self.result = result\n\n    @staticmethod\n    def uniCode2Latex(text: str, withConvert: bool = False) -&gt; str:\n        \"\"\"\n        converts unicode text to latex and\n        fixes UTF-8 chars for latex in a certain range:\n            \u2080:$_0$ ... \u2089:$_9$\n\n        see https://github.com/phfaist/pylatexenc/issues/72\n\n        Args:\n            text(str): the string to fix\n            withConvert(bool): if unicode to latex libary conversion should be used\n\n        Return:\n            str: latex presentation of UTF-8 char\n        \"\"\"\n        for code in range(8320, 8330):\n            text = text.replace(chr(code), f\"$_{code-8320}$\")\n        if withConvert:\n            # workaround - hidden dependency!\n            from pylatexenc.latexencode import unicode_to_latex\n\n            latex = unicode_to_latex(text)\n            # workaround {\\textbackslash} being returned\n            # latex=latex.replace(\"{\\\\textbackslash}\",'\\\\')\n            text = latex\n        return text\n\n    def __str__(self):\n        \"\"\"\n        simple string representation\n        \"\"\"\n        return self.asText()\n\n    def asText(self):\n        \"\"\"\n        return my text representation\n\n        Returns:\n            str: description, sourceCodeHeader, sourceCode, tryIt link and result table\n        \"\"\"\n        text = f\"{self.title}\\n{self.query.description}\\n{self.sourceCodeHeader}\\n{self.sourceCode}{self.tryItMarkup}\\n{self.resultHeader}\\n{self.result}\"\n        fixedStr = (\n            self.uniCode2Latex(text) if self.tablefmt.lower() == \"latex\" else text\n        )\n        return fixedStr\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.__init__","title":"<code>__init__(query, title, tablefmt, tryItMarkup, sourceCodeHeader, sourceCode, resultHeader, result)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>query(Query)</code> <p>the query to be documented</p> required <code>title(str)</code> <p>the title markup</p> required <code>tablefmt(str)</code> <p>the tableformat that has been used</p> required <code>tryItMarkup</code> <code>str</code> <p>the \"try it!\" markup to show</p> required <code>sourceCodeHeader(str)</code> <p>the header title to use for the sourceCode</p> required <code>sourceCode(str)</code> <p>the sourceCode</p> required <code>resultCodeHeader(str)</code> <p>the header title to use for the result</p> required <code>result(str)</code> <p>the result header</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self,\n    query,\n    title: str,\n    tablefmt: str,\n    tryItMarkup: str,\n    sourceCodeHeader: str,\n    sourceCode: str,\n    resultHeader: str,\n    result: str,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        query(Query): the query to be documented\n        title(str): the title markup\n        tablefmt(str): the tableformat that has been used\n        tryItMarkup: the \"try it!\" markup to show\n        sourceCodeHeader(str): the header title to use for the sourceCode\n        sourceCode(str): the sourceCode\n        resultCodeHeader(str): the header title to use for the result\n        result(str): the result header\n\n    \"\"\"\n    self.query = query\n    self.title = title\n    self.tablefmt = tablefmt\n    self.tryItMarkup = f\"\\n{tryItMarkup}\"\n    self.sourceCodeHeader = sourceCodeHeader\n    self.sourceCode = sourceCode\n    self.resultHeader = resultHeader\n    self.result = result\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.__str__","title":"<code>__str__()</code>","text":"<p>simple string representation</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    simple string representation\n    \"\"\"\n    return self.asText()\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.asText","title":"<code>asText()</code>","text":"<p>return my text representation</p> <p>Returns:</p> Name Type Description <code>str</code> <p>description, sourceCodeHeader, sourceCode, tryIt link and result table</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asText(self):\n    \"\"\"\n    return my text representation\n\n    Returns:\n        str: description, sourceCodeHeader, sourceCode, tryIt link and result table\n    \"\"\"\n    text = f\"{self.title}\\n{self.query.description}\\n{self.sourceCodeHeader}\\n{self.sourceCode}{self.tryItMarkup}\\n{self.resultHeader}\\n{self.result}\"\n    fixedStr = (\n        self.uniCode2Latex(text) if self.tablefmt.lower() == \"latex\" else text\n    )\n    return fixedStr\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.uniCode2Latex","title":"<code>uniCode2Latex(text, withConvert=False)</code>  <code>staticmethod</code>","text":"<p>converts unicode text to latex and fixes UTF-8 chars for latex in a certain range:     \u2080:$_0$ ... \u2089:$_9$</p> <p>see https://github.com/phfaist/pylatexenc/issues/72</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the string to fix</p> required <code>withConvert(bool)</code> <p>if unicode to latex libary conversion should be used</p> required Return <p>str: latex presentation of UTF-8 char</p> Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef uniCode2Latex(text: str, withConvert: bool = False) -&gt; str:\n    \"\"\"\n    converts unicode text to latex and\n    fixes UTF-8 chars for latex in a certain range:\n        \u2080:$_0$ ... \u2089:$_9$\n\n    see https://github.com/phfaist/pylatexenc/issues/72\n\n    Args:\n        text(str): the string to fix\n        withConvert(bool): if unicode to latex libary conversion should be used\n\n    Return:\n        str: latex presentation of UTF-8 char\n    \"\"\"\n    for code in range(8320, 8330):\n        text = text.replace(chr(code), f\"$_{code-8320}$\")\n    if withConvert:\n        # workaround - hidden dependency!\n        from pylatexenc.latexencode import unicode_to_latex\n\n        latex = unicode_to_latex(text)\n        # workaround {\\textbackslash} being returned\n        # latex=latex.replace(\"{\\\\textbackslash}\",'\\\\')\n        text = latex\n    return text\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight","title":"<code>QuerySyntaxHighlight</code>","text":"<p>Syntax highlighting for queries with pygments</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QuerySyntaxHighlight:\n    \"\"\"\n    Syntax highlighting for queries with pygments\n    \"\"\"\n\n    def __init__(self, query, highlightFormat: str = \"html\"):\n        \"\"\"\n        construct me for the given query and highlightFormat\n\n        Args:\n            query(Query): the query to do the syntax highlighting for\n            highlightFormat(str): the highlight format to be used\n        \"\"\"\n        self.query = query\n        self.highlightFormat = highlightFormat\n        self.lexer = get_lexer_by_name(self.query.lang)\n        if self.highlightFormat == \"html\":\n            self.formatter = HtmlFormatter()\n        elif self.highlightFormat == \"latex\":\n            self.formatter = LatexFormatter()\n\n    def highlight(self):\n        \"\"\"\n        Returns:\n            str: the result of the syntax highlighting with pygments\n        \"\"\"\n        syntaxResult = highlight(self.query.query, self.lexer, self.formatter)\n        return syntaxResult\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight.__init__","title":"<code>__init__(query, highlightFormat='html')</code>","text":"<p>construct me for the given query and highlightFormat</p> <p>Parameters:</p> Name Type Description Default <code>query(Query)</code> <p>the query to do the syntax highlighting for</p> required <code>highlightFormat(str)</code> <p>the highlight format to be used</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(self, query, highlightFormat: str = \"html\"):\n    \"\"\"\n    construct me for the given query and highlightFormat\n\n    Args:\n        query(Query): the query to do the syntax highlighting for\n        highlightFormat(str): the highlight format to be used\n    \"\"\"\n    self.query = query\n    self.highlightFormat = highlightFormat\n    self.lexer = get_lexer_by_name(self.query.lang)\n    if self.highlightFormat == \"html\":\n        self.formatter = HtmlFormatter()\n    elif self.highlightFormat == \"latex\":\n        self.formatter = LatexFormatter()\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight.highlight","title":"<code>highlight()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>the result of the syntax highlighting with pygments</p> Source code in <code>lodstorage/query.py</code> <pre><code>def highlight(self):\n    \"\"\"\n    Returns:\n        str: the result of the syntax highlighting with pygments\n    \"\"\"\n    syntaxResult = highlight(self.query.query, self.lexer, self.formatter)\n    return syntaxResult\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter","title":"<code>ValueFormatter</code>","text":"<p>a value Formatter</p> Source code in <code>lodstorage/query.py</code> <pre><code>@lod_storable\nclass ValueFormatter:\n    \"\"\"\n    a value Formatter\n    \"\"\"\n\n    format: str\n    regexps: List[str] = field(default_factory=list)\n\n    def apply_format(self, record, key, resultFormat: Format):\n        \"\"\"\n        apply the given format to the given record\n\n        Args:\n            record(dict): the record to handle\n            key(str): the property key\n            resultFormat(str): the resultFormat Style to apply\n        \"\"\"\n        if key in record:\n            value = record[key]\n            if value is not None and isinstance(value, str):\n                # if there are no regular expressions specified always format\n                doformat = len(self.regexps) == 0\n                for regexp in self.regexps:\n                    try:\n                        vmatch = re.match(regexp, value)\n                        if vmatch:\n                            # we found a match and will format it if the value is not none\n                            doformat = True\n                            value = vmatch.group(\"value\")\n                    except Exception as ex:\n                        print(\n                            f\"ValueFormatter: {self.name}\\nInvalid regular expression:{regexp}\\n{str(ex)}\",\n                            file=sys.stderr,\n                        )\n                if value is not None and doformat:\n                    link = self.format.format(value=value)\n                    newValue = None\n                    if resultFormat == \"github\":\n                        newValue = f\"[{value}]({link})\"\n                    elif resultFormat == \"mediawiki\":\n                        newValue = f\"[{link} {value}]\"\n                    elif resultFormat == \"latex\":\n                        newValue = rf\"\\href{{{link}}}{{{value}}}\"\n                    if newValue is not None:\n                        record[key] = newValue\n\n    def applyFormat(self, record, key, resultFormat: Format):\n        \"\"\"\n        legacy delegate\n        \"\"\"\n        self.apply_format(record, key, resultFormat)\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.applyFormat","title":"<code>applyFormat(record, key, resultFormat)</code>","text":"<p>legacy delegate</p> Source code in <code>lodstorage/query.py</code> <pre><code>def applyFormat(self, record, key, resultFormat: Format):\n    \"\"\"\n    legacy delegate\n    \"\"\"\n    self.apply_format(record, key, resultFormat)\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.apply_format","title":"<code>apply_format(record, key, resultFormat)</code>","text":"<p>apply the given format to the given record</p> <p>Parameters:</p> Name Type Description Default <code>record(dict)</code> <p>the record to handle</p> required <code>key(str)</code> <p>the property key</p> required <code>resultFormat(str)</code> <p>the resultFormat Style to apply</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def apply_format(self, record, key, resultFormat: Format):\n    \"\"\"\n    apply the given format to the given record\n\n    Args:\n        record(dict): the record to handle\n        key(str): the property key\n        resultFormat(str): the resultFormat Style to apply\n    \"\"\"\n    if key in record:\n        value = record[key]\n        if value is not None and isinstance(value, str):\n            # if there are no regular expressions specified always format\n            doformat = len(self.regexps) == 0\n            for regexp in self.regexps:\n                try:\n                    vmatch = re.match(regexp, value)\n                    if vmatch:\n                        # we found a match and will format it if the value is not none\n                        doformat = True\n                        value = vmatch.group(\"value\")\n                except Exception as ex:\n                    print(\n                        f\"ValueFormatter: {self.name}\\nInvalid regular expression:{regexp}\\n{str(ex)}\",\n                        file=sys.stderr,\n                    )\n            if value is not None and doformat:\n                link = self.format.format(value=value)\n                newValue = None\n                if resultFormat == \"github\":\n                    newValue = f\"[{value}]({link})\"\n                elif resultFormat == \"mediawiki\":\n                    newValue = f\"[{link} {value}]\"\n                elif resultFormat == \"latex\":\n                    newValue = rf\"\\href{{{link}}}{{{value}}}\"\n                if newValue is not None:\n                    record[key] = newValue\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatters","title":"<code>ValueFormatters</code>","text":"<p>manages a set of ValueFormatters</p> Source code in <code>lodstorage/query.py</code> <pre><code>@lod_storable\nclass ValueFormatters:\n    \"\"\"\n    manages a set of ValueFormatters\n    \"\"\"\n\n    formatters: Dict[str, ValueFormatter] = field(default_factory=dict)\n\n    _instance: Optional[\"ValueFormatters\"] = None\n    _formats_path: Optional[str] = None\n\n    @classmethod\n    def get_instance(cls) -&gt; \"ValueFormatters\":\n        \"\"\"Get the singleton instance.\"\"\"\n        if cls._instance is None:\n            cls._instance = cls.of_yaml()\n        return cls._instance\n\n    @classmethod\n    def preload(cls, formats_path: str) -&gt; \"ValueFormatters\":\n        \"\"\"Preload singleton with specific formats path.\"\"\"\n        cls._instance = cls.of_yaml(formats_path)\n        return cls._instance\n\n    @classmethod\n    def of_yaml(cls, yaml_path: str = None) -&gt; \"ValueFormatters\":\n        \"\"\"Load ValueFormatters from YAML file.\"\"\"\n        vf = None\n        if yaml_path is None:\n            paths = YamlPath.getPaths(\"formats.yaml\")\n            if len(paths) &gt; 0:\n                yaml_path = paths[0]\n        if yaml_path:\n            vf = cls.load_from_yaml_file(yaml_path)\n            cls._formats_path = yaml_path\n        return vf\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatters.get_instance","title":"<code>get_instance()</code>  <code>classmethod</code>","text":"<p>Get the singleton instance.</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef get_instance(cls) -&gt; \"ValueFormatters\":\n    \"\"\"Get the singleton instance.\"\"\"\n    if cls._instance is None:\n        cls._instance = cls.of_yaml()\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatters.of_yaml","title":"<code>of_yaml(yaml_path=None)</code>  <code>classmethod</code>","text":"<p>Load ValueFormatters from YAML file.</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef of_yaml(cls, yaml_path: str = None) -&gt; \"ValueFormatters\":\n    \"\"\"Load ValueFormatters from YAML file.\"\"\"\n    vf = None\n    if yaml_path is None:\n        paths = YamlPath.getPaths(\"formats.yaml\")\n        if len(paths) &gt; 0:\n            yaml_path = paths[0]\n    if yaml_path:\n        vf = cls.load_from_yaml_file(yaml_path)\n        cls._formats_path = yaml_path\n    return vf\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatters.preload","title":"<code>preload(formats_path)</code>  <code>classmethod</code>","text":"<p>Preload singleton with specific formats path.</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef preload(cls, formats_path: str) -&gt; \"ValueFormatters\":\n    \"\"\"Preload singleton with specific formats path.\"\"\"\n    cls._instance = cls.of_yaml(formats_path)\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.query_cmd","title":"<code>query_cmd</code>","text":"<p>Created on 2024-08-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.query_cmd.QueryCmd","title":"<code>QueryCmd</code>","text":"<p>command line support queries</p> Source code in <code>lodstorage/query_cmd.py</code> <pre><code>class QueryCmd:\n    \"\"\"\n    command line support queries\n    \"\"\"\n\n    def __init__(self, args: Namespace, with_default_queries: bool = True):\n        \"\"\"\n        command line args\n\n        Args:\n            args (Namespace): the command line arguments\n            with_default_queries (bool): should default queries be made available/listed?\n        \"\"\"\n        self.args = args\n        self.debug = args.debug\n        self.with_default_queries = with_default_queries\n\n    def init_managers(self):\n        self.endpoints = EndpointManager.getEndpoints(self.args.endpointPath)\n        self.qm = QueryManager(\n            lang=self.args.language,\n            debug=self.debug,\n            queriesPath=self.args.queriesPath,\n            with_default=self.with_default_queries,\n        )\n\n    def handle_args(self) -&gt; bool:\n        \"\"\"\n        handle the command line arguments\n        \"\"\"\n        handled = False\n        debug = self.debug\n        args = self.args\n        self.init_managers()\n        self.query = None\n        self.queryCode = args.query\n        self.formats = None\n        # preload ValueFormatters\n        ValueFormatters.preload(args.formatsPath)\n        if args.list:\n            for name, query in self.qm.queriesByName.items():\n                print(f\"{name}:{query.title}\")\n            handled = True\n        elif args.listEndpoints:\n            # list endpoints\n            for endpoint in self.endpoints.values():\n                if hasattr(endpoint, \"lang\") and endpoint.lang == args.language:\n                    print(endpoint)\n            handled = True\n        elif args.queryName is not None:\n            if debug or args.showQuery:\n                print(f\"named query {args.queryName}:\")\n            if args.queryName not in self.qm.queriesByName:\n                raise Exception(f\"named query {args.queryName} not available\")\n            self.query = self.qm.queriesByName[args.queryName]\n            if self.query.limit is None and args.limit is not None:\n                self.query.limit = args.limit\n            self.formats = self.query.formats\n            self.queryCode = self.query.query\n            if debug or args.showQuery:\n                if (\n                    hasattr(self.query, \"description\")\n                    and self.query.description is not None\n                ):\n                    print(self.query.description)\n        if self.query is None:\n            name = \"?\"\n            if self.queryCode is None and args.queryFile is not None:\n                queryFilePath = Path(args.queryFile)\n                self.queryCode = queryFilePath.read_text()\n                name = queryFilePath.stem\n            self.query = Query(name=\"?\", query=self.queryCode, lang=args.language)\n\n        if self.queryCode:\n            params = Params(self.query.query)\n            self.query.query = params.apply_parameters_with_check(args.params)\n            self.queryCode = self.query.query\n            if debug or args.showQuery:\n                print(f\"{args.language}:\\n{self.query.query}\")\n        return handled\n\n    def format_output(self, qlod: List[Dict[str, Any]]):\n        \"\"\"\n        Format and print the query results.\n\n        This method formats the query results based on the specified output format\n        (e.g., CSV, JSON, XML) and prints them to the console.\n\n        Args:\n            qlod (List[Dict[str, Any]]): A list of dictionaries containing the query results.\n                Each dictionary represents a row of the query result, with column names as keys\n                and the corresponding values.\n        \"\"\"\n        args = self.args\n        if args.format is Format.csv:\n            csv_converter = CSV.get_instance()\n            csv = csv_converter.toCSV(qlod)\n            print(csv)\n        elif args.format in [Format.latex, Format.github, Format.mediawiki]:\n            doc = self.query.documentQueryResult(\n                qlod, tablefmt=str(args.format), floatfmt=\".0f\"\n            )\n            docstr = doc.asText()\n            print(docstr)\n        elif args.format in [Format.json] or args.format is None:  # set as default\n            # https://stackoverflow.com/a/36142844/1497139\n            print(json.dumps(qlod, indent=2, sort_keys=True, default=str))\n        elif args.format in [Format.xml]:\n            lod2xml = Lod2Xml(qlod)\n            xml = lod2xml.asXml()\n            print(xml)\n\n        else:\n            raise Exception(f\"format {args.format} not supported yet\")\n\n    @classmethod\n    def argument_exists(cls, parser, arg_name):\n        return any(arg_name in action.option_strings for action in parser._actions)\n\n    @classmethod\n    def add_args(cls, parser: ArgumentParser):\n        if not cls.argument_exists(parser, \"--debug\"):\n            parser.add_argument(\n                \"-d\",\n                \"--debug\",\n                dest=\"debug\",\n                action=\"store_true\",\n                help=\"set debug [default: %(default)s]\",\n            )\n        parser.add_argument(\n            \"-ep\",\n            \"--endpointPath\",\n            default=None,\n            help=\"path to yaml file to configure endpoints to use for queries\",\n        )\n        ValueFormatters.get_instance()\n        parser.add_argument(\n            \"-fp\",\n            \"--formatsPath\",\n            default=ValueFormatters._formats_path,\n            help=\"path to yaml file to configure formats to use for query result documentation\",\n        )\n        parser.add_argument(\n            \"-li\",\n            \"--list\",\n            action=\"store_true\",\n            help=\"show the list of available queries\",\n        )\n        parser.add_argument(\n            \"--limit\", type=int, default=None, help=\"set limit parameter of query\"\n        )\n        parser.add_argument(\n            \"--params\",\n            action=StoreDictKeyPair,\n            help=\"query parameters as Key-value pairs in the format key1=value1,key2=value2\",\n        )\n        parser.add_argument(\n            \"-le\",\n            \"--listEndpoints\",\n            action=\"store_true\",\n            help=\"show the list of available endpoints\",\n        )\n        parser.add_argument(\n            \"-sq\", \"--showQuery\", action=\"store_true\", help=\"show the query\"\n        )\n        parser.add_argument(\n            \"-qp\", \"--queriesPath\", help=\"path to YAML file with query definitions\"\n        )\n        parser.add_argument(\"-q\", \"--query\", help=\"the query to run\")\n        parser.add_argument(\"-qf\", \"--queryFile\", help=\"the query file to run\")\n        parser.add_argument(\"-qn\", \"--queryName\", help=\"run a named query\")\n</code></pre>"},{"location":"#lodstorage.query_cmd.QueryCmd.__init__","title":"<code>__init__(args, with_default_queries=True)</code>","text":"<p>command line args</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>the command line arguments</p> required <code>with_default_queries</code> <code>bool</code> <p>should default queries be made available/listed?</p> <code>True</code> Source code in <code>lodstorage/query_cmd.py</code> <pre><code>def __init__(self, args: Namespace, with_default_queries: bool = True):\n    \"\"\"\n    command line args\n\n    Args:\n        args (Namespace): the command line arguments\n        with_default_queries (bool): should default queries be made available/listed?\n    \"\"\"\n    self.args = args\n    self.debug = args.debug\n    self.with_default_queries = with_default_queries\n</code></pre>"},{"location":"#lodstorage.query_cmd.QueryCmd.format_output","title":"<code>format_output(qlod)</code>","text":"<p>Format and print the query results.</p> <p>This method formats the query results based on the specified output format (e.g., CSV, JSON, XML) and prints them to the console.</p> <p>Parameters:</p> Name Type Description Default <code>qlod</code> <code>List[Dict[str, Any]]</code> <p>A list of dictionaries containing the query results. Each dictionary represents a row of the query result, with column names as keys and the corresponding values.</p> required Source code in <code>lodstorage/query_cmd.py</code> <pre><code>def format_output(self, qlod: List[Dict[str, Any]]):\n    \"\"\"\n    Format and print the query results.\n\n    This method formats the query results based on the specified output format\n    (e.g., CSV, JSON, XML) and prints them to the console.\n\n    Args:\n        qlod (List[Dict[str, Any]]): A list of dictionaries containing the query results.\n            Each dictionary represents a row of the query result, with column names as keys\n            and the corresponding values.\n    \"\"\"\n    args = self.args\n    if args.format is Format.csv:\n        csv_converter = CSV.get_instance()\n        csv = csv_converter.toCSV(qlod)\n        print(csv)\n    elif args.format in [Format.latex, Format.github, Format.mediawiki]:\n        doc = self.query.documentQueryResult(\n            qlod, tablefmt=str(args.format), floatfmt=\".0f\"\n        )\n        docstr = doc.asText()\n        print(docstr)\n    elif args.format in [Format.json] or args.format is None:  # set as default\n        # https://stackoverflow.com/a/36142844/1497139\n        print(json.dumps(qlod, indent=2, sort_keys=True, default=str))\n    elif args.format in [Format.xml]:\n        lod2xml = Lod2Xml(qlod)\n        xml = lod2xml.asXml()\n        print(xml)\n\n    else:\n        raise Exception(f\"format {args.format} not supported yet\")\n</code></pre>"},{"location":"#lodstorage.query_cmd.QueryCmd.handle_args","title":"<code>handle_args()</code>","text":"<p>handle the command line arguments</p> Source code in <code>lodstorage/query_cmd.py</code> <pre><code>def handle_args(self) -&gt; bool:\n    \"\"\"\n    handle the command line arguments\n    \"\"\"\n    handled = False\n    debug = self.debug\n    args = self.args\n    self.init_managers()\n    self.query = None\n    self.queryCode = args.query\n    self.formats = None\n    # preload ValueFormatters\n    ValueFormatters.preload(args.formatsPath)\n    if args.list:\n        for name, query in self.qm.queriesByName.items():\n            print(f\"{name}:{query.title}\")\n        handled = True\n    elif args.listEndpoints:\n        # list endpoints\n        for endpoint in self.endpoints.values():\n            if hasattr(endpoint, \"lang\") and endpoint.lang == args.language:\n                print(endpoint)\n        handled = True\n    elif args.queryName is not None:\n        if debug or args.showQuery:\n            print(f\"named query {args.queryName}:\")\n        if args.queryName not in self.qm.queriesByName:\n            raise Exception(f\"named query {args.queryName} not available\")\n        self.query = self.qm.queriesByName[args.queryName]\n        if self.query.limit is None and args.limit is not None:\n            self.query.limit = args.limit\n        self.formats = self.query.formats\n        self.queryCode = self.query.query\n        if debug or args.showQuery:\n            if (\n                hasattr(self.query, \"description\")\n                and self.query.description is not None\n            ):\n                print(self.query.description)\n    if self.query is None:\n        name = \"?\"\n        if self.queryCode is None and args.queryFile is not None:\n            queryFilePath = Path(args.queryFile)\n            self.queryCode = queryFilePath.read_text()\n            name = queryFilePath.stem\n        self.query = Query(name=\"?\", query=self.queryCode, lang=args.language)\n\n    if self.queryCode:\n        params = Params(self.query.query)\n        self.query.query = params.apply_parameters_with_check(args.params)\n        self.queryCode = self.query.query\n        if debug or args.showQuery:\n            print(f\"{args.language}:\\n{self.query.query}\")\n    return handled\n</code></pre>"},{"location":"#lodstorage.querymain","title":"<code>querymain</code>","text":"<p>Created on 2022-02-13</p> <p>@author: wf</p>"},{"location":"#lodstorage.querymain.QueryMain","title":"<code>QueryMain</code>","text":"<p>               Bases: <code>QueryCmd</code></p> <p>Commandline handler</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>class QueryMain(QueryCmd):\n    \"\"\"\n    Commandline handler\n    \"\"\"\n\n    def __init__(self, args):\n        \"\"\"\n        command line args\n\n        Args:\n            args(list): the command line arguments\n        \"\"\"\n        super().__init__(args=args)\n        self.rate_limiter = RateLimiter(\n            calls_per_minute=(\n                args.calls_per_minute if hasattr(args, \"calls_per_minute\") else None\n            )\n        )\n\n    def handle_args(self) -&gt; bool:\n        args = self.args\n        handled = super().handle_args()\n\n        if self.queryCode:\n            endpointConf = Endpoint()\n            endpointConf.method = \"POST\"\n            if args.endpointName:\n                endpointConf = self.endpoints.get(args.endpointName)\n            else:\n                endpointConf.endpoint = self.query.endpoint\n            if args.method:\n                endpointConf.method = args.method\n            if endpointConf:\n                self.query.tryItUrl = endpointConf.website\n                self.query.database = endpointConf.database\n            if self.query.limit:\n                if \"limit\" in self.queryCode or \"LIMIT\" in self.queryCode:\n                    self.queryCode = re.sub(\n                        r\"(limit|LIMIT)\\s+(\\d+)\",\n                        f\"LIMIT {self.query.limit}\",\n                        self.queryCode,\n                    )\n                else:\n                    self.queryCode += f\"\\nLIMIT {self.query.limit}\"\n            if args.language == \"sparql\":\n                sparql = SPARQL.fromEndpointConf(endpointConf)\n                if args.prefixes and endpointConf is not None:\n                    self.query.add_endpoint_prefixes(\n                        endpointConf, PrefixConfigs.get_instance()\n                    )\n                if args.raw:\n                    qres = self.rawQuery(\n                        endpointConf,\n                        query=self.query.query,\n                        resultFormat=args.format,\n                        mimeType=args.mimeType,\n                    )\n                    print(qres)\n                    return\n                if \"wikidata\" in args.endpointName and self.formats is None:\n                    self.formats = [\"*:wikidata\"]\n                qlod = sparql.queryAsListOfDicts(self.queryCode)\n            elif args.language == \"sql\":\n                if endpointConf.endpoint.startswith(\"jdbc:mysql\"):\n                    query_tool = MySqlQuery(endpointConf, debug=args.debug)\n                    qlod = query_tool.execute_sql_query(self.queryCode)\n                else:\n                    # Use existing SQLDB for other SQL endpoints\n                    sqlDB = SQLDB(endpointConf.endpoint)\n                    qlod = sqlDB.query(self.queryCode)\n            else:\n                raise Exception(f\"language {args.language} not known/supported\")\n            self.format_output(qlod)\n            handled = True\n        return handled\n\n    def rawQuery(\n        self,\n        endpointConf,\n        query: str,\n        resultFormat: str,\n        mimeType: str,\n        content_type: str = \"application/sparql-query\",\n        timeout: float = 10.0,\n        lenient: bool = True,\n    ):\n        \"\"\"\n        Returns raw result of the endpoint.\n\n        Args:\n            endpointConf: EndPoint\n            query (str): query\n            resultFormat (str): format of the result\n            mimeType (str): mimeType\n            content_type (str): content type of the request\n            timeout (float): timeout in seconds\n            lenient (bool): if True do not raise errors but just log\n\n        Returns:\n            raw result of the query\n        \"\"\"\n\n        headers = {\"User-Agent\": f\"{Version.name}/{Version.version}\"}\n\n        if mimeType:\n            headers[\"Accept\"] = mimeType\n\n        endpoint = endpointConf.endpoint\n        method = endpointConf.method.upper()\n\n        if method == \"POST\":\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n            data = urllib.parse.urlencode({\"query\": query, \"format\": resultFormat})\n            params = None\n        else:\n            headers[\"Content-Type\"] = content_type\n            params = {\"query\": query, \"format\": resultFormat}\n            data = None\n\n        try:\n            response = requests.request(\n                method,\n                endpoint,\n                headers=headers,\n                data=data,\n                params=params,\n                timeout=timeout,\n            )\n\n            # Check for HTTP errors\n            response.raise_for_status()\n\n            # Handle different response content types\n            if \"application/json\" in response.headers.get(\"Content-Type\", \"\"):\n                return response.json()  # Return JSON if applicable\n            else:\n                return response.text  # Fallback to plain text\n\n        except requests.exceptions.RequestException as e:\n            # Log or handle the error as needed\n            err_msg = f\"An error occurred while querying the endpoint: {e}\"\n            # Attempt to retrieve response content if available\n            if hasattr(e, \"response\") and e.response is not None:\n                error_content = e.response.content.decode(\"utf-8\", errors=\"replace\")\n                err_msg += f\"\\nResponse content: {error_content}\"\n\n            if lenient:\n                logging.error(err_msg)\n                return None\n            else:\n                raise RuntimeError(err_msg)\n</code></pre>"},{"location":"#lodstorage.querymain.QueryMain.__init__","title":"<code>__init__(args)</code>","text":"<p>command line args</p> <p>Parameters:</p> Name Type Description Default <code>args(list)</code> <p>the command line arguments</p> required Source code in <code>lodstorage/querymain.py</code> <pre><code>def __init__(self, args):\n    \"\"\"\n    command line args\n\n    Args:\n        args(list): the command line arguments\n    \"\"\"\n    super().__init__(args=args)\n    self.rate_limiter = RateLimiter(\n        calls_per_minute=(\n            args.calls_per_minute if hasattr(args, \"calls_per_minute\") else None\n        )\n    )\n</code></pre>"},{"location":"#lodstorage.querymain.QueryMain.rawQuery","title":"<code>rawQuery(endpointConf, query, resultFormat, mimeType, content_type='application/sparql-query', timeout=10.0, lenient=True)</code>","text":"<p>Returns raw result of the endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpointConf</code> <p>EndPoint</p> required <code>query</code> <code>str</code> <p>query</p> required <code>resultFormat</code> <code>str</code> <p>format of the result</p> required <code>mimeType</code> <code>str</code> <p>mimeType</p> required <code>content_type</code> <code>str</code> <p>content type of the request</p> <code>'application/sparql-query'</code> <code>timeout</code> <code>float</code> <p>timeout in seconds</p> <code>10.0</code> <code>lenient</code> <code>bool</code> <p>if True do not raise errors but just log</p> <code>True</code> <p>Returns:</p> Type Description <p>raw result of the query</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def rawQuery(\n    self,\n    endpointConf,\n    query: str,\n    resultFormat: str,\n    mimeType: str,\n    content_type: str = \"application/sparql-query\",\n    timeout: float = 10.0,\n    lenient: bool = True,\n):\n    \"\"\"\n    Returns raw result of the endpoint.\n\n    Args:\n        endpointConf: EndPoint\n        query (str): query\n        resultFormat (str): format of the result\n        mimeType (str): mimeType\n        content_type (str): content type of the request\n        timeout (float): timeout in seconds\n        lenient (bool): if True do not raise errors but just log\n\n    Returns:\n        raw result of the query\n    \"\"\"\n\n    headers = {\"User-Agent\": f\"{Version.name}/{Version.version}\"}\n\n    if mimeType:\n        headers[\"Accept\"] = mimeType\n\n    endpoint = endpointConf.endpoint\n    method = endpointConf.method.upper()\n\n    if method == \"POST\":\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        data = urllib.parse.urlencode({\"query\": query, \"format\": resultFormat})\n        params = None\n    else:\n        headers[\"Content-Type\"] = content_type\n        params = {\"query\": query, \"format\": resultFormat}\n        data = None\n\n    try:\n        response = requests.request(\n            method,\n            endpoint,\n            headers=headers,\n            data=data,\n            params=params,\n            timeout=timeout,\n        )\n\n        # Check for HTTP errors\n        response.raise_for_status()\n\n        # Handle different response content types\n        if \"application/json\" in response.headers.get(\"Content-Type\", \"\"):\n            return response.json()  # Return JSON if applicable\n        else:\n            return response.text  # Fallback to plain text\n\n    except requests.exceptions.RequestException as e:\n        # Log or handle the error as needed\n        err_msg = f\"An error occurred while querying the endpoint: {e}\"\n        # Attempt to retrieve response content if available\n        if hasattr(e, \"response\") and e.response is not None:\n            error_content = e.response.content.decode(\"utf-8\", errors=\"replace\")\n            err_msg += f\"\\nResponse content: {error_content}\"\n\n        if lenient:\n            logging.error(err_msg)\n            return None\n        else:\n            raise RuntimeError(err_msg)\n</code></pre>"},{"location":"#lodstorage.querymain.main","title":"<code>main(argv=None, lang=None)</code>","text":"<p>main program.</p> <p>commandline access to List of Dicts / Linked Open Data Queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def main(argv=None, lang=None):  # IGNORE:C0111\n    \"\"\"\n    main program.\n\n    commandline access to List of Dicts / Linked Open Data Queries\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = os.path.basename(__file__)\n    program_version = \"v%s\" % __version__\n    program_build_date = str(__updated__)\n    program_version_message = \"%%(prog)s %s (%s)\" % (\n        program_version,\n        program_build_date,\n    )\n    program_shortdesc = (\n        \"commandline query of endpoints in diverse languages such as SPARQL/SQL\"\n    )\n    user_name = \"Wolfgang Fahl\"\n    program_license = \"\"\"%s\n\n  Created by %s on %s.\n  Copyright 2020-2025 Wolfgang Fahl. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\n\nUSAGE\n\"\"\" % (\n        program_shortdesc,\n        user_name,\n        str(__date__),\n    )\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(\n            description=program_license, formatter_class=RawDescriptionHelpFormatter\n        )\n        QueryCmd.add_args(parser)\n\n        parser.add_argument(\n            \"-en\",\n            \"--endpointName\",\n            default=\"wikidata\",\n            help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames()}\",\n        )\n        parser.add_argument(\"--method\", help=\"method to be used for SPARQL queries\")\n        parser.add_argument(\"-f\", \"--format\", type=Format, choices=list(Format))\n        parser.add_argument(\n            \"-m\", \"--mimeType\", help=\"MIME-type to use for the raw query\"\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--prefixes\",\n            action=\"store_true\",\n            help=\"add predefined prefixes for endpoint\",\n        )\n        parser.add_argument(\n            \"-raw\",\n            action=\"store_true\",\n            help=\"return the raw query result from the endpoint. (MIME type defined over -f or -m)\",\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=program_version_message\n        )\n        if lang is None:\n            parser.add_argument(\n                \"-l\", \"--language\", help=\"the query language to use\", required=True\n            )\n        args = parser.parse_args(argv)\n        if lang is not None:\n            args.language = lang\n        query_main = QueryMain(args)\n        query_main.handle_args()\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#lodstorage.querymain.mainSPARQL","title":"<code>mainSPARQL(argv=None)</code>","text":"<p>commandline for SPARQL queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def mainSPARQL(argv=None):\n    \"\"\"\n    commandline for SPARQL queries\n    \"\"\"\n    main(argv, lang=\"sparql\")\n</code></pre>"},{"location":"#lodstorage.querymain.mainSQL","title":"<code>mainSQL(argv=None)</code>","text":"<p>commandline for SQL queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def mainSQL(argv=None):\n    \"\"\"\n    commandline for SQL queries\n    \"\"\"\n    main(argv, lang=\"sql\")\n</code></pre>"},{"location":"#lodstorage.rate_limiter","title":"<code>rate_limiter</code>","text":"<p>Created on 2024-08-24</p> <p>@author: wf</p>"},{"location":"#lodstorage.rate_limiter.RateLimiter","title":"<code>RateLimiter</code>","text":"<p>Wrap the @limits decorator in a new decorator</p> Source code in <code>lodstorage/rate_limiter.py</code> <pre><code>class RateLimiter:\n    \"\"\"\n    Wrap the @limits decorator in a new decorator\n    \"\"\"\n\n    def __init__(self, calls_per_minute: int = None):\n        if calls_per_minute is None:\n            calls_per_minute = 60 * 1000 * 1000  # use an irrationally high value\n        self.calls_per_minute = calls_per_minute\n\n    def rate_limited(self, f: callable):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            @sleep_and_retry\n            @limits(calls=self.calls_per_minute, period=60)\n            def rate_limited_function():\n                return f(*args, **kwargs)\n\n            return rate_limited_function()\n\n        return wrapper\n</code></pre>"},{"location":"#lodstorage.rdf","title":"<code>rdf</code>","text":"<p>Created on 2024-01-27</p> <p>@author: wf, using ChatGPT-4 prompting</p>"},{"location":"#lodstorage.rdf.RDFDumper","title":"<code>RDFDumper</code>","text":"<p>A class to convert instances of data models (based on a LinkML schema) into an RDF graph.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>class RDFDumper:\n    \"\"\"\n    A class to convert instances of data models (based on a LinkML schema) into an RDF graph.\n    \"\"\"\n\n    def __init__(self, schema: Schema, instance: object):\n        \"\"\"\n        Initialize the RDFDumper.\n\n        Args:\n            schema (Schema): The LinkML schema defining the structure of the data models.\n            instance (object): The instance of the data model to be converted into RDF.\n        \"\"\"\n        self.schema = schema\n        self.instance = instance\n        self.graph = Graph()\n        self.namespaces = {\n            prefix: Namespace(uri) for prefix, uri in schema.prefixes.items()\n        }\n\n    def convert_to_rdf(self):\n        \"\"\"\n        Converts the provided instance into RDF triples based on the LinkML schema.\n        \"\"\"\n        # Process the instance data according to its class in the schema\n        instance_class = self.instance.__class__.__name__\n        if instance_class in self.schema.classes:\n            self.process_class(instance_class, self.instance)\n\n    def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n        \"\"\"\n        Serializes the RDF graph into a string representation in the specified format.\n\n        Args:\n            format (str): The serialization format (e.g., 'turtle', 'xml', 'json-ld').\n\n        Returns:\n            str: The serialized RDF graph.\n        \"\"\"\n        return self.graph.serialize(format=rdf_format)\n\n    def value_iterator(self, value: Any):\n        \"\"\"\n        Iterates over values in a mapping or iterable.\n\n        Args:\n            value: The value to iterate over. It can be a mapping, iterable, or a single value.\n\n        Yields:\n            Tuples of (key, value) from the input value. For single values, key is None.\n        \"\"\"\n        if isinstance(value, Mapping):\n            yield from value.items()\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            yield from ((None, v) for v in value)\n        else:\n            yield (None, value)\n\n    def process_class(self, class_name: str, instance_data: object):\n        # Get the base namespace URI\n        self.base_uri = self.namespaces[self.schema.default_prefix]\n        # get the class object\n        # class_obj = self.schema.classes[class_name]\n        # Construct class_uri using the namespace and class_name with a separator\n        class_uri = URIRef(f\"{self.base_uri}:{class_name}\")\n\n        # Create a unique URI or a Blank Node for the instance\n        instance_uri = self.get_instance_uri(instance_data)\n\n        # Type the instance with its class\n        self.graph.add((instance_uri, RDF.type, class_uri))\n\n        # loop over all fieds of the instance data\n        for field_info in fields(instance_data):\n            slot_name = field_info.name\n            # assure we only work on fields defined\n            # in our schema\n            slot_obj = self.schema.slots.get(slot_name)\n            if not slot_obj:\n                continue\n\n            # Combine the namespace with the slot name to form the field URI\n            field_uri = URIRef(f\"{self.base_uri}:{slot_name}\")\n            field_value = getattr(instance_data, slot_name, None)\n\n            # Use value_iterator to handle different types of values\n            for key, item in self.value_iterator(field_value):\n                if key is not None:\n                    # Handle as a mapping\n                    key_uri = URIRef(self.namespaces[self.schema.default_prefix][key])\n                    self.graph.add((instance_uri, field_uri, key_uri))\n                    self.graph.add(\n                        (key_uri, RDF.value, self.convert_to_literal(item, slot_obj))\n                    )\n                else:\n                    # Handle as a single value or an item from an iterable\n                    # Check if item has an 'identifier' property\n                    if hasattr(item, \"identifier\") and getattr(item, \"identifier\"):\n                        item_uri = self.get_instance_uri(item)\n                        self.graph.add((instance_uri, field_uri, item_uri))\n                        self.process_class(item.__class__.__name__, item)\n                    else:\n                        self.graph.add(\n                            (\n                                instance_uri,\n                                field_uri,\n                                self.convert_to_literal(item, slot_obj),\n                            )\n                        )\n\n    def get_instance_uri(self, instance_data):\n        \"\"\"\n        Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI.\n        Otherwise, it generates or retrieves a unique URI.\n        \"\"\"\n        if hasattr(instance_data, \"identifier\") and getattr(\n            instance_data, \"identifier\"\n        ):\n            identifier = getattr(instance_data, \"identifier\")\n            return URIRef(f\"{self.base_uri}:{identifier}\")\n        else:\n            # Fallback to a blank node if no identifier is found\n            return BNode()\n\n    def convert_to_literal(self, value, slot_obj):\n        \"\"\"\n        Converts a value to an RDFLib Literal with appropriate datatype.\n\n        Args:\n            value: The value to be converted.\n            slot_obj: The slot object containing information about the field.\n\n        Returns:\n            An RDFLib Literal with the value and appropriate datatype.\n        \"\"\"\n        # Determine the datatype based on the Python type of the value\n        datatype = PythonTypes.get_rdf_datatype(type(value))\n\n        # Create and return the literal\n        return Literal(value, datatype=datatype)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.__init__","title":"<code>__init__(schema, instance)</code>","text":"<p>Initialize the RDFDumper.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The LinkML schema defining the structure of the data models.</p> required <code>instance</code> <code>object</code> <p>The instance of the data model to be converted into RDF.</p> required Source code in <code>lodstorage/rdf.py</code> <pre><code>def __init__(self, schema: Schema, instance: object):\n    \"\"\"\n    Initialize the RDFDumper.\n\n    Args:\n        schema (Schema): The LinkML schema defining the structure of the data models.\n        instance (object): The instance of the data model to be converted into RDF.\n    \"\"\"\n    self.schema = schema\n    self.instance = instance\n    self.graph = Graph()\n    self.namespaces = {\n        prefix: Namespace(uri) for prefix, uri in schema.prefixes.items()\n    }\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.convert_to_literal","title":"<code>convert_to_literal(value, slot_obj)</code>","text":"<p>Converts a value to an RDFLib Literal with appropriate datatype.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The value to be converted.</p> required <code>slot_obj</code> <p>The slot object containing information about the field.</p> required <p>Returns:</p> Type Description <p>An RDFLib Literal with the value and appropriate datatype.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def convert_to_literal(self, value, slot_obj):\n    \"\"\"\n    Converts a value to an RDFLib Literal with appropriate datatype.\n\n    Args:\n        value: The value to be converted.\n        slot_obj: The slot object containing information about the field.\n\n    Returns:\n        An RDFLib Literal with the value and appropriate datatype.\n    \"\"\"\n    # Determine the datatype based on the Python type of the value\n    datatype = PythonTypes.get_rdf_datatype(type(value))\n\n    # Create and return the literal\n    return Literal(value, datatype=datatype)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.convert_to_rdf","title":"<code>convert_to_rdf()</code>","text":"<p>Converts the provided instance into RDF triples based on the LinkML schema.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def convert_to_rdf(self):\n    \"\"\"\n    Converts the provided instance into RDF triples based on the LinkML schema.\n    \"\"\"\n    # Process the instance data according to its class in the schema\n    instance_class = self.instance.__class__.__name__\n    if instance_class in self.schema.classes:\n        self.process_class(instance_class, self.instance)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.get_instance_uri","title":"<code>get_instance_uri(instance_data)</code>","text":"<p>Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI. Otherwise, it generates or retrieves a unique URI.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def get_instance_uri(self, instance_data):\n    \"\"\"\n    Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI.\n    Otherwise, it generates or retrieves a unique URI.\n    \"\"\"\n    if hasattr(instance_data, \"identifier\") and getattr(\n        instance_data, \"identifier\"\n    ):\n        identifier = getattr(instance_data, \"identifier\")\n        return URIRef(f\"{self.base_uri}:{identifier}\")\n    else:\n        # Fallback to a blank node if no identifier is found\n        return BNode()\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.serialize","title":"<code>serialize(rdf_format='turtle')</code>","text":"<p>Serializes the RDF graph into a string representation in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>The serialization format (e.g., 'turtle', 'xml', 'json-ld').</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serialized RDF graph.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n    \"\"\"\n    Serializes the RDF graph into a string representation in the specified format.\n\n    Args:\n        format (str): The serialization format (e.g., 'turtle', 'xml', 'json-ld').\n\n    Returns:\n        str: The serialized RDF graph.\n    \"\"\"\n    return self.graph.serialize(format=rdf_format)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.value_iterator","title":"<code>value_iterator(value)</code>","text":"<p>Iterates over values in a mapping or iterable.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to iterate over. It can be a mapping, iterable, or a single value.</p> required <p>Yields:</p> Type Description <p>Tuples of (key, value) from the input value. For single values, key is None.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def value_iterator(self, value: Any):\n    \"\"\"\n    Iterates over values in a mapping or iterable.\n\n    Args:\n        value: The value to iterate over. It can be a mapping, iterable, or a single value.\n\n    Yields:\n        Tuples of (key, value) from the input value. For single values, key is None.\n    \"\"\"\n    if isinstance(value, Mapping):\n        yield from value.items()\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        yield from ((None, v) for v in value)\n    else:\n        yield (None, value)\n</code></pre>"},{"location":"#lodstorage.rdf_format","title":"<code>rdf_format</code>","text":"<p>Created on 2025-06-01</p> <p>@author: wf</p>"},{"location":"#lodstorage.rdf_format.RdfFormat","title":"<code>RdfFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>RDF serialization formats with MIME types, file extensions, and SPARQLWrapper constants.</p> Source code in <code>lodstorage/rdf_format.py</code> <pre><code>class RdfFormat(Enum):\n    \"\"\"\n    RDF serialization formats with MIME types, file extensions, and SPARQLWrapper constants.\n    \"\"\"\n\n    TURTLE = (\"turtle\", \"text/turtle\", \".ttl\", TURTLE)\n    RDF_XML = (\"rdf-xml\", \"application/rdf+xml\", \".rdf\", RDF)\n    N3 = (\"n3\", \"text/n3\", \".n3\", N3)\n    JSON_LD = (\"json-ld\", \"application/ld+json\", \".jsonld\", JSON)\n\n    def __init__(self, label: str, mime_type: str, extension: str, sparql_format):\n        self.label = label\n        self.mime_type = mime_type\n        self.extension = extension\n        self.sparql_format = sparql_format\n\n    @classmethod\n    def by_label(cls, label: str):\n        \"\"\"Get format by label\"\"\"\n        for rdf_format in cls:\n            if rdf_format.label == label:\n                return rdf_format\n        raise ValueError(f\"Unknown format: {label}\")\n</code></pre>"},{"location":"#lodstorage.rdf_format.RdfFormat.by_label","title":"<code>by_label(label)</code>  <code>classmethod</code>","text":"<p>Get format by label</p> Source code in <code>lodstorage/rdf_format.py</code> <pre><code>@classmethod\ndef by_label(cls, label: str):\n    \"\"\"Get format by label\"\"\"\n    for rdf_format in cls:\n        if rdf_format.label == label:\n            return rdf_format\n    raise ValueError(f\"Unknown format: {label}\")\n</code></pre>"},{"location":"#lodstorage.sample2","title":"<code>sample2</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.sample2.Countries","title":"<code>Countries</code>","text":"<p>Represents a collection of country instances.</p> <p>Attributes:</p> Name Type Description <code>countries</code> <code>List[Country]</code> <p>A list of Country instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Countries:\n    \"\"\"\n    Represents a collection of country instances.\n\n    Attributes:\n        countries (List[Country]): A list of Country instances.\n    \"\"\"\n\n    countries: List[Country]\n\n    @classmethod\n    def get_countries_erdem(cls) -&gt; \"Countries\":\n        \"\"\"\n        get Erdem Ozkol's country list\n        \"\"\"\n        countries_json_url = \"https://gist.githubusercontent.com/erdem/8c7d26765831d0f9a8c62f02782ae00d/raw/248037cd701af0a4957cce340dabb0fd04e38f4c/countries.json\"\n        json_str = cls.read_from_url(countries_json_url)\n        countries_list = json.loads(json_str)\n        countries_dict = {\"countries\": countries_list}\n        instance = cls.from_dict(countries_dict)\n        return instance\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"Countries\"]:\n        \"\"\"\n        Returns a dictionary of named samples\n        for 'specification by example' style\n        requirements management.\n\n        Returns:\n            dict: A dictionary with keys as sample names\n            and values as `Countries` instances.\n        \"\"\"\n        samples = {\"country list provided by Erdem Ozkol\": cls.get_countries_erdem()}\n        return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Countries.get_countries_erdem","title":"<code>get_countries_erdem()</code>  <code>classmethod</code>","text":"<p>get Erdem Ozkol's country list</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_countries_erdem(cls) -&gt; \"Countries\":\n    \"\"\"\n    get Erdem Ozkol's country list\n    \"\"\"\n    countries_json_url = \"https://gist.githubusercontent.com/erdem/8c7d26765831d0f9a8c62f02782ae00d/raw/248037cd701af0a4957cce340dabb0fd04e38f4c/countries.json\"\n    json_str = cls.read_from_url(countries_json_url)\n    countries_list = json.loads(json_str)\n    countries_dict = {\"countries\": countries_list}\n    instance = cls.from_dict(countries_dict)\n    return instance\n</code></pre>"},{"location":"#lodstorage.sample2.Countries.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>Returns a dictionary of named samples for 'specification by example' style requirements management.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Countries]</code> <p>A dictionary with keys as sample names</p> <code>dict[str, Countries]</code> <p>and values as <code>Countries</code> instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"Countries\"]:\n    \"\"\"\n    Returns a dictionary of named samples\n    for 'specification by example' style\n    requirements management.\n\n    Returns:\n        dict: A dictionary with keys as sample names\n        and values as `Countries` instances.\n    \"\"\"\n    samples = {\"country list provided by Erdem Ozkol\": cls.get_countries_erdem()}\n    return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Country","title":"<code>Country</code>","text":"<p>Represents a country with its details.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the country.</p> <code>country_code</code> <code>str</code> <p>The country code.</p> <code>capital</code> <code>Optional[str]</code> <p>The capital city of the country.</p> <code>timezones</code> <code>List[str]</code> <p>List of timezones in the country.</p> <code>latlng</code> <code>List[float]</code> <p>Latitude and longitude of the country.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Country:\n    \"\"\"\n    Represents a country with its details.\n\n    Attributes:\n        name (str): The name of the country.\n        country_code (str): The country code.\n        capital (Optional[str]): The capital city of the country.\n        timezones (List[str]): List of timezones in the country.\n        latlng (List[float]): Latitude and longitude of the country.\n    \"\"\"\n\n    name: str\n    country_code: str\n    capital: Optional[str] = None\n    timezones: List[str] = field(default_factory=list)\n    latlng: List[float] = field(default_factory=list)\n</code></pre>"},{"location":"#lodstorage.sample2.Royal","title":"<code>Royal</code>","text":"<p>Represents a member of the royal family, with various personal details.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The full name of the royal member.</p> <code>wikidata_id</code> <code>str</code> <p>The Wikidata identifier associated with the royal member.</p> <code>number_in_line</code> <code>Optional[int]</code> <p>The number in line to succession, if applicable.</p> <code>born_iso_date</code> <code>Optional[str]</code> <p>The ISO date of birth.</p> <code>died_iso_date</code> <code>Optional[str]</code> <p>The ISO date of death, if deceased.</p> <code>last_modified_iso</code> <code>str</code> <p>ISO timestamp of the last modification.</p> <code>age</code> <code>Optional[int]</code> <p>The age of the royal member.</p> <code>of_age</code> <code>Optional[bool]</code> <p>Indicates whether the member is of legal age.</p> <code>wikidata_url</code> <code>Optional[str]</code> <p>URL to the Wikidata page of the member.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Royal:\n    \"\"\"\n    Represents a member of the royal family, with various personal details.\n\n    Attributes:\n        name (str): The full name of the royal member.\n        wikidata_id (str): The Wikidata identifier associated with the royal member.\n        number_in_line (Optional[int]): The number in line to succession, if applicable.\n        born_iso_date (Optional[str]): The ISO date of birth.\n        died_iso_date (Optional[str]): The ISO date of death, if deceased.\n        last_modified_iso (str): ISO timestamp of the last modification.\n        age (Optional[int]): The age of the royal member.\n        of_age (Optional[bool]): Indicates whether the member is of legal age.\n        wikidata_url (Optional[str]): URL to the Wikidata page of the member.\n    \"\"\"\n\n    name: str\n    wikidata_id: str\n    number_in_line: Optional[int] = None\n    born_iso_date: Optional[str] = None\n    died_iso_date: Optional[str] = None\n    lastmodified_iso: Optional[str] = None\n    age: Optional[int] = field(init=None)\n    of_age: Optional[bool] = field(init=None)\n    wikidata_url: Optional[str] = field(init=None)\n\n    def __post_init__(self):\n        \"\"\"\n        init calculated fields\n        \"\"\"\n        end_date = self.died if self.died else date.today()\n        self.age = int((end_date - self.born).days / 365.2425)\n        self.of_age = self.age &gt;= 18\n        if self.wikidata_id:\n            self.wikidata_url = f\"https://www.wikidata.org/wiki/{self.wikidata_id}\"\n\n    @property\n    def identifier(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the Royal instance.\n        The identifier is a combination of a slugified name and the Wikidata ID (if available).\n        \"\"\"\n        slugified_name = slugify(self.name, lowercase=False, regex_pattern=r\"[^\\w\\-]\")\n        if self.wikidata_id:\n            return f\"{slugified_name}-{self.wikidata_id}\"\n        return slugified_name\n\n    @property\n    def born(self) -&gt; date:\n        \"\"\"Return the date of birth from the ISO date string.\"\"\"\n        born_date = DateConvert.iso_date_to_datetime(self.born_iso_date)\n        return born_date\n\n    @property\n    def died(self) -&gt; Optional[date]:\n        \"\"\"Return the date of death from the ISO date string, if available.\"\"\"\n        died_date = DateConvert.iso_date_to_datetime(self.died_iso_date)\n        return died_date\n</code></pre>"},{"location":"#lodstorage.sample2.Royal.born","title":"<code>born</code>  <code>property</code>","text":"<p>Return the date of birth from the ISO date string.</p>"},{"location":"#lodstorage.sample2.Royal.died","title":"<code>died</code>  <code>property</code>","text":"<p>Return the date of death from the ISO date string, if available.</p>"},{"location":"#lodstorage.sample2.Royal.identifier","title":"<code>identifier</code>  <code>property</code>","text":"<p>Generates a unique identifier for the Royal instance. The identifier is a combination of a slugified name and the Wikidata ID (if available).</p>"},{"location":"#lodstorage.sample2.Royal.__post_init__","title":"<code>__post_init__()</code>","text":"<p>init calculated fields</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    init calculated fields\n    \"\"\"\n    end_date = self.died if self.died else date.today()\n    self.age = int((end_date - self.born).days / 365.2425)\n    self.of_age = self.age &gt;= 18\n    if self.wikidata_id:\n        self.wikidata_url = f\"https://www.wikidata.org/wiki/{self.wikidata_id}\"\n</code></pre>"},{"location":"#lodstorage.sample2.Royals","title":"<code>Royals</code>","text":"<p>Represents a collection of Royal family members.</p> <p>Attributes:</p> Name Type Description <code>members</code> <code>List[Royal]</code> <p>A list of Royal family members.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Royals:\n    \"\"\"\n    Represents a collection of Royal family members.\n\n    Attributes:\n        members (List[Royal]): A list of Royal family members.\n    \"\"\"\n\n    members: List[Royal] = field(default_factory=list)\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"Royals\"]:\n        \"\"\"\n        Returns a dictionary of named samples\n        for 'specification by example' style\n        requirements management.\n\n        Returns:\n            dict: A dictionary with keys as sample names and values as `Royals` instances.\n        \"\"\"\n        samples = {\n            \"QE2 heirs up to number in line 5\": Royals(\n                members=[\n                    Royal(\n                        name=\"Elizabeth Alexandra Mary Windsor\",\n                        born_iso_date=\"1926-04-21\",\n                        died_iso_date=\"2022-09-08\",\n                        wikidata_id=\"Q9682\",\n                        number_in_line=-1,  # for deceased or unranked\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"Charles III of the United Kingdom\",\n                        born_iso_date=\"1948-11-14\",\n                        number_in_line=0,\n                        wikidata_id=\"Q43274\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"William, Duke of Cambridge\",\n                        born_iso_date=\"1982-06-21\",\n                        number_in_line=1,\n                        wikidata_id=\"Q36812\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"Prince George of Wales\",\n                        born_iso_date=\"2013-07-22\",\n                        number_in_line=2,\n                        wikidata_id=\"Q13590412\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"Princess Charlotte of Wales\",\n                        born_iso_date=\"2015-05-02\",\n                        number_in_line=3,\n                        wikidata_id=\"Q18002970\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"Prince Louis of Wales\",\n                        born_iso_date=\"2018-04-23\",\n                        number_in_line=4,\n                        wikidata_id=\"Q38668629\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                    Royal(\n                        name=\"Harry Duke of Sussex\",\n                        born_iso_date=\"1984-09-15\",\n                        number_in_line=5,\n                        wikidata_id=\"Q152316\",\n                        lastmodified_iso=\"2022-09-08\",\n                    ),\n                ]\n            )\n        }\n        return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Royals.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>Returns a dictionary of named samples for 'specification by example' style requirements management.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Royals]</code> <p>A dictionary with keys as sample names and values as <code>Royals</code> instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"Royals\"]:\n    \"\"\"\n    Returns a dictionary of named samples\n    for 'specification by example' style\n    requirements management.\n\n    Returns:\n        dict: A dictionary with keys as sample names and values as `Royals` instances.\n    \"\"\"\n    samples = {\n        \"QE2 heirs up to number in line 5\": Royals(\n            members=[\n                Royal(\n                    name=\"Elizabeth Alexandra Mary Windsor\",\n                    born_iso_date=\"1926-04-21\",\n                    died_iso_date=\"2022-09-08\",\n                    wikidata_id=\"Q9682\",\n                    number_in_line=-1,  # for deceased or unranked\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"Charles III of the United Kingdom\",\n                    born_iso_date=\"1948-11-14\",\n                    number_in_line=0,\n                    wikidata_id=\"Q43274\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"William, Duke of Cambridge\",\n                    born_iso_date=\"1982-06-21\",\n                    number_in_line=1,\n                    wikidata_id=\"Q36812\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"Prince George of Wales\",\n                    born_iso_date=\"2013-07-22\",\n                    number_in_line=2,\n                    wikidata_id=\"Q13590412\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"Princess Charlotte of Wales\",\n                    born_iso_date=\"2015-05-02\",\n                    number_in_line=3,\n                    wikidata_id=\"Q18002970\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"Prince Louis of Wales\",\n                    born_iso_date=\"2018-04-23\",\n                    number_in_line=4,\n                    wikidata_id=\"Q38668629\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n                Royal(\n                    name=\"Harry Duke of Sussex\",\n                    born_iso_date=\"1984-09-15\",\n                    number_in_line=5,\n                    wikidata_id=\"Q152316\",\n                    lastmodified_iso=\"2022-09-08\",\n                ),\n            ]\n        )\n    }\n    return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Sample","title":"<code>Sample</code>","text":"<p>Sample dataset provider</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>class Sample:\n    \"\"\"\n    Sample dataset provider\n    \"\"\"\n\n    cityList = None\n\n    @staticmethod\n    def get(dataset_name: str):\n        \"\"\"\n        Get the given sample dataset name\n        \"\"\"\n        samples = None\n        if dataset_name == \"royals\":\n            samples = Royals.get_samples()\n        elif dataset_name == \"countries\":\n            samples = Countries.get_samples()\n        else:\n            raise ValueError(\"Unknown dataset name\")\n        return samples\n\n    @staticmethod\n    def getRoyalsSample() -&gt; Royals:\n        samples = Royals.get_samples()\n        all_members = []\n        for royals in samples.values():\n            all_members.extend(royals.members)\n        royals = Royals(members=all_members)\n        return royals\n\n    @staticmethod\n    def getSample(size) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        get a generated sample of the given size\n        \"\"\"\n        listOfDicts = []\n        for index in range(size):\n            listOfDicts.append({\"pkey\": \"index%d\" % index, \"cindex\": index})\n        return listOfDicts\n\n    @staticmethod\n    def getRoyals() -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        compatibility for old sample module\n        return list of dicts\n        \"\"\"\n        royals_dict = Royals.get_samples()\n        royals = royals_dict.get(\"QE2 heirs up to number in line 5\")\n        royals_lod = []\n        for royal in royals.members:\n            record = royal.to_dict()\n            royals_lod.append(record)\n        return royals_lod\n\n    @staticmethod\n    def getCities() -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        get a list of city records\n        compatibility for old sample module\n        return list of dicts\n        \"\"\"\n        if Sample.cityList is None:\n            cityJsonUrl = \"https://raw.githubusercontent.com/lutangar/cities.json/master/cities.json\"\n            with urllib.request.urlopen(cityJsonUrl) as url:\n                Sample.cityList = json.loads(url.read().decode())\n            for city in Sample.cityList:\n                city[\"cityId\"] = \"%s-%s\" % (city[\"country\"], city[\"name\"])\n        return Sample.cityList\n</code></pre>"},{"location":"#lodstorage.sample2.Sample.get","title":"<code>get(dataset_name)</code>  <code>staticmethod</code>","text":"<p>Get the given sample dataset name</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@staticmethod\ndef get(dataset_name: str):\n    \"\"\"\n    Get the given sample dataset name\n    \"\"\"\n    samples = None\n    if dataset_name == \"royals\":\n        samples = Royals.get_samples()\n    elif dataset_name == \"countries\":\n        samples = Countries.get_samples()\n    else:\n        raise ValueError(\"Unknown dataset name\")\n    return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Sample.getCities","title":"<code>getCities()</code>  <code>staticmethod</code>","text":"<p>get a list of city records compatibility for old sample module return list of dicts</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@staticmethod\ndef getCities() -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    get a list of city records\n    compatibility for old sample module\n    return list of dicts\n    \"\"\"\n    if Sample.cityList is None:\n        cityJsonUrl = \"https://raw.githubusercontent.com/lutangar/cities.json/master/cities.json\"\n        with urllib.request.urlopen(cityJsonUrl) as url:\n            Sample.cityList = json.loads(url.read().decode())\n        for city in Sample.cityList:\n            city[\"cityId\"] = \"%s-%s\" % (city[\"country\"], city[\"name\"])\n    return Sample.cityList\n</code></pre>"},{"location":"#lodstorage.sample2.Sample.getRoyals","title":"<code>getRoyals()</code>  <code>staticmethod</code>","text":"<p>compatibility for old sample module return list of dicts</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@staticmethod\ndef getRoyals() -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    compatibility for old sample module\n    return list of dicts\n    \"\"\"\n    royals_dict = Royals.get_samples()\n    royals = royals_dict.get(\"QE2 heirs up to number in line 5\")\n    royals_lod = []\n    for royal in royals.members:\n        record = royal.to_dict()\n        royals_lod.append(record)\n    return royals_lod\n</code></pre>"},{"location":"#lodstorage.sample2.Sample.getSample","title":"<code>getSample(size)</code>  <code>staticmethod</code>","text":"<p>get a generated sample of the given size</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@staticmethod\ndef getSample(size) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    get a generated sample of the given size\n    \"\"\"\n    listOfDicts = []\n    for index in range(size):\n        listOfDicts.append({\"pkey\": \"index%d\" % index, \"cindex\": index})\n    return listOfDicts\n</code></pre>"},{"location":"#lodstorage.schema","title":"<code>schema</code>","text":"<p>Created on 2021-01-26</p> <p>@author: wf</p>"},{"location":"#lodstorage.schema.Schema","title":"<code>Schema</code>","text":"<p>               Bases: <code>object</code></p> <p>a relational Schema</p> Source code in <code>lodstorage/schema.py</code> <pre><code>class Schema(object):\n    \"\"\"\n    a relational Schema\n    \"\"\"\n\n    def __init__(self, name: str, title: str):\n        \"\"\"\n        Constructor\n\n        Args:\n            name(str): the name of the schema\n            title(str): the title of the schema\n        \"\"\"\n        self.name = name\n        self.title = title\n        self.propsByName = {}\n\n    @staticmethod\n    def generalizeColumn(tableList, colName: str):\n        \"\"\"\n        remove the column with the given name from all tables in the tablelist and\n        return it\n\n        Args:\n            tableList(list): a list of Tables\n            colName(string): the name of the column to generalize\n\n        Returns:\n            string: the column having been generalized and removed\n        \"\"\"\n        gCol = None\n        for table in tableList:\n            for col in table[\"columns\"]:\n                if col[\"name\"] == colName:\n                    gCol = col.copy()\n                    # no linking yet @FIXME - will need this later\n                    if \"link\" in gCol:\n                        gCol.pop(\"link\")\n                    # is generalization protected for this column?\n                    if not \"special\" in col or not col[\"special\"]:\n                        table[\"columns\"].remove(col)\n        return gCol\n\n    @staticmethod\n    def getGeneral(tableList, name: str, debug: bool = False):\n        \"\"\"\n        derive a general table from the given table list\n        Args:\n            tableList(list): a list of tables\n            name(str): name of the general table\n            debug(bool): True if column names should be shown\n\n        Returns:\n            a table dict for the generalized table\n        \"\"\"\n        general = {\"name\": name, \"columns\": []}\n        colCount = Counter()\n        for table in tableList:\n            for col in table[\"columns\"]:\n                columnId = \"%s.%s\" % (col[\"name\"], col[\"type\"])\n                if debug:\n                    print(columnId)\n                colCount[columnId] += 1\n        for columnId, count in colCount.items():\n            if count == len(tableList):\n                colName = columnId.split(\".\")[0]\n                generalCol = Schema.generalizeColumn(tableList, colName)\n                general[\"columns\"].append(generalCol)\n        return general\n\n    @staticmethod\n    def getGeneralViewDDL(tableList, name: str, debug=False) -&gt; str:\n        \"\"\"\n        get the DDL statement to create a general view\n\n        Args:\n            tableList: the list of tables\n            name (str): the name of the view\n            debug (bool): True if debug should be set\n        \"\"\"\n        general = Schema.getGeneral(tableList, name, debug)\n        cols = \"\"\n        delim = \"\"\n        for col in general[\"columns\"]:\n            col_name = col[\"name\"].strip()\n            cols += f\"{delim}{col_name}\"\n            delim = \",\"\n        ddl = f\"CREATE VIEW {name} AS\\n\"\n        delim = \"\"\n        for table in tableList:\n            table_name = table[\"name\"].strip()\n            ddl += f\"{delim}  SELECT {cols} FROM {table_name}\"\n            delim = \"\\nUNION\\n\"\n        return ddl\n</code></pre>"},{"location":"#lodstorage.schema.Schema.__init__","title":"<code>__init__(name, title)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the schema</p> required <code>title(str)</code> <p>the title of the schema</p> required Source code in <code>lodstorage/schema.py</code> <pre><code>def __init__(self, name: str, title: str):\n    \"\"\"\n    Constructor\n\n    Args:\n        name(str): the name of the schema\n        title(str): the title of the schema\n    \"\"\"\n    self.name = name\n    self.title = title\n    self.propsByName = {}\n</code></pre>"},{"location":"#lodstorage.schema.Schema.generalizeColumn","title":"<code>generalizeColumn(tableList, colName)</code>  <code>staticmethod</code>","text":"<p>remove the column with the given name from all tables in the tablelist and return it</p> <p>Parameters:</p> Name Type Description Default <code>tableList(list)</code> <p>a list of Tables</p> required <code>colName(string)</code> <p>the name of the column to generalize</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the column having been generalized and removed</p> Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef generalizeColumn(tableList, colName: str):\n    \"\"\"\n    remove the column with the given name from all tables in the tablelist and\n    return it\n\n    Args:\n        tableList(list): a list of Tables\n        colName(string): the name of the column to generalize\n\n    Returns:\n        string: the column having been generalized and removed\n    \"\"\"\n    gCol = None\n    for table in tableList:\n        for col in table[\"columns\"]:\n            if col[\"name\"] == colName:\n                gCol = col.copy()\n                # no linking yet @FIXME - will need this later\n                if \"link\" in gCol:\n                    gCol.pop(\"link\")\n                # is generalization protected for this column?\n                if not \"special\" in col or not col[\"special\"]:\n                    table[\"columns\"].remove(col)\n    return gCol\n</code></pre>"},{"location":"#lodstorage.schema.Schema.getGeneral","title":"<code>getGeneral(tableList, name, debug=False)</code>  <code>staticmethod</code>","text":"<p>derive a general table from the given table list Args:     tableList(list): a list of tables     name(str): name of the general table     debug(bool): True if column names should be shown</p> <p>Returns:</p> Type Description <p>a table dict for the generalized table</p> Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef getGeneral(tableList, name: str, debug: bool = False):\n    \"\"\"\n    derive a general table from the given table list\n    Args:\n        tableList(list): a list of tables\n        name(str): name of the general table\n        debug(bool): True if column names should be shown\n\n    Returns:\n        a table dict for the generalized table\n    \"\"\"\n    general = {\"name\": name, \"columns\": []}\n    colCount = Counter()\n    for table in tableList:\n        for col in table[\"columns\"]:\n            columnId = \"%s.%s\" % (col[\"name\"], col[\"type\"])\n            if debug:\n                print(columnId)\n            colCount[columnId] += 1\n    for columnId, count in colCount.items():\n        if count == len(tableList):\n            colName = columnId.split(\".\")[0]\n            generalCol = Schema.generalizeColumn(tableList, colName)\n            general[\"columns\"].append(generalCol)\n    return general\n</code></pre>"},{"location":"#lodstorage.schema.Schema.getGeneralViewDDL","title":"<code>getGeneralViewDDL(tableList, name, debug=False)</code>  <code>staticmethod</code>","text":"<p>get the DDL statement to create a general view</p> <p>Parameters:</p> Name Type Description Default <code>tableList</code> <p>the list of tables</p> required <code>name</code> <code>str</code> <p>the name of the view</p> required <code>debug</code> <code>bool</code> <p>True if debug should be set</p> <code>False</code> Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef getGeneralViewDDL(tableList, name: str, debug=False) -&gt; str:\n    \"\"\"\n    get the DDL statement to create a general view\n\n    Args:\n        tableList: the list of tables\n        name (str): the name of the view\n        debug (bool): True if debug should be set\n    \"\"\"\n    general = Schema.getGeneral(tableList, name, debug)\n    cols = \"\"\n    delim = \"\"\n    for col in general[\"columns\"]:\n        col_name = col[\"name\"].strip()\n        cols += f\"{delim}{col_name}\"\n        delim = \",\"\n    ddl = f\"CREATE VIEW {name} AS\\n\"\n    delim = \"\"\n    for table in tableList:\n        table_name = table[\"name\"].strip()\n        ddl += f\"{delim}  SELECT {cols} FROM {table_name}\"\n        delim = \"\\nUNION\\n\"\n    return ddl\n</code></pre>"},{"location":"#lodstorage.schema.SchemaManager","title":"<code>SchemaManager</code>","text":"<p>               Bases: <code>object</code></p> <p>a manager for schemas</p> Source code in <code>lodstorage/schema.py</code> <pre><code>class SchemaManager(\n    object,\n):\n    \"\"\"\n    a manager for schemas\n    \"\"\"\n\n    def __init__(self, schemaDefs=None, baseUrl: str = None):\n        \"\"\"\n        constructor\n            Args:\n                schemaDefs(dict): a dictionary of schema names\n                baseUrl(str): the base url to use for links\n        \"\"\"\n        self.baseUrl = baseUrl\n        self.schemasByName = {}\n        if schemaDefs is None:\n            schemaDefs = {}\n        for key, name in schemaDefs.items():\n            self.schemasByName[key] = Schema(key, name)\n        pass\n</code></pre>"},{"location":"#lodstorage.schema.SchemaManager.__init__","title":"<code>__init__(schemaDefs=None, baseUrl=None)</code>","text":"<p>constructor     Args:         schemaDefs(dict): a dictionary of schema names         baseUrl(str): the base url to use for links</p> Source code in <code>lodstorage/schema.py</code> <pre><code>def __init__(self, schemaDefs=None, baseUrl: str = None):\n    \"\"\"\n    constructor\n        Args:\n            schemaDefs(dict): a dictionary of schema names\n            baseUrl(str): the base url to use for links\n    \"\"\"\n    self.baseUrl = baseUrl\n    self.schemasByName = {}\n    if schemaDefs is None:\n        schemaDefs = {}\n    for key, name in schemaDefs.items():\n        self.schemasByName[key] = Schema(key, name)\n    pass\n</code></pre>"},{"location":"#lodstorage.sparql","title":"<code>sparql</code>","text":"<p>Created on 2020-08-14</p> <p>@author: wf</p>"},{"location":"#lodstorage.sparql.SPARQL","title":"<code>SPARQL</code>","text":"<p>               Bases: <code>object</code></p> <p>wrapper for SPARQL e.g. Apache Jena, Virtuoso, Blazegraph</p> <p>:ivar url: full endpoint url (including mode) :ivar mode: 'query' or 'update' :ivar debug: True if debugging is active :ivar typedLiterals: True if INSERT should be done with typedLiterals :ivar profile(boolean): True if profiling / timing information should be displayed :ivar sparql: the SPARQLWrapper2 instance to be used :ivar method(str): the HTTP method to be used 'POST' or 'GET'</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>class SPARQL(object):\n    \"\"\"\n    wrapper for SPARQL e.g. Apache Jena, Virtuoso, Blazegraph\n\n    :ivar url: full endpoint url (including mode)\n    :ivar mode: 'query' or 'update'\n    :ivar debug: True if debugging is active\n    :ivar typedLiterals: True if INSERT should be done with typedLiterals\n    :ivar profile(boolean): True if profiling / timing information should be displayed\n    :ivar sparql: the SPARQLWrapper2 instance to be used\n    :ivar method(str): the HTTP method to be used 'POST' or 'GET'\n    \"\"\"\n\n    def __init__(\n        self,\n        url,\n        mode=\"query\",\n        debug=False,\n        isFuseki=False,\n        typedLiterals=False,\n        profile=False,\n        agent=\"PyLodStorage\",\n        method=\"POST\",\n        calls_per_minute: int = None,\n    ):\n        \"\"\"\n        Construct a SPARQL wrapper\n\n        Args:\n            url (string): the base URL of the endpoint - the mode query/update is going to be appended\n            mode (string): 'query' or 'update'\n            debug (bool): True if debugging is to be activated\n            typedLiterals (bool): True if INSERT should be done with typedLiterals\n            profile (boolean): True if profiling / timing information should be displayed\n            agent (string): the User agent to use\n            method (string): the HTTP method to be used 'POST' or 'GET'\n        \"\"\"\n        if isFuseki:\n            self.url = f\"{url}/{mode}\"\n        else:\n            self.url = url\n        self.mode = mode\n        self.debug = debug\n        self.typedLiterals = typedLiterals\n        self.profile = profile\n        self.sparql = SPARQLWrapper2(url)\n        self.method = method\n        self.sparql.agent = agent\n        self.rate_limiter = RateLimiter(calls_per_minute=calls_per_minute)\n\n    @classmethod\n    def fromEndpointConf(cls, endpointConf) -&gt; \"SPARQL\":\n        \"\"\"\n        create a SPARQL endpoint from the given EndpointConfiguration\n\n        Args:\n            endpointConf (Endpoint): the endpoint configuration to be used\n        \"\"\"\n        if not endpointConf:\n            raise ValueError(\"endpointConf must be specified\")\n        sparql = SPARQL(\n            url=endpointConf.endpoint,\n            method=endpointConf.method,\n            calls_per_minute=endpointConf.calls_per_minute,\n        )\n        if hasattr(endpointConf, \"auth\"):\n            authMethod = None\n            if endpointConf.auth == \"BASIC\":\n                authMethod = \"BASIC\"\n            elif endpointConf.auth == \"DIGEST\":\n                authMethod = \"DIGEST\"\n            sparql.addAuthentication(\n                endpointConf.user, endpointConf.password, method=authMethod\n            )\n        return sparql\n\n    def addAuthentication(self, username: str, password: str, method: str = \"BASIC\"):\n        \"\"\"\n        Add Http Authentication credentials to the sparql wrapper\n        Args:\n            username: name of the user\n            password: password of the user\n            method: HTTP Authentication method\n        \"\"\"\n        if method:\n            self.sparql.setHTTPAuth(method)\n\n        if username and password:\n            self.sparql.setCredentials(username, password)\n\n    def test_query(\n        self,\n        query: str = \"SELECT * WHERE { ?s ?p ?o } LIMIT 1\",\n        expected_bindings: int = 1,\n    ) -&gt; Exception:\n        \"\"\"\n        Check if the SPARQL endpoint is available using a standard SPARQL query.\n\n        Args:\n            query (str): the SPARQL query to use for testing\n\n        Returns:\n            Exception if the endpoint fails\n        \"\"\"\n        result = None\n        try:\n            query_result = self.rawQuery(query, method=self.method)\n            bindings = query_result.bindings\n            if not len(bindings) == expected_bindings:\n                raise Exception(\n                    f\"SPARQL query {query} returned {len(bindings)} bindings instead of {expected_bindings}\"\n                )\n        except Exception as ex:\n            result = ex\n        return result\n\n    def post_query_direct(\n        self, query: str, rdf_format: str = \"n3\", timeout: int = 60\n    ) -&gt; str:\n        \"\"\"\n        Fetch raw RDF response via direct HTTP POST.\n\n        Args:\n            query: SPARQL CONSTRUCT query\n            rdf_format: RDF format label (e.g. 'turtle', 'rdf-xml', 'json-ld', 'n3')\n            timeout: timeout in seconds (default: 60)\n\n        Returns:\n            Raw RDF content as string\n\n        Raises:\n            Exception if HTTP request fails\n        \"\"\"\n        rdf_format = RdfFormat.by_label(rdf_format)\n        mime_type = rdf_format.mime_type\n        headers = {\"Accept\": mime_type}\n        response = requests.post(\n            self.url,\n            data={\"query\": query},\n            headers=headers,\n            timeout=timeout,\n        )\n        if response.status_code != 200:\n            msg = f\"HTTP {response.status_code}: {response.text}\"\n            raise Exception(msg)\n        text = response.text.strip()\n        return text\n\n    def rawQuery(self, queryString: str, method=POST):\n        \"\"\"\n        query with the given query string\n\n        Args:\n            queryString(str): the SPARQL query to be performed\n            method(str): POST or GET - POST is mandatory for update queries\n        Returns:\n            list: the raw query result as bindings\n        \"\"\"\n        queryString = self.fix_comments(queryString)\n        self.sparql.setQuery(queryString)\n        self.sparql.method = method\n        bindings = self.sparql.query()\n        return bindings\n\n    def fix_comments(self, query_string: str) -&gt; str:\n        \"\"\"\n        make sure broken SPARQLWrapper will find comments\n        \"\"\"\n        if query_string is None:\n            return None\n        return \"#\\n\" + query_string\n\n    def getValue(self, sparqlQuery: str, attr: str):\n        \"\"\"\n        get the value for the given SPARQL query using the given attr\n\n        Args:\n            sparql(SPARQL): the SPARQL endpoint to ge the value for\n            sparqlQuery(str): the SPARQL query to run\n            attr(str): the attribute to get\n        \"\"\"\n        if self.debug:\n            print(sparqlQuery)\n        qLod = self.queryAsListOfDicts(sparqlQuery)\n        return self.getFirst(qLod, attr)\n\n    def getValues(self, sparqlQuery: str, attrList: list):\n        \"\"\"\n        get Values for the given sparlQuery and attribute list\n\n        Args:\n            sparqlQuery(str): the query which did not return any values\n            attrList(list): the list of attributes\n        \"\"\"\n        if self.debug:\n            print(sparqlQuery)\n        qLod = self.queryAsListOfDicts(sparqlQuery)\n        if not (len(qLod) == 1):\n            msg = f\"getValues for {attrList} failed for {qLod}\"\n            raise Exception(msg)\n        record = qLod[0]\n        values = ()\n        for attr in attrList:\n            if not attr in record:\n                msg = f\"getValues failed for attribute {attr} which is missing in result record {record}\"\n                raise Exception(msg)\n            recordTuple = (record[attr],)\n            values += recordTuple\n        return values\n\n    def getFirst(self, qLod: list, attr: str):\n        \"\"\"\n        get the column attr of the first row of the given qLod list\n\n        Args:\n            qLod(list): the list of dicts (returned by a query)\n            attr(str): the attribute to retrieve\n\n        Returns:\n            object: the value\n        \"\"\"\n        if len(qLod) == 1 and attr in qLod[0]:\n            value = qLod[0][attr]\n            return value\n        raise Exception(f\"getFirst for attribute {attr} failed for {qLod}\")\n\n    def getResults(self, jsonResult):\n        \"\"\"\n        get the result from the given jsonResult\n\n        Args:\n            jsonResult: the JSON encoded result\n\n        Returns:\n            list: the list of bindings\n        \"\"\"\n        return jsonResult.bindings\n\n    def insert(self, insertCommand):\n        \"\"\"\n        run an insert\n\n        Args:\n            insertCommand(string): the SPARQL INSERT command\n\n        Returns:\n            a response\n        \"\"\"\n        self.sparql.setRequestMethod(POSTDIRECTLY)\n        response = None\n        exception = None\n        try:\n            response = self.rawQuery(insertCommand, method=POST)\n            # see https://github.com/RDFLib/sparqlwrapper/issues/159#issuecomment-674523696\n            # dummy read the body\n            response.response.read()\n        except Exception as ex:\n            exception = ex\n            if self.debug:\n                print(ex)\n        return response, exception\n\n    def getLocalName(self, name):\n        \"\"\"\n        retrieve valid localname from a string based primary key\n        https://www.w3.org/TR/sparql11-query/#prefNames\n\n        Args:\n            name(string): the name to convert\n\n        Returns:\n            string: a valid local name\n        \"\"\"\n        localName = \"\".join(ch for ch in name if ch.isalnum())\n        return localName\n\n    def insertListOfDicts(\n        self,\n        listOfDicts,\n        entityType,\n        primaryKey,\n        prefixes,\n        limit=None,\n        batchSize=None,\n        profile=False,\n    ):\n        \"\"\"\n        insert the given list of dicts mapping datatypes\n\n        Args:\n            entityType(string): the entityType to use as a\n            primaryKey(string): the name of the primary key attribute to use\n            prefix(string): any PREFIX statements to be used\n            limit(int): maximum number of records to insert\n            batchSize(int): number of records to send per request\n\n        Return:\n            a list of errors which should be empty on full success\n\n        datatype maping according to\n        https://www.w3.org/TR/xmlschema-2/#built-in-datatypes\n\n        mapped from\n        https://docs.python.org/3/library/stdtypes.html\n\n        compare to\n        https://www.w3.org/2001/sw/rdb2rdf/directGraph/\n        http://www.bobdc.com/blog/json2rdf/\n        https://www.w3.org/TR/json-ld11-api/#data-round-tripping\n        https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python\n        \"\"\"\n        if limit is not None:\n            listOfDicts = listOfDicts[:limit]\n        else:\n            limit = len(listOfDicts)\n        total = len(listOfDicts)\n        if batchSize is None:\n            return self.insertListOfDictsBatch(\n                listOfDicts, entityType, primaryKey, prefixes, total=total\n            )\n        else:\n            startTime = time.time()\n            errors = []\n            # store the list in batches\n            for i in range(0, total, batchSize):\n                recordBatch = listOfDicts[i : i + batchSize]\n                batchErrors = self.insertListOfDictsBatch(\n                    recordBatch,\n                    entityType,\n                    primaryKey,\n                    prefixes,\n                    batchIndex=i,\n                    total=total,\n                    startTime=startTime,\n                )\n                errors.extend(batchErrors)\n            if self.profile:\n                print(\n                    \"insertListOfDicts for %9d records in %6.1f secs\"\n                    % (len(listOfDicts), time.time() - startTime),\n                    flush=True,\n                )\n            return errors\n\n    def insertListOfDictsBatch(\n        self,\n        listOfDicts,\n        entityType,\n        primaryKey,\n        prefixes,\n        title=\"batch\",\n        batchIndex=None,\n        total=None,\n        startTime=None,\n    ):\n        \"\"\"\n        insert a Batch part of listOfDicts\n\n        Args:\n            entityType(string): the entityType to use as a\n            primaryKey(string): the name of the primary key attribute to use\n            prefix(string): any PREFIX statements to be used\n            title(string): the title to display for the profiling (if any)\n            batchIndex(int): the start index of the current batch\n            total(int): the total number of records for all batches\n            starttime(datetime): the start of the batch processing\n\n        Return:\n            a list of errors which should be empty on full success\n        \"\"\"\n        errors = []\n        size = len(listOfDicts)\n        if batchIndex is None:\n            batchIndex = 0\n        batchStartTime = time.time()\n        if startTime is None:\n            startTime = batchStartTime\n        rdfprefix = \"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\\n\"\n        insertCommand = f\"{rdfprefix}{prefixes}\\nINSERT DATA {{\\n\"\n        for index, record in enumerate(listOfDicts):\n            if not primaryKey in record:\n                errors.append(f\"missing primary key {primaryKey} in record {index}\")\n            else:\n                primaryValue = record[primaryKey]\n                if primaryValue is None:\n                    errors.append(\n                        f\"primary key {primaryKey} value is None in record {index}\"\n                    )\n                else:\n                    encodedPrimaryValue = self.getLocalName(primaryValue)\n                    tSubject = f\"{entityType}__{encodedPrimaryValue}\"\n                    insertCommand += f'  {tSubject} rdf:type \"{entityType}\".\\n'\n                    for keyValue in record.items():\n                        key, value = keyValue\n                        # convert key if necessary\n                        key = self.getLocalName(key)\n                        valueType = type(value)\n                        if self.debug:\n                            print(\"%s(%s)=%s\" % (key, valueType, value))\n                        tPredicate = f\"{entityType}_{key}\"\n                        tObject = value\n                        if valueType == str:\n                            escapedString = self.controlEscape(value)\n                            tObject = '\"%s\"' % escapedString\n                        elif valueType == int:\n                            if self.typedLiterals:\n                                tObject = (\n                                    '\"%d\"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'\n                                    % value\n                                )\n                            pass\n                        elif valueType == float:\n                            if self.typedLiterals:\n                                tObject = (\n                                    '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;'\n                                    % value\n                                )\n                            pass\n                        elif valueType == bool:\n                            pass\n                        elif valueType == datetime.date:\n                            # if self.typedLiterals:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;' % value\n                            )\n                            pass\n                        elif valueType == datetime.datetime:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;'\n                                % value\n                            )\n                            pass\n                        else:\n                            errors.append(\n                                \"can't handle type %s in record %d\" % (valueType, index)\n                            )\n                            tObject = None\n                        if tObject is not None:\n                            insertRecord = \"  %s %s %s.\\n\" % (\n                                tSubject,\n                                tPredicate,\n                                tObject,\n                            )\n                            insertCommand += insertRecord\n        insertCommand += \"\\n}\"\n        if self.debug:\n            print(insertCommand, flush=True)\n        response, ex = self.insert(insertCommand)\n        if response is None and ex is not None:\n            errors.append(\"%s for record %d\" % (str(ex), index))\n        if self.profile:\n            print(\n                \"%7s for %9d - %9d of %9d %s in %6.1f s -&gt; %6.1f s\"\n                % (\n                    title,\n                    batchIndex + 1,\n                    batchIndex + size,\n                    total,\n                    entityType,\n                    time.time() - batchStartTime,\n                    time.time() - startTime,\n                ),\n                flush=True,\n            )\n        return errors\n\n    controlChars = [chr(c) for c in range(0x20)]\n\n    @staticmethod\n    def controlEscape(s):\n        \"\"\"\n        escape control characters\n\n        see https://stackoverflow.com/a/9778992/1497139\n        \"\"\"\n        escaped = \"\".join(\n            [\n                (\n                    c.encode(\"unicode_escape\").decode(\"ascii\")\n                    if c in SPARQL.controlChars\n                    else c\n                )\n                for c in s\n            ]\n        )\n        escaped = escaped.replace('\"', '\\\\\"')\n        return escaped\n\n    def query(self, queryString, method=POST):\n        \"\"\"\n        get a list of results for the given query\n\n        Args:\n            queryString(string): the SPARQL query to execute\n            method(string): the method eg. POST to use\n\n        Returns:\n            list: list of bindings\n        \"\"\"\n        queryResult = self.rawQuery(queryString, method=method)\n        if self.debug:\n            print(queryString)\n        if hasattr(queryResult, \"info\"):\n            if \"content-type\" in queryResult.info():\n                ct = queryResult.info()[\"content-type\"]\n                if \"text/html\" in ct:\n                    response = queryResult.response.read().decode()\n                    if not \"Success\" in response:\n                        raise (\"%s failed: %s\", response)\n                return None\n        jsonResult = queryResult.convert()\n        return self.getResults(jsonResult)\n\n    def queryAsListOfDicts(\n        self,\n        queryString,\n        fixNone: bool = False,\n        sampleCount: int = None,\n        param_dict: dict = None,\n    ):\n        \"\"\"\n        Get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)\n\n        Args:\n            queryString (str): the SPARQL query to execute\n            fixNone (bool): if True add None values for empty columns in Dict\n            sampleCount (int): the number of samples to check\n            param_dict (dict): dictionary of parameter names and values to be applied to the query\n\n        Returns:\n            list: a list of Dicts\n\n        Raises:\n            Exception: If the query requires parameters but they are not provided\n        \"\"\"\n        params = Params(queryString)\n        queryString = params.apply_parameters_with_check(param_dict)\n\n        records = self.query(queryString, method=self.method)\n        listOfDicts = self.asListOfDicts(\n            records, fixNone=fixNone, sampleCount=sampleCount\n        )\n        return listOfDicts\n\n    @staticmethod\n    def strToDatetime(value, debug=False):\n        \"\"\"\n        convert a string to a datetime\n        Args:\n            value(str): the value to convert\n        Returns:\n            datetime: the datetime\n        \"\"\"\n        dateFormat = \"%Y-%m-%d %H:%M:%S.%f\"\n        if \"T\" in value and \"Z\" in value:\n            dateFormat = \"%Y-%m-%dT%H:%M:%SZ\"\n        dt = None\n        try:\n            dt = datetime.datetime.strptime(value, dateFormat)\n        except ValueError as ve:\n            if debug:\n                print(str(ve))\n        return dt\n\n    def asListOfDicts(self, records, fixNone: bool = False, sampleCount: int = None):\n        \"\"\"\n        convert SPARQL result back to python native\n\n        Args:\n            record(list): the list of bindings\n            fixNone(bool): if True add None values for empty columns in Dict\n            sampleCount(int): the number of samples to check\n\n        Returns:\n            list: a list of Dicts\n        \"\"\"\n        resultList = []\n        fields = None\n        if fixNone:\n            fields = LOD.getFields(records, sampleCount)\n        for record in records:\n            resultDict = {}\n            for keyValue in record.items():\n                key, value = keyValue\n                datatype = value.datatype\n                if datatype is not None:\n                    if datatype == \"http://www.w3.org/2001/XMLSchema#integer\":\n                        resultValue = int(value.value)\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#decimal\":\n                        resultValue = float(value.value)\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#boolean\":\n                        resultValue = value.value in [\"TRUE\", \"true\"]\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#date\":\n                        dt = datetime.datetime.strptime(value.value, \"%Y-%m-%d\")\n                        resultValue = dt.date()\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#dateTime\":\n                        dt = SPARQL.strToDatetime(value.value, debug=self.debug)\n                        resultValue = dt\n                    else:\n                        # unsupported datatype\n                        resultValue = value.value\n                else:\n                    resultValue = value.value\n                resultDict[key] = resultValue\n            if fixNone:\n                for field in fields:\n                    if not field in resultDict:\n                        resultDict[field] = None\n            resultList.append(resultDict)\n        return resultList\n\n    def printErrors(self, errors):\n        \"\"\"\n        print the given list of errors\n\n        Args:\n            errors(list): a list of error strings\n\n        Returns:\n            boolean: True if the list is empty else false\n        \"\"\"\n        if len(errors) &gt; 0:\n            print(\"ERRORS:\")\n            for error in errors:\n                print(error, flush=True, file=stderr)\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.__init__","title":"<code>__init__(url, mode='query', debug=False, isFuseki=False, typedLiterals=False, profile=False, agent='PyLodStorage', method='POST', calls_per_minute=None)</code>","text":"<p>Construct a SPARQL wrapper</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>string</code> <p>the base URL of the endpoint - the mode query/update is going to be appended</p> required <code>mode</code> <code>string</code> <p>'query' or 'update'</p> <code>'query'</code> <code>debug</code> <code>bool</code> <p>True if debugging is to be activated</p> <code>False</code> <code>typedLiterals</code> <code>bool</code> <p>True if INSERT should be done with typedLiterals</p> <code>False</code> <code>profile</code> <code>boolean</code> <p>True if profiling / timing information should be displayed</p> <code>False</code> <code>agent</code> <code>string</code> <p>the User agent to use</p> <code>'PyLodStorage'</code> <code>method</code> <code>string</code> <p>the HTTP method to be used 'POST' or 'GET'</p> <code>'POST'</code> Source code in <code>lodstorage/sparql.py</code> <pre><code>def __init__(\n    self,\n    url,\n    mode=\"query\",\n    debug=False,\n    isFuseki=False,\n    typedLiterals=False,\n    profile=False,\n    agent=\"PyLodStorage\",\n    method=\"POST\",\n    calls_per_minute: int = None,\n):\n    \"\"\"\n    Construct a SPARQL wrapper\n\n    Args:\n        url (string): the base URL of the endpoint - the mode query/update is going to be appended\n        mode (string): 'query' or 'update'\n        debug (bool): True if debugging is to be activated\n        typedLiterals (bool): True if INSERT should be done with typedLiterals\n        profile (boolean): True if profiling / timing information should be displayed\n        agent (string): the User agent to use\n        method (string): the HTTP method to be used 'POST' or 'GET'\n    \"\"\"\n    if isFuseki:\n        self.url = f\"{url}/{mode}\"\n    else:\n        self.url = url\n    self.mode = mode\n    self.debug = debug\n    self.typedLiterals = typedLiterals\n    self.profile = profile\n    self.sparql = SPARQLWrapper2(url)\n    self.method = method\n    self.sparql.agent = agent\n    self.rate_limiter = RateLimiter(calls_per_minute=calls_per_minute)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.addAuthentication","title":"<code>addAuthentication(username, password, method='BASIC')</code>","text":"<p>Add Http Authentication credentials to the sparql wrapper Args:     username: name of the user     password: password of the user     method: HTTP Authentication method</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def addAuthentication(self, username: str, password: str, method: str = \"BASIC\"):\n    \"\"\"\n    Add Http Authentication credentials to the sparql wrapper\n    Args:\n        username: name of the user\n        password: password of the user\n        method: HTTP Authentication method\n    \"\"\"\n    if method:\n        self.sparql.setHTTPAuth(method)\n\n    if username and password:\n        self.sparql.setCredentials(username, password)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.asListOfDicts","title":"<code>asListOfDicts(records, fixNone=False, sampleCount=None)</code>","text":"<p>convert SPARQL result back to python native</p> <p>Parameters:</p> Name Type Description Default <code>record(list)</code> <p>the list of bindings</p> required <code>fixNone(bool)</code> <p>if True add None values for empty columns in Dict</p> required <code>sampleCount(int)</code> <p>the number of samples to check</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of Dicts</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def asListOfDicts(self, records, fixNone: bool = False, sampleCount: int = None):\n    \"\"\"\n    convert SPARQL result back to python native\n\n    Args:\n        record(list): the list of bindings\n        fixNone(bool): if True add None values for empty columns in Dict\n        sampleCount(int): the number of samples to check\n\n    Returns:\n        list: a list of Dicts\n    \"\"\"\n    resultList = []\n    fields = None\n    if fixNone:\n        fields = LOD.getFields(records, sampleCount)\n    for record in records:\n        resultDict = {}\n        for keyValue in record.items():\n            key, value = keyValue\n            datatype = value.datatype\n            if datatype is not None:\n                if datatype == \"http://www.w3.org/2001/XMLSchema#integer\":\n                    resultValue = int(value.value)\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#decimal\":\n                    resultValue = float(value.value)\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#boolean\":\n                    resultValue = value.value in [\"TRUE\", \"true\"]\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#date\":\n                    dt = datetime.datetime.strptime(value.value, \"%Y-%m-%d\")\n                    resultValue = dt.date()\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#dateTime\":\n                    dt = SPARQL.strToDatetime(value.value, debug=self.debug)\n                    resultValue = dt\n                else:\n                    # unsupported datatype\n                    resultValue = value.value\n            else:\n                resultValue = value.value\n            resultDict[key] = resultValue\n        if fixNone:\n            for field in fields:\n                if not field in resultDict:\n                    resultDict[field] = None\n        resultList.append(resultDict)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.controlEscape","title":"<code>controlEscape(s)</code>  <code>staticmethod</code>","text":"<p>escape control characters</p> <p>see https://stackoverflow.com/a/9778992/1497139</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>@staticmethod\ndef controlEscape(s):\n    \"\"\"\n    escape control characters\n\n    see https://stackoverflow.com/a/9778992/1497139\n    \"\"\"\n    escaped = \"\".join(\n        [\n            (\n                c.encode(\"unicode_escape\").decode(\"ascii\")\n                if c in SPARQL.controlChars\n                else c\n            )\n            for c in s\n        ]\n    )\n    escaped = escaped.replace('\"', '\\\\\"')\n    return escaped\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.fix_comments","title":"<code>fix_comments(query_string)</code>","text":"<p>make sure broken SPARQLWrapper will find comments</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def fix_comments(self, query_string: str) -&gt; str:\n    \"\"\"\n    make sure broken SPARQLWrapper will find comments\n    \"\"\"\n    if query_string is None:\n        return None\n    return \"#\\n\" + query_string\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.fromEndpointConf","title":"<code>fromEndpointConf(endpointConf)</code>  <code>classmethod</code>","text":"<p>create a SPARQL endpoint from the given EndpointConfiguration</p> <p>Parameters:</p> Name Type Description Default <code>endpointConf</code> <code>Endpoint</code> <p>the endpoint configuration to be used</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>@classmethod\ndef fromEndpointConf(cls, endpointConf) -&gt; \"SPARQL\":\n    \"\"\"\n    create a SPARQL endpoint from the given EndpointConfiguration\n\n    Args:\n        endpointConf (Endpoint): the endpoint configuration to be used\n    \"\"\"\n    if not endpointConf:\n        raise ValueError(\"endpointConf must be specified\")\n    sparql = SPARQL(\n        url=endpointConf.endpoint,\n        method=endpointConf.method,\n        calls_per_minute=endpointConf.calls_per_minute,\n    )\n    if hasattr(endpointConf, \"auth\"):\n        authMethod = None\n        if endpointConf.auth == \"BASIC\":\n            authMethod = \"BASIC\"\n        elif endpointConf.auth == \"DIGEST\":\n            authMethod = \"DIGEST\"\n        sparql.addAuthentication(\n            endpointConf.user, endpointConf.password, method=authMethod\n        )\n    return sparql\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getFirst","title":"<code>getFirst(qLod, attr)</code>","text":"<p>get the column attr of the first row of the given qLod list</p> <p>Parameters:</p> Name Type Description Default <code>qLod(list)</code> <p>the list of dicts (returned by a query)</p> required <code>attr(str)</code> <p>the attribute to retrieve</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>the value</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getFirst(self, qLod: list, attr: str):\n    \"\"\"\n    get the column attr of the first row of the given qLod list\n\n    Args:\n        qLod(list): the list of dicts (returned by a query)\n        attr(str): the attribute to retrieve\n\n    Returns:\n        object: the value\n    \"\"\"\n    if len(qLod) == 1 and attr in qLod[0]:\n        value = qLod[0][attr]\n        return value\n    raise Exception(f\"getFirst for attribute {attr} failed for {qLod}\")\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getLocalName","title":"<code>getLocalName(name)</code>","text":"<p>retrieve valid localname from a string based primary key https://www.w3.org/TR/sparql11-query/#prefNames</p> <p>Parameters:</p> Name Type Description Default <code>name(string)</code> <p>the name to convert</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>a valid local name</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getLocalName(self, name):\n    \"\"\"\n    retrieve valid localname from a string based primary key\n    https://www.w3.org/TR/sparql11-query/#prefNames\n\n    Args:\n        name(string): the name to convert\n\n    Returns:\n        string: a valid local name\n    \"\"\"\n    localName = \"\".join(ch for ch in name if ch.isalnum())\n    return localName\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getResults","title":"<code>getResults(jsonResult)</code>","text":"<p>get the result from the given jsonResult</p> <p>Parameters:</p> Name Type Description Default <code>jsonResult</code> <p>the JSON encoded result</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>the list of bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getResults(self, jsonResult):\n    \"\"\"\n    get the result from the given jsonResult\n\n    Args:\n        jsonResult: the JSON encoded result\n\n    Returns:\n        list: the list of bindings\n    \"\"\"\n    return jsonResult.bindings\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getValue","title":"<code>getValue(sparqlQuery, attr)</code>","text":"<p>get the value for the given SPARQL query using the given attr</p> <p>Parameters:</p> Name Type Description Default <code>sparql(SPARQL)</code> <p>the SPARQL endpoint to ge the value for</p> required <code>sparqlQuery(str)</code> <p>the SPARQL query to run</p> required <code>attr(str)</code> <p>the attribute to get</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>def getValue(self, sparqlQuery: str, attr: str):\n    \"\"\"\n    get the value for the given SPARQL query using the given attr\n\n    Args:\n        sparql(SPARQL): the SPARQL endpoint to ge the value for\n        sparqlQuery(str): the SPARQL query to run\n        attr(str): the attribute to get\n    \"\"\"\n    if self.debug:\n        print(sparqlQuery)\n    qLod = self.queryAsListOfDicts(sparqlQuery)\n    return self.getFirst(qLod, attr)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getValues","title":"<code>getValues(sparqlQuery, attrList)</code>","text":"<p>get Values for the given sparlQuery and attribute list</p> <p>Parameters:</p> Name Type Description Default <code>sparqlQuery(str)</code> <p>the query which did not return any values</p> required <code>attrList(list)</code> <p>the list of attributes</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>def getValues(self, sparqlQuery: str, attrList: list):\n    \"\"\"\n    get Values for the given sparlQuery and attribute list\n\n    Args:\n        sparqlQuery(str): the query which did not return any values\n        attrList(list): the list of attributes\n    \"\"\"\n    if self.debug:\n        print(sparqlQuery)\n    qLod = self.queryAsListOfDicts(sparqlQuery)\n    if not (len(qLod) == 1):\n        msg = f\"getValues for {attrList} failed for {qLod}\"\n        raise Exception(msg)\n    record = qLod[0]\n    values = ()\n    for attr in attrList:\n        if not attr in record:\n            msg = f\"getValues failed for attribute {attr} which is missing in result record {record}\"\n            raise Exception(msg)\n        recordTuple = (record[attr],)\n        values += recordTuple\n    return values\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insert","title":"<code>insert(insertCommand)</code>","text":"<p>run an insert</p> <p>Parameters:</p> Name Type Description Default <code>insertCommand(string)</code> <p>the SPARQL INSERT command</p> required <p>Returns:</p> Type Description <p>a response</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insert(self, insertCommand):\n    \"\"\"\n    run an insert\n\n    Args:\n        insertCommand(string): the SPARQL INSERT command\n\n    Returns:\n        a response\n    \"\"\"\n    self.sparql.setRequestMethod(POSTDIRECTLY)\n    response = None\n    exception = None\n    try:\n        response = self.rawQuery(insertCommand, method=POST)\n        # see https://github.com/RDFLib/sparqlwrapper/issues/159#issuecomment-674523696\n        # dummy read the body\n        response.response.read()\n    except Exception as ex:\n        exception = ex\n        if self.debug:\n            print(ex)\n    return response, exception\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insertListOfDicts","title":"<code>insertListOfDicts(listOfDicts, entityType, primaryKey, prefixes, limit=None, batchSize=None, profile=False)</code>","text":"<p>insert the given list of dicts mapping datatypes</p> <p>Parameters:</p> Name Type Description Default <code>entityType(string)</code> <p>the entityType to use as a</p> required <code>primaryKey(string)</code> <p>the name of the primary key attribute to use</p> required <code>prefix(string)</code> <p>any PREFIX statements to be used</p> required <code>limit(int)</code> <p>maximum number of records to insert</p> required <code>batchSize(int)</code> <p>number of records to send per request</p> required Return <p>a list of errors which should be empty on full success</p> <p>datatype maping according to https://www.w3.org/TR/xmlschema-2/#built-in-datatypes</p> <p>mapped from https://docs.python.org/3/library/stdtypes.html</p> <p>compare to https://www.w3.org/2001/sw/rdb2rdf/directGraph/ http://www.bobdc.com/blog/json2rdf/ https://www.w3.org/TR/json-ld11-api/#data-round-tripping https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insertListOfDicts(\n    self,\n    listOfDicts,\n    entityType,\n    primaryKey,\n    prefixes,\n    limit=None,\n    batchSize=None,\n    profile=False,\n):\n    \"\"\"\n    insert the given list of dicts mapping datatypes\n\n    Args:\n        entityType(string): the entityType to use as a\n        primaryKey(string): the name of the primary key attribute to use\n        prefix(string): any PREFIX statements to be used\n        limit(int): maximum number of records to insert\n        batchSize(int): number of records to send per request\n\n    Return:\n        a list of errors which should be empty on full success\n\n    datatype maping according to\n    https://www.w3.org/TR/xmlschema-2/#built-in-datatypes\n\n    mapped from\n    https://docs.python.org/3/library/stdtypes.html\n\n    compare to\n    https://www.w3.org/2001/sw/rdb2rdf/directGraph/\n    http://www.bobdc.com/blog/json2rdf/\n    https://www.w3.org/TR/json-ld11-api/#data-round-tripping\n    https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python\n    \"\"\"\n    if limit is not None:\n        listOfDicts = listOfDicts[:limit]\n    else:\n        limit = len(listOfDicts)\n    total = len(listOfDicts)\n    if batchSize is None:\n        return self.insertListOfDictsBatch(\n            listOfDicts, entityType, primaryKey, prefixes, total=total\n        )\n    else:\n        startTime = time.time()\n        errors = []\n        # store the list in batches\n        for i in range(0, total, batchSize):\n            recordBatch = listOfDicts[i : i + batchSize]\n            batchErrors = self.insertListOfDictsBatch(\n                recordBatch,\n                entityType,\n                primaryKey,\n                prefixes,\n                batchIndex=i,\n                total=total,\n                startTime=startTime,\n            )\n            errors.extend(batchErrors)\n        if self.profile:\n            print(\n                \"insertListOfDicts for %9d records in %6.1f secs\"\n                % (len(listOfDicts), time.time() - startTime),\n                flush=True,\n            )\n        return errors\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insertListOfDictsBatch","title":"<code>insertListOfDictsBatch(listOfDicts, entityType, primaryKey, prefixes, title='batch', batchIndex=None, total=None, startTime=None)</code>","text":"<p>insert a Batch part of listOfDicts</p> <p>Parameters:</p> Name Type Description Default <code>entityType(string)</code> <p>the entityType to use as a</p> required <code>primaryKey(string)</code> <p>the name of the primary key attribute to use</p> required <code>prefix(string)</code> <p>any PREFIX statements to be used</p> required <code>title(string)</code> <p>the title to display for the profiling (if any)</p> required <code>batchIndex(int)</code> <p>the start index of the current batch</p> required <code>total(int)</code> <p>the total number of records for all batches</p> required <code>starttime(datetime)</code> <p>the start of the batch processing</p> required Return <p>a list of errors which should be empty on full success</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insertListOfDictsBatch(\n    self,\n    listOfDicts,\n    entityType,\n    primaryKey,\n    prefixes,\n    title=\"batch\",\n    batchIndex=None,\n    total=None,\n    startTime=None,\n):\n    \"\"\"\n    insert a Batch part of listOfDicts\n\n    Args:\n        entityType(string): the entityType to use as a\n        primaryKey(string): the name of the primary key attribute to use\n        prefix(string): any PREFIX statements to be used\n        title(string): the title to display for the profiling (if any)\n        batchIndex(int): the start index of the current batch\n        total(int): the total number of records for all batches\n        starttime(datetime): the start of the batch processing\n\n    Return:\n        a list of errors which should be empty on full success\n    \"\"\"\n    errors = []\n    size = len(listOfDicts)\n    if batchIndex is None:\n        batchIndex = 0\n    batchStartTime = time.time()\n    if startTime is None:\n        startTime = batchStartTime\n    rdfprefix = \"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\\n\"\n    insertCommand = f\"{rdfprefix}{prefixes}\\nINSERT DATA {{\\n\"\n    for index, record in enumerate(listOfDicts):\n        if not primaryKey in record:\n            errors.append(f\"missing primary key {primaryKey} in record {index}\")\n        else:\n            primaryValue = record[primaryKey]\n            if primaryValue is None:\n                errors.append(\n                    f\"primary key {primaryKey} value is None in record {index}\"\n                )\n            else:\n                encodedPrimaryValue = self.getLocalName(primaryValue)\n                tSubject = f\"{entityType}__{encodedPrimaryValue}\"\n                insertCommand += f'  {tSubject} rdf:type \"{entityType}\".\\n'\n                for keyValue in record.items():\n                    key, value = keyValue\n                    # convert key if necessary\n                    key = self.getLocalName(key)\n                    valueType = type(value)\n                    if self.debug:\n                        print(\"%s(%s)=%s\" % (key, valueType, value))\n                    tPredicate = f\"{entityType}_{key}\"\n                    tObject = value\n                    if valueType == str:\n                        escapedString = self.controlEscape(value)\n                        tObject = '\"%s\"' % escapedString\n                    elif valueType == int:\n                        if self.typedLiterals:\n                            tObject = (\n                                '\"%d\"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'\n                                % value\n                            )\n                        pass\n                    elif valueType == float:\n                        if self.typedLiterals:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;'\n                                % value\n                            )\n                        pass\n                    elif valueType == bool:\n                        pass\n                    elif valueType == datetime.date:\n                        # if self.typedLiterals:\n                        tObject = (\n                            '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;' % value\n                        )\n                        pass\n                    elif valueType == datetime.datetime:\n                        tObject = (\n                            '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;'\n                            % value\n                        )\n                        pass\n                    else:\n                        errors.append(\n                            \"can't handle type %s in record %d\" % (valueType, index)\n                        )\n                        tObject = None\n                    if tObject is not None:\n                        insertRecord = \"  %s %s %s.\\n\" % (\n                            tSubject,\n                            tPredicate,\n                            tObject,\n                        )\n                        insertCommand += insertRecord\n    insertCommand += \"\\n}\"\n    if self.debug:\n        print(insertCommand, flush=True)\n    response, ex = self.insert(insertCommand)\n    if response is None and ex is not None:\n        errors.append(\"%s for record %d\" % (str(ex), index))\n    if self.profile:\n        print(\n            \"%7s for %9d - %9d of %9d %s in %6.1f s -&gt; %6.1f s\"\n            % (\n                title,\n                batchIndex + 1,\n                batchIndex + size,\n                total,\n                entityType,\n                time.time() - batchStartTime,\n                time.time() - startTime,\n            ),\n            flush=True,\n        )\n    return errors\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.post_query_direct","title":"<code>post_query_direct(query, rdf_format='n3', timeout=60)</code>","text":"<p>Fetch raw RDF response via direct HTTP POST.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SPARQL CONSTRUCT query</p> required <code>rdf_format</code> <code>str</code> <p>RDF format label (e.g. 'turtle', 'rdf-xml', 'json-ld', 'n3')</p> <code>'n3'</code> <code>timeout</code> <code>int</code> <p>timeout in seconds (default: 60)</p> <code>60</code> <p>Returns:</p> Type Description <code>str</code> <p>Raw RDF content as string</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def post_query_direct(\n    self, query: str, rdf_format: str = \"n3\", timeout: int = 60\n) -&gt; str:\n    \"\"\"\n    Fetch raw RDF response via direct HTTP POST.\n\n    Args:\n        query: SPARQL CONSTRUCT query\n        rdf_format: RDF format label (e.g. 'turtle', 'rdf-xml', 'json-ld', 'n3')\n        timeout: timeout in seconds (default: 60)\n\n    Returns:\n        Raw RDF content as string\n\n    Raises:\n        Exception if HTTP request fails\n    \"\"\"\n    rdf_format = RdfFormat.by_label(rdf_format)\n    mime_type = rdf_format.mime_type\n    headers = {\"Accept\": mime_type}\n    response = requests.post(\n        self.url,\n        data={\"query\": query},\n        headers=headers,\n        timeout=timeout,\n    )\n    if response.status_code != 200:\n        msg = f\"HTTP {response.status_code}: {response.text}\"\n        raise Exception(msg)\n    text = response.text.strip()\n    return text\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.printErrors","title":"<code>printErrors(errors)</code>","text":"<p>print the given list of errors</p> <p>Parameters:</p> Name Type Description Default <code>errors(list)</code> <p>a list of error strings</p> required <p>Returns:</p> Name Type Description <code>boolean</code> <p>True if the list is empty else false</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def printErrors(self, errors):\n    \"\"\"\n    print the given list of errors\n\n    Args:\n        errors(list): a list of error strings\n\n    Returns:\n        boolean: True if the list is empty else false\n    \"\"\"\n    if len(errors) &gt; 0:\n        print(\"ERRORS:\")\n        for error in errors:\n            print(error, flush=True, file=stderr)\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.query","title":"<code>query(queryString, method=POST)</code>","text":"<p>get a list of results for the given query</p> <p>Parameters:</p> Name Type Description Default <code>queryString(string)</code> <p>the SPARQL query to execute</p> required <code>method(string)</code> <p>the method eg. POST to use</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def query(self, queryString, method=POST):\n    \"\"\"\n    get a list of results for the given query\n\n    Args:\n        queryString(string): the SPARQL query to execute\n        method(string): the method eg. POST to use\n\n    Returns:\n        list: list of bindings\n    \"\"\"\n    queryResult = self.rawQuery(queryString, method=method)\n    if self.debug:\n        print(queryString)\n    if hasattr(queryResult, \"info\"):\n        if \"content-type\" in queryResult.info():\n            ct = queryResult.info()[\"content-type\"]\n            if \"text/html\" in ct:\n                response = queryResult.response.read().decode()\n                if not \"Success\" in response:\n                    raise (\"%s failed: %s\", response)\n            return None\n    jsonResult = queryResult.convert()\n    return self.getResults(jsonResult)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.queryAsListOfDicts","title":"<code>queryAsListOfDicts(queryString, fixNone=False, sampleCount=None, param_dict=None)</code>","text":"<p>Get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)</p> <p>Parameters:</p> Name Type Description Default <code>queryString</code> <code>str</code> <p>the SPARQL query to execute</p> required <code>fixNone</code> <code>bool</code> <p>if True add None values for empty columns in Dict</p> <code>False</code> <code>sampleCount</code> <code>int</code> <p>the number of samples to check</p> <code>None</code> <code>param_dict</code> <code>dict</code> <p>dictionary of parameter names and values to be applied to the query</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>a list of Dicts</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the query requires parameters but they are not provided</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def queryAsListOfDicts(\n    self,\n    queryString,\n    fixNone: bool = False,\n    sampleCount: int = None,\n    param_dict: dict = None,\n):\n    \"\"\"\n    Get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)\n\n    Args:\n        queryString (str): the SPARQL query to execute\n        fixNone (bool): if True add None values for empty columns in Dict\n        sampleCount (int): the number of samples to check\n        param_dict (dict): dictionary of parameter names and values to be applied to the query\n\n    Returns:\n        list: a list of Dicts\n\n    Raises:\n        Exception: If the query requires parameters but they are not provided\n    \"\"\"\n    params = Params(queryString)\n    queryString = params.apply_parameters_with_check(param_dict)\n\n    records = self.query(queryString, method=self.method)\n    listOfDicts = self.asListOfDicts(\n        records, fixNone=fixNone, sampleCount=sampleCount\n    )\n    return listOfDicts\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.rawQuery","title":"<code>rawQuery(queryString, method=POST)</code>","text":"<p>query with the given query string</p> <p>Parameters:</p> Name Type Description Default <code>queryString(str)</code> <p>the SPARQL query to be performed</p> required <code>method(str)</code> <p>POST or GET - POST is mandatory for update queries</p> required <p>Returns:     list: the raw query result as bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def rawQuery(self, queryString: str, method=POST):\n    \"\"\"\n    query with the given query string\n\n    Args:\n        queryString(str): the SPARQL query to be performed\n        method(str): POST or GET - POST is mandatory for update queries\n    Returns:\n        list: the raw query result as bindings\n    \"\"\"\n    queryString = self.fix_comments(queryString)\n    self.sparql.setQuery(queryString)\n    self.sparql.method = method\n    bindings = self.sparql.query()\n    return bindings\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.strToDatetime","title":"<code>strToDatetime(value, debug=False)</code>  <code>staticmethod</code>","text":"<p>convert a string to a datetime Args:     value(str): the value to convert Returns:     datetime: the datetime</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>@staticmethod\ndef strToDatetime(value, debug=False):\n    \"\"\"\n    convert a string to a datetime\n    Args:\n        value(str): the value to convert\n    Returns:\n        datetime: the datetime\n    \"\"\"\n    dateFormat = \"%Y-%m-%d %H:%M:%S.%f\"\n    if \"T\" in value and \"Z\" in value:\n        dateFormat = \"%Y-%m-%dT%H:%M:%SZ\"\n    dt = None\n    try:\n        dt = datetime.datetime.strptime(value, dateFormat)\n    except ValueError as ve:\n        if debug:\n            print(str(ve))\n    return dt\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.test_query","title":"<code>test_query(query='SELECT * WHERE { ?s ?p ?o } LIMIT 1', expected_bindings=1)</code>","text":"<p>Check if the SPARQL endpoint is available using a standard SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>the SPARQL query to use for testing</p> <code>'SELECT * WHERE { ?s ?p ?o } LIMIT 1'</code> <p>Returns:</p> Type Description <code>Exception</code> <p>Exception if the endpoint fails</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def test_query(\n    self,\n    query: str = \"SELECT * WHERE { ?s ?p ?o } LIMIT 1\",\n    expected_bindings: int = 1,\n) -&gt; Exception:\n    \"\"\"\n    Check if the SPARQL endpoint is available using a standard SPARQL query.\n\n    Args:\n        query (str): the SPARQL query to use for testing\n\n    Returns:\n        Exception if the endpoint fails\n    \"\"\"\n    result = None\n    try:\n        query_result = self.rawQuery(query, method=self.method)\n        bindings = query_result.bindings\n        if not len(bindings) == expected_bindings:\n            raise Exception(\n                f\"SPARQL query {query} returned {len(bindings)} bindings instead of {expected_bindings}\"\n            )\n    except Exception as ex:\n        result = ex\n    return result\n</code></pre>"},{"location":"#lodstorage.sql","title":"<code>sql</code>","text":"<p>Created on 2020-08-24</p> <p>@author: wf</p>"},{"location":"#lodstorage.sql.EntityInfo","title":"<code>EntityInfo</code>","text":"<p>               Bases: <code>object</code></p> <p>holds entity meta Info</p> <p>:ivar name(string): entity name = table name</p> <p>:ivar primaryKey(string): the name of the primary key column</p> <p>:ivar typeMap(dict): maps column names to python types</p> <p>:ivar debug(boolean): True if debug information should be shown</p> Source code in <code>lodstorage/sql.py</code> <pre><code>class EntityInfo(object):\n    \"\"\"\n    holds entity meta Info\n\n    :ivar name(string): entity name = table name\n\n    :ivar primaryKey(string): the name of the primary key column\n\n    :ivar typeMap(dict): maps column names to python types\n\n    :ivar debug(boolean): True if debug information should be shown\n\n    \"\"\"\n\n    def __init__(self, sampleRecords, name, primaryKey=None, quiet=False, debug=False):\n        \"\"\"\n        construct me from the given name and primary key\n\n        Args:\n           sampleRecords:a list of sample record dicts\n           name(string): the name of the entity\n           primaryKey(string): the name of the primary key column\n           quite(boolean): if True suppress all print messages\n           debug(boolean): True if debug information should be shown\n        \"\"\"\n        self.sampleRecords = sampleRecords\n        self.name = name\n        self.primaryKey = primaryKey\n        self.quiet = quiet\n        self.debug = debug\n        self.typeMap = {}\n        self.sqlTypeMap = {}\n        self.createTableCmd = self.getCreateTableCmd(sampleRecords)\n        self.dropTableCmd = \"DROP TABLE IF EXISTS %s\" % self.name\n        self.insertCmd = self.getInsertCmd()\n\n    def getCreateTableCmd(self, sampleRecords):\n        \"\"\"\n        get the CREATE TABLE DDL command for the given sample records\n\n        Args:\n            sampleRecords(list): a list of Dicts of sample Records\n\n        Returns:\n            string: CREATE TABLE DDL command for this entity info\n\n        Example:\n\n        .. code-block:: sql\n\n            CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n\n        \"\"\"\n        ddlCmd = \"CREATE TABLE %s(\" % self.name\n        delim = \"\"\n        for sampleRecord in sampleRecords:\n            for key, value in sampleRecord.items():\n                sqlType = None\n                valueType = None\n                if value is None:\n                    if len(sampleRecords) == 1:\n                        msg = f\"Warning sampleRecord column {key} is None - using TEXT as type\"\n                        if not self.quiet:\n                            print(msg)\n                        valueType = str\n                else:\n                    valueType = type(value)\n                if valueType == str:\n                    sqlType = \"TEXT\"\n                elif valueType == int:\n                    sqlType = \"INTEGER\"\n                elif valueType == float:\n                    sqlType = \"FLOAT\"\n                elif valueType == bool:\n                    sqlType = \"BOOLEAN\"\n                elif valueType == datetime.date:\n                    sqlType = \"DATE\"\n                elif valueType == datetime.datetime:\n                    sqlType = \"TIMESTAMP\"\n                else:\n                    msg = f\"warning: unsupported type {valueType} for column {key}\"\n                    if not self.quiet:\n                        print(msg)\n                if sqlType is not None and valueType is not None:\n                    self.addType(key, valueType, sqlType)\n        for key, sqlType in self.sqlTypeMap.items():\n            is_primary = \" PRIMARY KEY\" if key == self.primaryKey else \"\"\n            ddl_col = f\"{delim}{key} {sqlType}{is_primary}\"\n            ddlCmd += ddl_col\n            delim = \",\"\n        ddlCmd += \")\"\n        if self.debug and not self.quiet:\n            print(ddlCmd)\n        return ddlCmd\n\n    def getInsertCmd(self, replace: bool = False) -&gt; str:\n        \"\"\"\n        get the INSERT command for this entityInfo\n\n        Args:\n             replace(bool): if True allow replace for insert\n\n        Returns:\n            str: the INSERT INTO SQL command for his entityInfo e.g.\n\n        Example:\n\n        .. code-block:: sql\n\n            INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n\n        \"\"\"\n        columns = \",\".join(self.typeMap.keys())\n        placeholders = \":\" + \",:\".join(self.typeMap.keys())\n        replaceClause = \" OR REPLACE\" if replace else \"\"\n        insertCmd = f\"INSERT{replaceClause} INTO {self.name} ({columns}) values ({placeholders})\"\n        if self.debug and not self.quiet:\n            print(insertCmd)\n        return insertCmd\n\n    def addType(self, column, valueType, sqlType):\n        \"\"\"\n        add the python type for the given column to the typeMap\n\n        Args:\n           column(string): the name of the column\n\n           valueType(type): the python type of the column\n        \"\"\"\n        if not column in self.typeMap:\n            self.typeMap[column] = valueType\n            self.sqlTypeMap[column] = sqlType\n\n    def fixDates(self, resultList):\n        \"\"\"\n        fix date entries in the given resultList by parsing the date content e.g.\n        converting '1926-04-21' back to datetime.date(1926, 4, 21)\n\n        Args:\n            resultList(list): the list of records to be fixed\n        \"\"\"\n        for record in resultList:\n            for key, valueType in self.typeMap.items():\n                if valueType == datetime.date:\n                    dt = datetime.datetime.strptime(record[key], \"%Y-%m-%d\")\n                    dateValue = dt.date()\n                    record[key] = dateValue\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.__init__","title":"<code>__init__(sampleRecords, name, primaryKey=None, quiet=False, debug=False)</code>","text":"<p>construct me from the given name and primary key</p> <p>Parameters:</p> Name Type Description Default <code>sampleRecords</code> <p>a list of sample record dicts</p> required <code>name(string)</code> <p>the name of the entity</p> required <code>primaryKey(string)</code> <p>the name of the primary key column</p> required <code>quite(boolean)</code> <p>if True suppress all print messages</p> required <code>debug(boolean)</code> <p>True if debug information should be shown</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def __init__(self, sampleRecords, name, primaryKey=None, quiet=False, debug=False):\n    \"\"\"\n    construct me from the given name and primary key\n\n    Args:\n       sampleRecords:a list of sample record dicts\n       name(string): the name of the entity\n       primaryKey(string): the name of the primary key column\n       quite(boolean): if True suppress all print messages\n       debug(boolean): True if debug information should be shown\n    \"\"\"\n    self.sampleRecords = sampleRecords\n    self.name = name\n    self.primaryKey = primaryKey\n    self.quiet = quiet\n    self.debug = debug\n    self.typeMap = {}\n    self.sqlTypeMap = {}\n    self.createTableCmd = self.getCreateTableCmd(sampleRecords)\n    self.dropTableCmd = \"DROP TABLE IF EXISTS %s\" % self.name\n    self.insertCmd = self.getInsertCmd()\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.addType","title":"<code>addType(column, valueType, sqlType)</code>","text":"<p>add the python type for the given column to the typeMap</p> <p>Parameters:</p> Name Type Description Default <code>column(string)</code> <p>the name of the column</p> required <code>valueType(type)</code> <p>the python type of the column</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def addType(self, column, valueType, sqlType):\n    \"\"\"\n    add the python type for the given column to the typeMap\n\n    Args:\n       column(string): the name of the column\n\n       valueType(type): the python type of the column\n    \"\"\"\n    if not column in self.typeMap:\n        self.typeMap[column] = valueType\n        self.sqlTypeMap[column] = sqlType\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.fixDates","title":"<code>fixDates(resultList)</code>","text":"<p>fix date entries in the given resultList by parsing the date content e.g. converting '1926-04-21' back to datetime.date(1926, 4, 21)</p> <p>Parameters:</p> Name Type Description Default <code>resultList(list)</code> <p>the list of records to be fixed</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def fixDates(self, resultList):\n    \"\"\"\n    fix date entries in the given resultList by parsing the date content e.g.\n    converting '1926-04-21' back to datetime.date(1926, 4, 21)\n\n    Args:\n        resultList(list): the list of records to be fixed\n    \"\"\"\n    for record in resultList:\n        for key, valueType in self.typeMap.items():\n            if valueType == datetime.date:\n                dt = datetime.datetime.strptime(record[key], \"%Y-%m-%d\")\n                dateValue = dt.date()\n                record[key] = dateValue\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.getCreateTableCmd","title":"<code>getCreateTableCmd(sampleRecords)</code>","text":"<p>get the CREATE TABLE DDL command for the given sample records</p> <p>Parameters:</p> Name Type Description Default <code>sampleRecords(list)</code> <p>a list of Dicts of sample Records</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>CREATE TABLE DDL command for this entity info</p> <p>Example:</p> <p>.. code-block:: sql</p> <pre><code>CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n</code></pre> Source code in <code>lodstorage/sql.py</code> <pre><code>def getCreateTableCmd(self, sampleRecords):\n    \"\"\"\n    get the CREATE TABLE DDL command for the given sample records\n\n    Args:\n        sampleRecords(list): a list of Dicts of sample Records\n\n    Returns:\n        string: CREATE TABLE DDL command for this entity info\n\n    Example:\n\n    .. code-block:: sql\n\n        CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n\n    \"\"\"\n    ddlCmd = \"CREATE TABLE %s(\" % self.name\n    delim = \"\"\n    for sampleRecord in sampleRecords:\n        for key, value in sampleRecord.items():\n            sqlType = None\n            valueType = None\n            if value is None:\n                if len(sampleRecords) == 1:\n                    msg = f\"Warning sampleRecord column {key} is None - using TEXT as type\"\n                    if not self.quiet:\n                        print(msg)\n                    valueType = str\n            else:\n                valueType = type(value)\n            if valueType == str:\n                sqlType = \"TEXT\"\n            elif valueType == int:\n                sqlType = \"INTEGER\"\n            elif valueType == float:\n                sqlType = \"FLOAT\"\n            elif valueType == bool:\n                sqlType = \"BOOLEAN\"\n            elif valueType == datetime.date:\n                sqlType = \"DATE\"\n            elif valueType == datetime.datetime:\n                sqlType = \"TIMESTAMP\"\n            else:\n                msg = f\"warning: unsupported type {valueType} for column {key}\"\n                if not self.quiet:\n                    print(msg)\n            if sqlType is not None and valueType is not None:\n                self.addType(key, valueType, sqlType)\n    for key, sqlType in self.sqlTypeMap.items():\n        is_primary = \" PRIMARY KEY\" if key == self.primaryKey else \"\"\n        ddl_col = f\"{delim}{key} {sqlType}{is_primary}\"\n        ddlCmd += ddl_col\n        delim = \",\"\n    ddlCmd += \")\"\n    if self.debug and not self.quiet:\n        print(ddlCmd)\n    return ddlCmd\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.getInsertCmd","title":"<code>getInsertCmd(replace=False)</code>","text":"<p>get the INSERT command for this entityInfo</p> <p>Parameters:</p> Name Type Description Default <code>replace(bool)</code> <p>if True allow replace for insert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the INSERT INTO SQL command for his entityInfo e.g.</p> <p>Example:</p> <p>.. code-block:: sql</p> <pre><code>INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n</code></pre> Source code in <code>lodstorage/sql.py</code> <pre><code>def getInsertCmd(self, replace: bool = False) -&gt; str:\n    \"\"\"\n    get the INSERT command for this entityInfo\n\n    Args:\n         replace(bool): if True allow replace for insert\n\n    Returns:\n        str: the INSERT INTO SQL command for his entityInfo e.g.\n\n    Example:\n\n    .. code-block:: sql\n\n        INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n\n    \"\"\"\n    columns = \",\".join(self.typeMap.keys())\n    placeholders = \":\" + \",:\".join(self.typeMap.keys())\n    replaceClause = \" OR REPLACE\" if replace else \"\"\n    insertCmd = f\"INSERT{replaceClause} INTO {self.name} ({columns}) values ({placeholders})\"\n    if self.debug and not self.quiet:\n        print(insertCmd)\n    return insertCmd\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB","title":"<code>SQLDB</code>","text":"<p>               Bases: <code>object</code></p> <p>Structured Query Language Database wrapper</p> <p>:ivar dbname(string): name of the database :ivar debug(boolean): True if debug info should be provided :ivar errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> Source code in <code>lodstorage/sql.py</code> <pre><code>class SQLDB(object):\n    \"\"\"\n    Structured Query Language Database wrapper\n\n    :ivar dbname(string): name of the database\n    :ivar debug(boolean): True if debug info should be provided\n    :ivar errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n\n    RAM = \":memory:\"\n\n    def __init__(\n        self,\n        dbname: str = \":memory:\",\n        connection=None,\n        check_same_thread=True,\n        timeout=5,\n        debug=False,\n        errorDebug=False,\n    ):\n        \"\"\"\n        Construct me for the given dbname and debug\n\n        Args:\n\n           dbname(string): name of the database - default is a RAM based database\n           connection(Connection): an optional connection to be reused\n           check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139\n           timeout(float): number of seconds for connection timeout\n           debug(boolean): if True switch on debug\n           errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n        \"\"\"\n        self.dbname = dbname\n        self.debug = debug\n        self.errorDebug = errorDebug\n        SQLiteApiFixer.install(lenient=debug)\n        if connection is None:\n            self.c = sqlite3.connect(\n                dbname,\n                detect_types=sqlite3.PARSE_DECLTYPES,\n                check_same_thread=check_same_thread,\n                timeout=timeout,\n            )\n        else:\n            self.c = connection\n\n    def logError(self, msg):\n        \"\"\"\n        log the given error message to stderr\n\n        Args:\n            msg(str): the error messsage to display\n        \"\"\"\n        print(msg, file=sys.stderr, flush=True)\n\n    def close(self):\n        \"\"\"close my connection\"\"\"\n        self.c.close()\n\n    def execute(self, ddlCmd):\n        \"\"\"\n        execute the given Data Definition Command\n\n        Args:\n            ddlCmd(string): e.g. a CREATE TABLE or CREATE View command\n        \"\"\"\n        self.c.execute(ddlCmd)\n\n    def createTable4EntityInfo(self, entityInfo, withDrop=False, withCreate=True):\n        \"\"\"\n        Create a table based on the provided EntityInfo.\n\n        Args:\n            entityInfo (EntityInfo): The EntityInfo object containing table metadata.\n            withDrop (bool): If True, drop the existing table before creation.\n            withCreate (bool): If True, execute the CREATE TABLE command.\n\n        Returns:\n            EntityInfo: The provided EntityInfo object.\n        \"\"\"\n        if withDrop:\n            self.c.execute(entityInfo.dropTableCmd)\n        if withCreate:\n            try:\n                self.c.execute(entityInfo.createTableCmd)\n            except sqlite3.OperationalError as oe:\n                raise Exception(\n                    f\"createTable failed with error {oe} for {entityInfo.createTableCmd}\"\n                )\n        return entityInfo\n\n    def createTable(\n        self,\n        listOfRecords,\n        entityName: str,\n        primaryKey: str = None,\n        withCreate: bool = True,\n        withDrop: bool = False,\n        sampleRecordCount=1,\n        failIfTooFew=True,\n    ):\n        \"\"\"\n        Derive Data Definition Language CREATE TABLE command from list of Records by examining first record\n        as defining sample record and execute DDL command.\n\n        Args:\n            listOfRecords (list): A list of Dicts.\n            entityName (str): The entity / table name to use.\n            primaryKey (str): The key/column to use as a primary key.\n            withDrop (bool): True if the existing Table should be dropped.\n            withCreate (bool): True if the create Table command should be executed.\n            sampleRecordCount (int): Number of sample records expected and to be inspected.\n            failIfTooFew (bool): Raise an Exception if too few sample records, else warn only.\n\n        Returns:\n            EntityInfo: Meta data information for the created table.\n        \"\"\"\n        l = len(listOfRecords)\n        if sampleRecordCount &lt; 0:\n            sampleRecordCount = l\n        if l &lt; sampleRecordCount:\n            msg = f\"only {l}/{sampleRecordCount} of needed sample records to createTable available\"\n            if failIfTooFew:\n                raise Exception(msg)\n            elif self.debug:\n                self.logError(msg)\n\n        sampleRecords = listOfRecords[:sampleRecordCount]\n        entityInfo = EntityInfo(sampleRecords, entityName, primaryKey, debug=self.debug)\n\n        return self.createTable4EntityInfo(entityInfo, withDrop, withCreate)\n\n    def getDebugInfo(self, record, index, executeMany):\n        \"\"\"\n        get the debug info for the given record at the given index depending on the state of executeMany\n\n        Args:\n            record(dict): the record to show\n            index(int): the index of the record\n            executeMany(boolean): if True the record may be valid else not\n        \"\"\"\n        debugInfo = \"\"\n        if not executeMany:\n            # shall we shoe the details of the record (which might be a security risk)\n            if self.errorDebug:\n                # show details of record\n                debugInfo = \"\\nrecord  #%d=%s\" % (index, repr(record))\n            else:\n                # show only index\n                debugInfo = \"\\nrecord #%d\" % index\n        return debugInfo\n\n    def store(\n        self, listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False\n    ):\n        \"\"\"\n        store the given list of records based on the given entityInfo\n\n        Args:\n\n           listOfRecords(list): the list of Dicts to be stored\n           entityInfo(EntityInfo): the meta data to be used for storing\n           executeMany(bool): if True the insert command is done with many/all records at once\n           fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values\n           replace(bool): if True allow replace for insert\n        \"\"\"\n        insertCmd = entityInfo.getInsertCmd(replace=replace)\n        record = None\n        index = 0\n        try:\n            if executeMany:\n                if fixNone:\n                    LOD.setNone4List(listOfRecords, entityInfo.typeMap.keys())\n                self.c.executemany(insertCmd, listOfRecords)\n            else:\n                for record in listOfRecords:\n                    index += 1\n                    if fixNone:\n                        LOD.setNone(record, entityInfo.typeMap.keys())\n                    self.c.execute(insertCmd, record)\n            self.c.commit()\n        except sqlite3.ProgrammingError as pe:\n            msg = pe.args[0]\n            if \"You did not supply a value for binding\" in msg:\n                if \":\" in msg:\n                    # sqlite now returns the parameter name not the number\n                    # You did not supply a value for binding parameter :type.\n                    columnName = re.findall(r\":([a-zA-Z][a-zA-Z0-9_]*)\", msg)[0]\n                    columnName = columnName.replace(\":\", \"\")\n                else:\n                    # pre python 3.10\n                    # You did not supply a value for binding 2.\n                    columnIndex = int(re.findall(r\"\\d+\", msg)[0])\n                    columnName = list(entityInfo.typeMap.keys())[columnIndex - 1]\n                debugInfo = self.getDebugInfo(record, index, executeMany)\n                raise Exception(\n                    \"%s\\nfailed: no value supplied for column '%s'%s\"\n                    % (insertCmd, columnName, debugInfo)\n                )\n            else:\n                raise pe\n        except sqlite3.InterfaceError as ie:\n            msg = ie.args[0]\n            if \"Error binding parameter\" in msg:\n                columnName = re.findall(r\":[_a-zA-Z]\\w*\", msg)[0]\n                debugInfo = self.getDebugInfo(record, index, executeMany)\n                raise Exception(\n                    \"%s\\nfailed: error binding column '%s'%s\"\n                    % (insertCmd, columnName, debugInfo)\n                )\n            else:\n                raise ie\n        except Exception as ex:\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            msg = \"%s\\nfailed:%s%s\" % (insertCmd, str(ex), debugInfo)\n            raise Exception(msg)\n\n    def queryGen(self, sqlQuery, params=None):\n        \"\"\"\n        run the given sqlQuery a a generator for dicts\n\n        Args:\n\n            sqlQuery(string): the SQL query to be executed\n            params(tuple): the query params, if any\n\n        Returns:\n            a generator of dicts\n        \"\"\"\n        if self.debug:\n            print(sqlQuery)\n            if params is not None:\n                print(params)\n        # https://stackoverflow.com/a/13735506/1497139\n        cur = self.c.cursor()\n        if params is not None:\n            query = cur.execute(sqlQuery, params)\n        else:\n            query = cur.execute(sqlQuery)\n        colname = [d[0] for d in query.description]\n        try:\n            # loop over all rows\n            for row in query:\n                record = dict(zip(colname, row))\n                yield record\n        except Exception as ex:\n            msg = str(ex)\n            self.logError(msg)\n            pass\n        cur.close()\n\n    def query(self, sqlQuery, params=None):\n        \"\"\"\n        run the given sqlQuery and return a list of Dicts\n\n        Args:\n\n            sqlQuery(string): the SQL query to be executed\n            params(tuple): the query params, if any\n\n        Returns:\n            list: a list of Dicts\n        \"\"\"\n        resultList = []\n        for record in self.queryGen(sqlQuery, params):\n            resultList.append(record)\n        return resultList\n\n    def queryAll(self, entityInfo, fixDates=True):\n        \"\"\"\n        query all records for the given entityName/tableName\n\n        Args:\n           entityName(string): name of the entity/table to qury\n           fixDates(boolean): True if date entries should be returned as such and not as strings\n        \"\"\"\n        sqlQuery = \"SELECT * FROM %s\" % entityInfo.name\n        resultList = self.query(sqlQuery)\n        if fixDates:\n            entityInfo.fixDates(resultList)\n        return resultList\n\n    def getTableList(self, tableType=\"table\"):\n        \"\"\"\n        get the schema information from this database\n\n        Args:\n            tableType(str): table or view\n\n        Return:\n            list: a list as derived from PRAGMA table_info\n        \"\"\"\n        tableQuery = f\"SELECT name FROM sqlite_master WHERE type='{tableType}'\"\n        tableList = self.query(tableQuery)\n        for table in tableList:\n            tableName = table[\"name\"]\n            columnQuery = f\"PRAGMA table_info('{tableName}')\"\n            columns = self.query(columnQuery)\n            table[\"columns\"] = columns\n        return tableList\n\n    def getTableDict(self, tableType=\"table\"):\n        \"\"\"\n        get the schema information from this database as a dict\n\n        Args:\n            tableType(str): table or view\n\n        Returns:\n            dict: Lookup map of tables with columns also being converted to dict\n        \"\"\"\n        tableDict = {}\n        for table in self.getTableList(tableType=tableType):\n            colDict = {}\n            for col in table[\"columns\"]:\n                colDict[col[\"name\"]] = col\n            table[\"columns\"] = colDict\n            tableDict[table[\"name\"]] = table\n        return tableDict\n\n    def restoreProgress(self, status, remaining, total):\n        self.progress(\"Restore\", status, remaining, total)\n\n    def backupProgress(self, status, remaining, total):\n        self.progress(\"Backup\", status, remaining, total)\n\n    def progress(self, action, status, remaining, total):\n        \"\"\"\n        show progress\n        \"\"\"\n        print(\n            \"%s %s at %5.0f%%\"\n            % (\n                action,\n                \"... \" if status == 0 else \"done\",\n                (total - remaining) / total * 100,\n            )\n        )\n\n    def backup(\n        self,\n        backupDB,\n        action=\"Backup\",\n        profile=False,\n        showProgress: int = 200,\n        doClose=True,\n    ):\n        \"\"\"\n        create backup of this SQLDB to the given backup db\n\n        see https://stackoverflow.com/a/59042442/1497139\n\n        Args:\n            backupDB(string): the path to the backupdb or SQLDB.RAM for in memory\n            action(string): the action to display\n            profile(boolean): True if timing information shall be shown\n            showProgress(int): show progress at each showProgress page (0=show no progress)\n        \"\"\"\n        if sys.version_info &lt;= (3, 6):\n            raise Exception(\n                \"backup via stdlibrary not available in python &lt;=3.6 use copyToDB instead\"\n            )\n        startTime = time.time()\n        bck = sqlite3.connect(backupDB)\n        if showProgress &gt; 0:\n            if action == \"Restore\":\n                progress = self.restoreProgress\n            else:\n                progress = self.backupProgress\n        else:\n            progress = None\n        with bck:\n            self.c.backup(bck, pages=showProgress, progress=progress)\n        elapsed = time.time() - startTime\n        if profile:\n            print(\"%s to %s took %5.1f s\" % (action, backupDB, elapsed))\n        if doClose:\n            bck.close()\n            return None\n        else:\n            return bck\n\n    def showDump(self, dump, limit=10):\n        \"\"\"\n        show the given dump up to the given limit\n\n        Args:\n            dump(string): the SQL dump to show\n            limit(int): the maximum number of lines to display\n        \"\"\"\n        s = io.StringIO(dump)\n        index = 0\n        for line in s:\n            if index &lt;= limit:\n                print(line)\n                index += 1\n            else:\n                break\n\n    def executeDump(\n        self, connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True\n    ):\n        \"\"\"\n        execute the given dump for the given connection\n\n        Args:\n            connection(Connection): the sqlite3 connection to use\n            dump(string): the SQL commands for the dump\n            title(string): the title of the dump\n            maxErrors(int): maximum number of errors to be tolerated before stopping and doing a rollback\n            profile(boolean): True if profiling information should be shown\n        Returns:\n            a list of errors\n        \"\"\"\n        if self.debug:\n            self.showDump(dump)\n        startTime = time.time()\n        if profile:\n            print(\"dump of %s has size %4.1f MB\" % (title, len(dump) / 1024 / 1024))\n        errors = []\n        index = 0\n        # fixes https://github.com/WolfgangFahl/ProceedingsTitleParser/issues/37\n        for line in dump.split(\";\\n\"):\n            try:\n                connection.execute(line)\n            except sqlite3.OperationalError as soe:\n                msg = \"SQL error %s in line %d:\\n\\t%s\" % (soe, index, line)\n                errors.append(msg)\n                if len(errors) &lt;= errorDisplayLimit:\n                    print(msg)\n                if len(errors) &gt;= maxErrors:\n                    connection.execute(\"ROLLBACK;\")\n                    break\n\n            index = index + 1\n        if profile:\n            print(\n                \"finished executing dump %s with %d lines and %d errors in %5.1f s\"\n                % (title, index, len(errors), time.time() - startTime)\n            )\n        return errors\n\n    def copyTo(self, copyDB, profile=True):\n        \"\"\"\n        copy my content to another database\n\n        Args:\n\n           copyDB(Connection): the target database\n           profile(boolean): if True show profile information\n        \"\"\"\n        startTime = time.time()\n        dump = \"\\n\".join(self.c.iterdump())\n        # cursor.executescript(dump)\n        if profile:\n            print(\n                \"finished getting dump of %s in %5.1f s\"\n                % (self.dbname, time.time() - startTime)\n            )\n        dumpErrors = self.executeDump(copyDB.c, dump, self.dbname, profile=profile)\n        return dumpErrors\n\n    @staticmethod\n    def restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False):\n        \"\"\"\n        restore the restoreDB from the given backup DB\n\n        Args:\n            backupDB(string): path to the backupDB e.g. backup.db\n            restoreDB(string): path to the restoreDB or in Memory SQLDB.RAM\n            profile(boolean): True if timing information should be shown\n            showProgress(int): show progress at each showProgress page (0=show no progress)\n        \"\"\"\n        backupSQLDB = SQLDB(backupDB)\n        connection = backupSQLDB.backup(\n            restoreDB,\n            action=\"Restore\",\n            profile=profile,\n            showProgress=showProgress,\n            doClose=False,\n        )\n        restoreSQLDB = SQLDB(restoreDB, connection=connection, debug=debug)\n        return restoreSQLDB\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.__init__","title":"<code>__init__(dbname=':memory:', connection=None, check_same_thread=True, timeout=5, debug=False, errorDebug=False)</code>","text":"<p>Construct me for the given dbname and debug</p> <p>Args:</p> <p>dbname(string): name of the database - default is a RAM based database    connection(Connection): an optional connection to be reused    check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139    timeout(float): number of seconds for connection timeout    debug(boolean): if True switch on debug    errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def __init__(\n    self,\n    dbname: str = \":memory:\",\n    connection=None,\n    check_same_thread=True,\n    timeout=5,\n    debug=False,\n    errorDebug=False,\n):\n    \"\"\"\n    Construct me for the given dbname and debug\n\n    Args:\n\n       dbname(string): name of the database - default is a RAM based database\n       connection(Connection): an optional connection to be reused\n       check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139\n       timeout(float): number of seconds for connection timeout\n       debug(boolean): if True switch on debug\n       errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n    self.dbname = dbname\n    self.debug = debug\n    self.errorDebug = errorDebug\n    SQLiteApiFixer.install(lenient=debug)\n    if connection is None:\n        self.c = sqlite3.connect(\n            dbname,\n            detect_types=sqlite3.PARSE_DECLTYPES,\n            check_same_thread=check_same_thread,\n            timeout=timeout,\n        )\n    else:\n        self.c = connection\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.backup","title":"<code>backup(backupDB, action='Backup', profile=False, showProgress=200, doClose=True)</code>","text":"<p>create backup of this SQLDB to the given backup db</p> <p>see https://stackoverflow.com/a/59042442/1497139</p> <p>Parameters:</p> Name Type Description Default <code>backupDB(string)</code> <p>the path to the backupdb or SQLDB.RAM for in memory</p> required <code>action(string)</code> <p>the action to display</p> required <code>profile(boolean)</code> <p>True if timing information shall be shown</p> required <code>showProgress(int)</code> <p>show progress at each showProgress page (0=show no progress)</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def backup(\n    self,\n    backupDB,\n    action=\"Backup\",\n    profile=False,\n    showProgress: int = 200,\n    doClose=True,\n):\n    \"\"\"\n    create backup of this SQLDB to the given backup db\n\n    see https://stackoverflow.com/a/59042442/1497139\n\n    Args:\n        backupDB(string): the path to the backupdb or SQLDB.RAM for in memory\n        action(string): the action to display\n        profile(boolean): True if timing information shall be shown\n        showProgress(int): show progress at each showProgress page (0=show no progress)\n    \"\"\"\n    if sys.version_info &lt;= (3, 6):\n        raise Exception(\n            \"backup via stdlibrary not available in python &lt;=3.6 use copyToDB instead\"\n        )\n    startTime = time.time()\n    bck = sqlite3.connect(backupDB)\n    if showProgress &gt; 0:\n        if action == \"Restore\":\n            progress = self.restoreProgress\n        else:\n            progress = self.backupProgress\n    else:\n        progress = None\n    with bck:\n        self.c.backup(bck, pages=showProgress, progress=progress)\n    elapsed = time.time() - startTime\n    if profile:\n        print(\"%s to %s took %5.1f s\" % (action, backupDB, elapsed))\n    if doClose:\n        bck.close()\n        return None\n    else:\n        return bck\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.close","title":"<code>close()</code>","text":"<p>close my connection</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def close(self):\n    \"\"\"close my connection\"\"\"\n    self.c.close()\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.copyTo","title":"<code>copyTo(copyDB, profile=True)</code>","text":"<p>copy my content to another database</p> <p>Args:</p> <p>copyDB(Connection): the target database    profile(boolean): if True show profile information</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def copyTo(self, copyDB, profile=True):\n    \"\"\"\n    copy my content to another database\n\n    Args:\n\n       copyDB(Connection): the target database\n       profile(boolean): if True show profile information\n    \"\"\"\n    startTime = time.time()\n    dump = \"\\n\".join(self.c.iterdump())\n    # cursor.executescript(dump)\n    if profile:\n        print(\n            \"finished getting dump of %s in %5.1f s\"\n            % (self.dbname, time.time() - startTime)\n        )\n    dumpErrors = self.executeDump(copyDB.c, dump, self.dbname, profile=profile)\n    return dumpErrors\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.createTable","title":"<code>createTable(listOfRecords, entityName, primaryKey=None, withCreate=True, withDrop=False, sampleRecordCount=1, failIfTooFew=True)</code>","text":"<p>Derive Data Definition Language CREATE TABLE command from list of Records by examining first record as defining sample record and execute DDL command.</p> <p>Parameters:</p> Name Type Description Default <code>listOfRecords</code> <code>list</code> <p>A list of Dicts.</p> required <code>entityName</code> <code>str</code> <p>The entity / table name to use.</p> required <code>primaryKey</code> <code>str</code> <p>The key/column to use as a primary key.</p> <code>None</code> <code>withDrop</code> <code>bool</code> <p>True if the existing Table should be dropped.</p> <code>False</code> <code>withCreate</code> <code>bool</code> <p>True if the create Table command should be executed.</p> <code>True</code> <code>sampleRecordCount</code> <code>int</code> <p>Number of sample records expected and to be inspected.</p> <code>1</code> <code>failIfTooFew</code> <code>bool</code> <p>Raise an Exception if too few sample records, else warn only.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EntityInfo</code> <p>Meta data information for the created table.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def createTable(\n    self,\n    listOfRecords,\n    entityName: str,\n    primaryKey: str = None,\n    withCreate: bool = True,\n    withDrop: bool = False,\n    sampleRecordCount=1,\n    failIfTooFew=True,\n):\n    \"\"\"\n    Derive Data Definition Language CREATE TABLE command from list of Records by examining first record\n    as defining sample record and execute DDL command.\n\n    Args:\n        listOfRecords (list): A list of Dicts.\n        entityName (str): The entity / table name to use.\n        primaryKey (str): The key/column to use as a primary key.\n        withDrop (bool): True if the existing Table should be dropped.\n        withCreate (bool): True if the create Table command should be executed.\n        sampleRecordCount (int): Number of sample records expected and to be inspected.\n        failIfTooFew (bool): Raise an Exception if too few sample records, else warn only.\n\n    Returns:\n        EntityInfo: Meta data information for the created table.\n    \"\"\"\n    l = len(listOfRecords)\n    if sampleRecordCount &lt; 0:\n        sampleRecordCount = l\n    if l &lt; sampleRecordCount:\n        msg = f\"only {l}/{sampleRecordCount} of needed sample records to createTable available\"\n        if failIfTooFew:\n            raise Exception(msg)\n        elif self.debug:\n            self.logError(msg)\n\n    sampleRecords = listOfRecords[:sampleRecordCount]\n    entityInfo = EntityInfo(sampleRecords, entityName, primaryKey, debug=self.debug)\n\n    return self.createTable4EntityInfo(entityInfo, withDrop, withCreate)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.createTable4EntityInfo","title":"<code>createTable4EntityInfo(entityInfo, withDrop=False, withCreate=True)</code>","text":"<p>Create a table based on the provided EntityInfo.</p> <p>Parameters:</p> Name Type Description Default <code>entityInfo</code> <code>EntityInfo</code> <p>The EntityInfo object containing table metadata.</p> required <code>withDrop</code> <code>bool</code> <p>If True, drop the existing table before creation.</p> <code>False</code> <code>withCreate</code> <code>bool</code> <p>If True, execute the CREATE TABLE command.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EntityInfo</code> <p>The provided EntityInfo object.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def createTable4EntityInfo(self, entityInfo, withDrop=False, withCreate=True):\n    \"\"\"\n    Create a table based on the provided EntityInfo.\n\n    Args:\n        entityInfo (EntityInfo): The EntityInfo object containing table metadata.\n        withDrop (bool): If True, drop the existing table before creation.\n        withCreate (bool): If True, execute the CREATE TABLE command.\n\n    Returns:\n        EntityInfo: The provided EntityInfo object.\n    \"\"\"\n    if withDrop:\n        self.c.execute(entityInfo.dropTableCmd)\n    if withCreate:\n        try:\n            self.c.execute(entityInfo.createTableCmd)\n        except sqlite3.OperationalError as oe:\n            raise Exception(\n                f\"createTable failed with error {oe} for {entityInfo.createTableCmd}\"\n            )\n    return entityInfo\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.execute","title":"<code>execute(ddlCmd)</code>","text":"<p>execute the given Data Definition Command</p> <p>Parameters:</p> Name Type Description Default <code>ddlCmd(string)</code> <p>e.g. a CREATE TABLE or CREATE View command</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def execute(self, ddlCmd):\n    \"\"\"\n    execute the given Data Definition Command\n\n    Args:\n        ddlCmd(string): e.g. a CREATE TABLE or CREATE View command\n    \"\"\"\n    self.c.execute(ddlCmd)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.executeDump","title":"<code>executeDump(connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True)</code>","text":"<p>execute the given dump for the given connection</p> <p>Parameters:</p> Name Type Description Default <code>connection(Connection)</code> <p>the sqlite3 connection to use</p> required <code>dump(string)</code> <p>the SQL commands for the dump</p> required <code>title(string)</code> <p>the title of the dump</p> required <code>maxErrors(int)</code> <p>maximum number of errors to be tolerated before stopping and doing a rollback</p> required <code>profile(boolean)</code> <p>True if profiling information should be shown</p> required <p>Returns:     a list of errors</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def executeDump(\n    self, connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True\n):\n    \"\"\"\n    execute the given dump for the given connection\n\n    Args:\n        connection(Connection): the sqlite3 connection to use\n        dump(string): the SQL commands for the dump\n        title(string): the title of the dump\n        maxErrors(int): maximum number of errors to be tolerated before stopping and doing a rollback\n        profile(boolean): True if profiling information should be shown\n    Returns:\n        a list of errors\n    \"\"\"\n    if self.debug:\n        self.showDump(dump)\n    startTime = time.time()\n    if profile:\n        print(\"dump of %s has size %4.1f MB\" % (title, len(dump) / 1024 / 1024))\n    errors = []\n    index = 0\n    # fixes https://github.com/WolfgangFahl/ProceedingsTitleParser/issues/37\n    for line in dump.split(\";\\n\"):\n        try:\n            connection.execute(line)\n        except sqlite3.OperationalError as soe:\n            msg = \"SQL error %s in line %d:\\n\\t%s\" % (soe, index, line)\n            errors.append(msg)\n            if len(errors) &lt;= errorDisplayLimit:\n                print(msg)\n            if len(errors) &gt;= maxErrors:\n                connection.execute(\"ROLLBACK;\")\n                break\n\n        index = index + 1\n    if profile:\n        print(\n            \"finished executing dump %s with %d lines and %d errors in %5.1f s\"\n            % (title, index, len(errors), time.time() - startTime)\n        )\n    return errors\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getDebugInfo","title":"<code>getDebugInfo(record, index, executeMany)</code>","text":"<p>get the debug info for the given record at the given index depending on the state of executeMany</p> <p>Parameters:</p> Name Type Description Default <code>record(dict)</code> <p>the record to show</p> required <code>index(int)</code> <p>the index of the record</p> required <code>executeMany(boolean)</code> <p>if True the record may be valid else not</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def getDebugInfo(self, record, index, executeMany):\n    \"\"\"\n    get the debug info for the given record at the given index depending on the state of executeMany\n\n    Args:\n        record(dict): the record to show\n        index(int): the index of the record\n        executeMany(boolean): if True the record may be valid else not\n    \"\"\"\n    debugInfo = \"\"\n    if not executeMany:\n        # shall we shoe the details of the record (which might be a security risk)\n        if self.errorDebug:\n            # show details of record\n            debugInfo = \"\\nrecord  #%d=%s\" % (index, repr(record))\n        else:\n            # show only index\n            debugInfo = \"\\nrecord #%d\" % index\n    return debugInfo\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getTableDict","title":"<code>getTableDict(tableType='table')</code>","text":"<p>get the schema information from this database as a dict</p> <p>Parameters:</p> Name Type Description Default <code>tableType(str)</code> <p>table or view</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Lookup map of tables with columns also being converted to dict</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def getTableDict(self, tableType=\"table\"):\n    \"\"\"\n    get the schema information from this database as a dict\n\n    Args:\n        tableType(str): table or view\n\n    Returns:\n        dict: Lookup map of tables with columns also being converted to dict\n    \"\"\"\n    tableDict = {}\n    for table in self.getTableList(tableType=tableType):\n        colDict = {}\n        for col in table[\"columns\"]:\n            colDict[col[\"name\"]] = col\n        table[\"columns\"] = colDict\n        tableDict[table[\"name\"]] = table\n    return tableDict\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getTableList","title":"<code>getTableList(tableType='table')</code>","text":"<p>get the schema information from this database</p> <p>Parameters:</p> Name Type Description Default <code>tableType(str)</code> <p>table or view</p> required Return <p>list: a list as derived from PRAGMA table_info</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def getTableList(self, tableType=\"table\"):\n    \"\"\"\n    get the schema information from this database\n\n    Args:\n        tableType(str): table or view\n\n    Return:\n        list: a list as derived from PRAGMA table_info\n    \"\"\"\n    tableQuery = f\"SELECT name FROM sqlite_master WHERE type='{tableType}'\"\n    tableList = self.query(tableQuery)\n    for table in tableList:\n        tableName = table[\"name\"]\n        columnQuery = f\"PRAGMA table_info('{tableName}')\"\n        columns = self.query(columnQuery)\n        table[\"columns\"] = columns\n    return tableList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.logError","title":"<code>logError(msg)</code>","text":"<p>log the given error message to stderr</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the error messsage to display</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def logError(self, msg):\n    \"\"\"\n    log the given error message to stderr\n\n    Args:\n        msg(str): the error messsage to display\n    \"\"\"\n    print(msg, file=sys.stderr, flush=True)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.progress","title":"<code>progress(action, status, remaining, total)</code>","text":"<p>show progress</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def progress(self, action, status, remaining, total):\n    \"\"\"\n    show progress\n    \"\"\"\n    print(\n        \"%s %s at %5.0f%%\"\n        % (\n            action,\n            \"... \" if status == 0 else \"done\",\n            (total - remaining) / total * 100,\n        )\n    )\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.query","title":"<code>query(sqlQuery, params=None)</code>","text":"<p>run the given sqlQuery and return a list of Dicts</p> <p>Args:</p> <pre><code>sqlQuery(string): the SQL query to be executed\nparams(tuple): the query params, if any\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <p>a list of Dicts</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def query(self, sqlQuery, params=None):\n    \"\"\"\n    run the given sqlQuery and return a list of Dicts\n\n    Args:\n\n        sqlQuery(string): the SQL query to be executed\n        params(tuple): the query params, if any\n\n    Returns:\n        list: a list of Dicts\n    \"\"\"\n    resultList = []\n    for record in self.queryGen(sqlQuery, params):\n        resultList.append(record)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.queryAll","title":"<code>queryAll(entityInfo, fixDates=True)</code>","text":"<p>query all records for the given entityName/tableName</p> <p>Parameters:</p> Name Type Description Default <code>entityName(string)</code> <p>name of the entity/table to qury</p> required <code>fixDates(boolean)</code> <p>True if date entries should be returned as such and not as strings</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def queryAll(self, entityInfo, fixDates=True):\n    \"\"\"\n    query all records for the given entityName/tableName\n\n    Args:\n       entityName(string): name of the entity/table to qury\n       fixDates(boolean): True if date entries should be returned as such and not as strings\n    \"\"\"\n    sqlQuery = \"SELECT * FROM %s\" % entityInfo.name\n    resultList = self.query(sqlQuery)\n    if fixDates:\n        entityInfo.fixDates(resultList)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.queryGen","title":"<code>queryGen(sqlQuery, params=None)</code>","text":"<p>run the given sqlQuery a a generator for dicts</p> <p>Args:</p> <pre><code>sqlQuery(string): the SQL query to be executed\nparams(tuple): the query params, if any\n</code></pre> <p>Returns:</p> Type Description <p>a generator of dicts</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def queryGen(self, sqlQuery, params=None):\n    \"\"\"\n    run the given sqlQuery a a generator for dicts\n\n    Args:\n\n        sqlQuery(string): the SQL query to be executed\n        params(tuple): the query params, if any\n\n    Returns:\n        a generator of dicts\n    \"\"\"\n    if self.debug:\n        print(sqlQuery)\n        if params is not None:\n            print(params)\n    # https://stackoverflow.com/a/13735506/1497139\n    cur = self.c.cursor()\n    if params is not None:\n        query = cur.execute(sqlQuery, params)\n    else:\n        query = cur.execute(sqlQuery)\n    colname = [d[0] for d in query.description]\n    try:\n        # loop over all rows\n        for row in query:\n            record = dict(zip(colname, row))\n            yield record\n    except Exception as ex:\n        msg = str(ex)\n        self.logError(msg)\n        pass\n    cur.close()\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.restore","title":"<code>restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False)</code>  <code>staticmethod</code>","text":"<p>restore the restoreDB from the given backup DB</p> <p>Parameters:</p> Name Type Description Default <code>backupDB(string)</code> <p>path to the backupDB e.g. backup.db</p> required <code>restoreDB(string)</code> <p>path to the restoreDB or in Memory SQLDB.RAM</p> required <code>profile(boolean)</code> <p>True if timing information should be shown</p> required <code>showProgress(int)</code> <p>show progress at each showProgress page (0=show no progress)</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>@staticmethod\ndef restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False):\n    \"\"\"\n    restore the restoreDB from the given backup DB\n\n    Args:\n        backupDB(string): path to the backupDB e.g. backup.db\n        restoreDB(string): path to the restoreDB or in Memory SQLDB.RAM\n        profile(boolean): True if timing information should be shown\n        showProgress(int): show progress at each showProgress page (0=show no progress)\n    \"\"\"\n    backupSQLDB = SQLDB(backupDB)\n    connection = backupSQLDB.backup(\n        restoreDB,\n        action=\"Restore\",\n        profile=profile,\n        showProgress=showProgress,\n        doClose=False,\n    )\n    restoreSQLDB = SQLDB(restoreDB, connection=connection, debug=debug)\n    return restoreSQLDB\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.showDump","title":"<code>showDump(dump, limit=10)</code>","text":"<p>show the given dump up to the given limit</p> <p>Parameters:</p> Name Type Description Default <code>dump(string)</code> <p>the SQL dump to show</p> required <code>limit(int)</code> <p>the maximum number of lines to display</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def showDump(self, dump, limit=10):\n    \"\"\"\n    show the given dump up to the given limit\n\n    Args:\n        dump(string): the SQL dump to show\n        limit(int): the maximum number of lines to display\n    \"\"\"\n    s = io.StringIO(dump)\n    index = 0\n    for line in s:\n        if index &lt;= limit:\n            print(line)\n            index += 1\n        else:\n            break\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.store","title":"<code>store(listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False)</code>","text":"<p>store the given list of records based on the given entityInfo</p> <p>Args:</p> <p>listOfRecords(list): the list of Dicts to be stored    entityInfo(EntityInfo): the meta data to be used for storing    executeMany(bool): if True the insert command is done with many/all records at once    fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values    replace(bool): if True allow replace for insert</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def store(\n    self, listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False\n):\n    \"\"\"\n    store the given list of records based on the given entityInfo\n\n    Args:\n\n       listOfRecords(list): the list of Dicts to be stored\n       entityInfo(EntityInfo): the meta data to be used for storing\n       executeMany(bool): if True the insert command is done with many/all records at once\n       fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values\n       replace(bool): if True allow replace for insert\n    \"\"\"\n    insertCmd = entityInfo.getInsertCmd(replace=replace)\n    record = None\n    index = 0\n    try:\n        if executeMany:\n            if fixNone:\n                LOD.setNone4List(listOfRecords, entityInfo.typeMap.keys())\n            self.c.executemany(insertCmd, listOfRecords)\n        else:\n            for record in listOfRecords:\n                index += 1\n                if fixNone:\n                    LOD.setNone(record, entityInfo.typeMap.keys())\n                self.c.execute(insertCmd, record)\n        self.c.commit()\n    except sqlite3.ProgrammingError as pe:\n        msg = pe.args[0]\n        if \"You did not supply a value for binding\" in msg:\n            if \":\" in msg:\n                # sqlite now returns the parameter name not the number\n                # You did not supply a value for binding parameter :type.\n                columnName = re.findall(r\":([a-zA-Z][a-zA-Z0-9_]*)\", msg)[0]\n                columnName = columnName.replace(\":\", \"\")\n            else:\n                # pre python 3.10\n                # You did not supply a value for binding 2.\n                columnIndex = int(re.findall(r\"\\d+\", msg)[0])\n                columnName = list(entityInfo.typeMap.keys())[columnIndex - 1]\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            raise Exception(\n                \"%s\\nfailed: no value supplied for column '%s'%s\"\n                % (insertCmd, columnName, debugInfo)\n            )\n        else:\n            raise pe\n    except sqlite3.InterfaceError as ie:\n        msg = ie.args[0]\n        if \"Error binding parameter\" in msg:\n            columnName = re.findall(r\":[_a-zA-Z]\\w*\", msg)[0]\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            raise Exception(\n                \"%s\\nfailed: error binding column '%s'%s\"\n                % (insertCmd, columnName, debugInfo)\n            )\n        else:\n            raise ie\n    except Exception as ex:\n        debugInfo = self.getDebugInfo(record, index, executeMany)\n        msg = \"%s\\nfailed:%s%s\" % (insertCmd, str(ex), debugInfo)\n        raise Exception(msg)\n</code></pre>"},{"location":"#lodstorage.sqlite_api","title":"<code>sqlite_api</code>","text":"<p>Created on 2024-08-24</p> <p>@author: wf</p>"},{"location":"#lodstorage.sqlite_api.DatetimeAdapter","title":"<code>DatetimeAdapter</code>","text":"<p>Class for converting date and time formats with optional lenient error handling.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>class DatetimeAdapter:\n    \"\"\"Class for converting date and time formats with optional lenient error handling.\"\"\"\n\n    def __init__(self, lenient: bool = False):\n        \"\"\"Initialize with optional lenient error handling.\"\"\"\n        self.lenient = lenient\n\n    def _handle_input(self, val: bytes) -&gt; str:\n        \"\"\"Validate and decode the input bytes into string.\"\"\"\n        if not isinstance(val, bytes):\n            raise TypeError(\"Input must be a byte string.\")\n        return val.decode()\n\n    def _handle_error(self, error: Exception, val: bytes):\n        \"\"\"Handle errors based on the lenient mode.\"\"\"\n        if self.lenient:\n            logging.warning(f\"Failed to convert {val}: {error}\")\n            return None\n        else:\n            raise error\n\n    def convert_date(self, val: bytes) -&gt; datetime.date:\n        \"\"\"Convert ISO 8601 date byte string to a datetime.date object.\"\"\"\n        try:\n            decoded_date = self._handle_input(val)\n            dt = datetime.date.fromisoformat(decoded_date)\n            return dt\n        except Exception as e:\n            return self._handle_error(e, val)\n\n    def convert_datetime(self, val: bytes) -&gt; datetime.datetime:\n        \"\"\"Convert ISO 8601 datetime byte string to a datetime.datetime object.\"\"\"\n        try:\n            decoded_datetime = self._handle_input(val)\n            return datetime.datetime.fromisoformat(decoded_datetime)\n        except Exception as e:\n            return self._handle_error(e, val)\n\n    def convert_timestamp(self, val: bytes) -&gt; datetime.datetime:\n        \"\"\"Convert Unix epoch timestamp byte string to a datetime.datetime object.\"\"\"\n        try:\n            decoded_string = self._handle_input(val)\n            timestamp_float = float(decoded_string) / 10**6\n            dt = datetime.datetime.fromtimestamp(timestamp_float)\n            return dt\n        except ValueError as _ve:\n            try:\n                dt = datetime.datetime.fromisoformat(decoded_string)\n                return dt\n            except Exception as e:\n                return self._handle_error(e, val)\n        except Exception as e:\n            return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sqlite_api.DatetimeAdapter.__init__","title":"<code>__init__(lenient=False)</code>","text":"<p>Initialize with optional lenient error handling.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def __init__(self, lenient: bool = False):\n    \"\"\"Initialize with optional lenient error handling.\"\"\"\n    self.lenient = lenient\n</code></pre>"},{"location":"#lodstorage.sqlite_api.DatetimeAdapter.convert_date","title":"<code>convert_date(val)</code>","text":"<p>Convert ISO 8601 date byte string to a datetime.date object.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def convert_date(self, val: bytes) -&gt; datetime.date:\n    \"\"\"Convert ISO 8601 date byte string to a datetime.date object.\"\"\"\n    try:\n        decoded_date = self._handle_input(val)\n        dt = datetime.date.fromisoformat(decoded_date)\n        return dt\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sqlite_api.DatetimeAdapter.convert_datetime","title":"<code>convert_datetime(val)</code>","text":"<p>Convert ISO 8601 datetime byte string to a datetime.datetime object.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def convert_datetime(self, val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert ISO 8601 datetime byte string to a datetime.datetime object.\"\"\"\n    try:\n        decoded_datetime = self._handle_input(val)\n        return datetime.datetime.fromisoformat(decoded_datetime)\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sqlite_api.DatetimeAdapter.convert_timestamp","title":"<code>convert_timestamp(val)</code>","text":"<p>Convert Unix epoch timestamp byte string to a datetime.datetime object.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def convert_timestamp(self, val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert Unix epoch timestamp byte string to a datetime.datetime object.\"\"\"\n    try:\n        decoded_string = self._handle_input(val)\n        timestamp_float = float(decoded_string) / 10**6\n        dt = datetime.datetime.fromtimestamp(timestamp_float)\n        return dt\n    except ValueError as _ve:\n        try:\n            dt = datetime.datetime.fromisoformat(decoded_string)\n            return dt\n        except Exception as e:\n            return self._handle_error(e, val)\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer","title":"<code>SQLiteApiFixer</code>","text":"<p>Class to register SQLite adapters and converters using a DatetimeAdapter instance.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>class SQLiteApiFixer:\n    \"\"\"\n    Class to register SQLite adapters\n    and converters using a DatetimeAdapter instance.\n    \"\"\"\n\n    _instance = None  # Singleton instance\n\n    def __init__(self, lenient: bool = True):\n        \"\"\"Private constructor to initialize the singleton instance.\"\"\"\n        self.adapter = DatetimeAdapter(lenient=lenient)\n        self.register_converters()\n        self.register_adapters()\n\n    @classmethod\n    def install(cls, lenient: bool = True):\n        \"\"\"Install the singleton instance and register SQLite adapters and converters.\"\"\"\n        if cls._instance is None:\n            cls._instance = cls(lenient=lenient)\n        return cls._instance\n\n    def register_adapters(self):\n        \"\"\"Register the necessary SQLite adapters.\"\"\"\n        sqlite3.register_adapter(datetime.date, self.adapt_date_iso)\n        sqlite3.register_adapter(datetime.datetime, self.adapt_datetime_iso)\n        sqlite3.register_adapter(bool, self.adapt_boolean)\n\n    def register_converters(self):\n        \"\"\"Register the necessary SQLite converters.\"\"\"\n        sqlite3.register_converter(\"date\", self.adapter.convert_date)\n        sqlite3.register_converter(\"datetime\", self.adapter.convert_datetime)\n        sqlite3.register_converter(\"timestamp\", self.adapter.convert_timestamp)\n        sqlite3.register_converter(\"boolean\", self.convert_boolean)\n\n    @staticmethod\n    def adapt_date_iso(val: datetime.date):\n        \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n        return val.isoformat()\n\n    @staticmethod\n    def adapt_datetime_iso(val: datetime.datetime):\n        \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n        return val.isoformat()\n\n    @staticmethod\n    def adapt_boolean(val: bool):\n        \"\"\"Adapt boolean to int.\"\"\"\n        return 1 if val else 0\n\n    @staticmethod\n    def convert_boolean(val: bytes):\n        \"\"\"Convert 0 or 1 to boolean.\"\"\"\n        return bool(int(val))\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.__init__","title":"<code>__init__(lenient=True)</code>","text":"<p>Private constructor to initialize the singleton instance.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def __init__(self, lenient: bool = True):\n    \"\"\"Private constructor to initialize the singleton instance.\"\"\"\n    self.adapter = DatetimeAdapter(lenient=lenient)\n    self.register_converters()\n    self.register_adapters()\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.adapt_boolean","title":"<code>adapt_boolean(val)</code>  <code>staticmethod</code>","text":"<p>Adapt boolean to int.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>@staticmethod\ndef adapt_boolean(val: bool):\n    \"\"\"Adapt boolean to int.\"\"\"\n    return 1 if val else 0\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.adapt_date_iso","title":"<code>adapt_date_iso(val)</code>  <code>staticmethod</code>","text":"<p>Adapt datetime.date to ISO 8601 date.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>@staticmethod\ndef adapt_date_iso(val: datetime.date):\n    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n    return val.isoformat()\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.adapt_datetime_iso","title":"<code>adapt_datetime_iso(val)</code>  <code>staticmethod</code>","text":"<p>Adapt datetime.datetime to timezone-naive ISO 8601 date.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>@staticmethod\ndef adapt_datetime_iso(val: datetime.datetime):\n    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n    return val.isoformat()\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.convert_boolean","title":"<code>convert_boolean(val)</code>  <code>staticmethod</code>","text":"<p>Convert 0 or 1 to boolean.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>@staticmethod\ndef convert_boolean(val: bytes):\n    \"\"\"Convert 0 or 1 to boolean.\"\"\"\n    return bool(int(val))\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.install","title":"<code>install(lenient=True)</code>  <code>classmethod</code>","text":"<p>Install the singleton instance and register SQLite adapters and converters.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>@classmethod\ndef install(cls, lenient: bool = True):\n    \"\"\"Install the singleton instance and register SQLite adapters and converters.\"\"\"\n    if cls._instance is None:\n        cls._instance = cls(lenient=lenient)\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.register_adapters","title":"<code>register_adapters()</code>","text":"<p>Register the necessary SQLite adapters.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def register_adapters(self):\n    \"\"\"Register the necessary SQLite adapters.\"\"\"\n    sqlite3.register_adapter(datetime.date, self.adapt_date_iso)\n    sqlite3.register_adapter(datetime.datetime, self.adapt_datetime_iso)\n    sqlite3.register_adapter(bool, self.adapt_boolean)\n</code></pre>"},{"location":"#lodstorage.sqlite_api.SQLiteApiFixer.register_converters","title":"<code>register_converters()</code>","text":"<p>Register the necessary SQLite converters.</p> Source code in <code>lodstorage/sqlite_api.py</code> <pre><code>def register_converters(self):\n    \"\"\"Register the necessary SQLite converters.\"\"\"\n    sqlite3.register_converter(\"date\", self.adapter.convert_date)\n    sqlite3.register_converter(\"datetime\", self.adapter.convert_datetime)\n    sqlite3.register_converter(\"timestamp\", self.adapter.convert_timestamp)\n    sqlite3.register_converter(\"boolean\", self.convert_boolean)\n</code></pre>"},{"location":"#lodstorage.storageconfig","title":"<code>storageconfig</code>","text":"<p>Created on 2020-08-29</p> <p>@author: wf</p>"},{"location":"#lodstorage.storageconfig.StorageConfig","title":"<code>StorageConfig</code>","text":"<p>               Bases: <code>object</code></p> <p>a storage configuration</p> Source code in <code>lodstorage/storageconfig.py</code> <pre><code>class StorageConfig(object):\n    \"\"\"\n    a storage configuration\n    \"\"\"\n\n    def getCachePath(self, ensureExists=True) -&gt; str:\n        \"\"\"\n        get the path to the default cache\n\n        Args:\n            name(str): the name of the cache to use\n        \"\"\"\n\n        cachedir = f\"{self.cacheRootDir}/.{self.cacheDirName}\"\n\n        if ensureExists:\n            if not os.path.exists(cachedir):\n                os.makedirs(cachedir)\n        return cachedir\n\n    def __init__(\n        self,\n        mode=StoreMode.SQL,\n        cacheRootDir: str = None,\n        cacheDirName: str = \"lodstorage\",\n        cacheFile=None,\n        withShowProgress=True,\n        profile=True,\n        debug=False,\n        errorDebug=True,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            mode(StoreMode): the storage mode e.g. sql\n            cacheRootDir(str): the cache root directory to use - if None the home directory will be used\n            cacheFile(string): the common cacheFile to use (if any)\n            withShowProgress(boolean): True if progress should be shown\n            profile(boolean): True if timing / profiling information should be shown\n            debug(boolean): True if debugging information should be shown\n            errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n        \"\"\"\n        if cacheRootDir is None:\n            home = str(Path.home())\n            self.cacheRootDir = f\"{home}\"\n        else:\n            self.cacheRootDir = cacheRootDir\n        self.cacheDirName = cacheDirName\n        self.mode = mode\n        self.cacheFile = cacheFile\n        self.profile = profile\n        self.withShowProgress = withShowProgress\n        self.debug = debug\n        self.errorDebug = errorDebug\n\n    @staticmethod\n    def getDefault(debug=False):\n        return StorageConfig.getSQL(debug)\n\n    @staticmethod\n    def getSQL(debug=False):\n        config = StorageConfig(mode=StoreMode.SQL, debug=debug)\n        config.tableName = None\n        return config\n\n    @staticmethod\n    def getJSON(debug=False):\n        config = StorageConfig(mode=StoreMode.JSON, debug=debug)\n        return config\n\n    @staticmethod\n    def getJsonPickle(debug=False):\n        config = StorageConfig(mode=StoreMode.JSONPICKLE, debug=debug)\n        return config\n\n    @staticmethod\n    def getSPARQL(prefix, endpoint, host, debug=False):\n        config = StorageConfig(mode=StoreMode.SPARQL, debug=debug)\n        config.prefix = prefix\n        config.host = host\n        config.endpoint = endpoint\n        return config\n\n    @staticmethod\n    def getYaml(debug=False):\n        config = StorageConfig(mode=StoreMode.YAML, debug=debug)\n        return config\n</code></pre>"},{"location":"#lodstorage.storageconfig.StorageConfig.__init__","title":"<code>__init__(mode=StoreMode.SQL, cacheRootDir=None, cacheDirName='lodstorage', cacheFile=None, withShowProgress=True, profile=True, debug=False, errorDebug=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>mode(StoreMode)</code> <p>the storage mode e.g. sql</p> required <code>cacheRootDir(str)</code> <p>the cache root directory to use - if None the home directory will be used</p> required <code>cacheFile(string)</code> <p>the common cacheFile to use (if any)</p> required <code>withShowProgress(boolean)</code> <p>True if progress should be shown</p> required <code>profile(boolean)</code> <p>True if timing / profiling information should be shown</p> required <code>debug(boolean)</code> <p>True if debugging information should be shown</p> required <code>errorDebug(boolean)</code> <p>True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> required Source code in <code>lodstorage/storageconfig.py</code> <pre><code>def __init__(\n    self,\n    mode=StoreMode.SQL,\n    cacheRootDir: str = None,\n    cacheDirName: str = \"lodstorage\",\n    cacheFile=None,\n    withShowProgress=True,\n    profile=True,\n    debug=False,\n    errorDebug=True,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        mode(StoreMode): the storage mode e.g. sql\n        cacheRootDir(str): the cache root directory to use - if None the home directory will be used\n        cacheFile(string): the common cacheFile to use (if any)\n        withShowProgress(boolean): True if progress should be shown\n        profile(boolean): True if timing / profiling information should be shown\n        debug(boolean): True if debugging information should be shown\n        errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n    if cacheRootDir is None:\n        home = str(Path.home())\n        self.cacheRootDir = f\"{home}\"\n    else:\n        self.cacheRootDir = cacheRootDir\n    self.cacheDirName = cacheDirName\n    self.mode = mode\n    self.cacheFile = cacheFile\n    self.profile = profile\n    self.withShowProgress = withShowProgress\n    self.debug = debug\n    self.errorDebug = errorDebug\n</code></pre>"},{"location":"#lodstorage.storageconfig.StorageConfig.getCachePath","title":"<code>getCachePath(ensureExists=True)</code>","text":"<p>get the path to the default cache</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the cache to use</p> required Source code in <code>lodstorage/storageconfig.py</code> <pre><code>def getCachePath(self, ensureExists=True) -&gt; str:\n    \"\"\"\n    get the path to the default cache\n\n    Args:\n        name(str): the name of the cache to use\n    \"\"\"\n\n    cachedir = f\"{self.cacheRootDir}/.{self.cacheDirName}\"\n\n    if ensureExists:\n        if not os.path.exists(cachedir):\n            os.makedirs(cachedir)\n    return cachedir\n</code></pre>"},{"location":"#lodstorage.storageconfig.StoreMode","title":"<code>StoreMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>possible supported storage modes</p> Source code in <code>lodstorage/storageconfig.py</code> <pre><code>class StoreMode(Enum):\n    \"\"\"\n    possible supported storage modes\n    \"\"\"\n\n    JSONPICKLE = 1  # JSON Pickle\n    JSON = 2\n    SQL = 3\n    SPARQL = 4\n    YAML = 5\n</code></pre>"},{"location":"#lodstorage.sync","title":"<code>sync</code>","text":"<p>Created on 2023-12-27</p> <p>@author: wf</p>"},{"location":"#lodstorage.sync.Sync","title":"<code>Sync</code>","text":"<p>A class to help with synchronization between two sets of data, each represented as a list of dictionaries.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>class Sync:\n    \"\"\"\n    A class to help with synchronization between two sets of data, each represented as a list of dictionaries.\n    \"\"\"\n\n    def __init__(self, pair: SyncPair):\n        \"\"\"\n        Initialize the Sync class with the given Synchronization Pair.\n        \"\"\"\n        self.pair = pair\n        self.sync_dict = self._create_sync_dict()\n        self.directions = [\"\u2190\", \"\u2194\", \"\u2192\"]\n        self.sides = {\"left\": [\"\u2190\", \"l\", \"left\"], \"right\": [\"\u2192\", \"r\", \"right\"]}\n\n    def handle_direction_error(self, direction: str):\n        invalid_direction_msg = (\n            f\"Invalid direction '{direction}'. Use {', '.join(self.directions)}.\"\n        )\n        raise ValueError(invalid_direction_msg)\n\n    def handle_side_error(self, side: str):\n        invalid_side_msg = f\"Invalid side '{side}'. Use {', '.join(self.sides['left'])} for left or {', '.join(self.sides['right'])} for right.\"\n        raise ValueError(invalid_side_msg)\n\n    def _create_sync_dict(self) -&gt; dict:\n        \"\"\"\n        Create a dictionary representing the synchronization state between left and right data sources.\n        \"\"\"\n        l_keys = {d[self.pair.l_key] for d in self.pair.l_data if self.pair.l_key in d}\n        r_keys = {d[self.pair.r_key] for d in self.pair.r_data if self.pair.r_key in d}\n\n        sync_dict = {\n            \"\u2190\": r_keys - l_keys,  # Present in right but not in left\n            \"\u2194\": l_keys.intersection(r_keys),  # Present in both\n            \"\u2192\": l_keys - r_keys,  # Present in left but not in right\n        }\n        return sync_dict\n\n    def get_record_by_pkey(self, side: str, pkey: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieves a record by primary key from the appropriate data source as specified by direction.\n\n        Args:\n            side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n            pkey (str): The primary key of the record to retrieve.\n\n        Returns:\n            Optional[Dict[str, Any]]: The record if found, otherwise None.\n        \"\"\"\n        record = None\n        if side in self.sides[\"left\"]:  # retrieve from left\n            record = self.pair.l_by_pkey.get(pkey)\n        elif side in self.sides[\"right\"]:  # retrieve from right\n            record = self.pair.r_by_pkey.get(pkey)\n        else:\n            self.handle_side_error(side)\n        return record\n\n    def get_record_by_key(self, side: str, key: str) -&gt; dict:\n        \"\"\"\n        Retrieves a record by the given unique key from the appropriate data source as specified by direction.\n\n        Args:\n            side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n            key (str): The unique key of the record to retrieve.\n\n        Returns:\n            Optional[Dict[str, Any]]: The record if found, otherwise None.\n\n        Raises:\n            ValueError: If the provided direction is invalid.\n        \"\"\"\n        record = None\n        if side in [\"\u2190\", \"l\", \"left\"]:\n            record = next(\n                (item for item in self.pair.l_data if item[self.pair.l_key] == key),\n                None,\n            )\n        elif side in [\"\u2192\", \"r\", \"right\"]:\n            record = next(\n                (item for item in self.pair.r_data if item[self.pair.r_key] == key),\n                None,\n            )\n        else:\n            self.handle_side_error(side)\n        return record\n\n    def get_keys(self, direction: str) -&gt; set:\n        \"\"\"\n        Get the keys for a given direction of synchronization.\n        \"\"\"\n        if direction in self.sync_dict:\n            return self.sync_dict[direction]\n        else:\n            self.handle_direction_error(direction)\n\n    def status_table(self, tablefmt: str = \"grid\") -&gt; str:\n        \"\"\"\n        Create a table representing the synchronization status.\n        \"\"\"\n        total_records = sum(len(keys) for keys in self.sync_dict.values())\n        if total_records == 0:  # Avoid division by zero\n            total_records = 1\n\n        table_data = []\n        for direction, keys in self.sync_dict.items():\n            num_records = len(keys)\n            percentage = (num_records / total_records) * 100\n            table_data.append(\n                {\n                    \"left\": self.pair.l_name,\n                    \"\u2194\": direction,\n                    \"right\": self.pair.r_name,\n                    \"#\": num_records,\n                    \"%\": f\"{percentage:7.2f}%\",\n                }\n            )\n\n        markup = tabulate(\n            table_data,\n            headers=\"keys\",\n            tablefmt=tablefmt,\n            colalign=(\"right\", \"center\", \"left\", \"right\", \"right\"),\n        )\n        return markup\n</code></pre>"},{"location":"#lodstorage.sync.Sync.__init__","title":"<code>__init__(pair)</code>","text":"<p>Initialize the Sync class with the given Synchronization Pair.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def __init__(self, pair: SyncPair):\n    \"\"\"\n    Initialize the Sync class with the given Synchronization Pair.\n    \"\"\"\n    self.pair = pair\n    self.sync_dict = self._create_sync_dict()\n    self.directions = [\"\u2190\", \"\u2194\", \"\u2192\"]\n    self.sides = {\"left\": [\"\u2190\", \"l\", \"left\"], \"right\": [\"\u2192\", \"r\", \"right\"]}\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_keys","title":"<code>get_keys(direction)</code>","text":"<p>Get the keys for a given direction of synchronization.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_keys(self, direction: str) -&gt; set:\n    \"\"\"\n    Get the keys for a given direction of synchronization.\n    \"\"\"\n    if direction in self.sync_dict:\n        return self.sync_dict[direction]\n    else:\n        self.handle_direction_error(direction)\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_record_by_key","title":"<code>get_record_by_key(side, key)</code>","text":"<p>Retrieves a record by the given unique key from the appropriate data source as specified by direction.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>str</code> <p>The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.</p> required <code>key</code> <code>str</code> <p>The unique key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Optional[Dict[str, Any]]: The record if found, otherwise None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided direction is invalid.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_record_by_key(self, side: str, key: str) -&gt; dict:\n    \"\"\"\n    Retrieves a record by the given unique key from the appropriate data source as specified by direction.\n\n    Args:\n        side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n        key (str): The unique key of the record to retrieve.\n\n    Returns:\n        Optional[Dict[str, Any]]: The record if found, otherwise None.\n\n    Raises:\n        ValueError: If the provided direction is invalid.\n    \"\"\"\n    record = None\n    if side in [\"\u2190\", \"l\", \"left\"]:\n        record = next(\n            (item for item in self.pair.l_data if item[self.pair.l_key] == key),\n            None,\n        )\n    elif side in [\"\u2192\", \"r\", \"right\"]:\n        record = next(\n            (item for item in self.pair.r_data if item[self.pair.r_key] == key),\n            None,\n        )\n    else:\n        self.handle_side_error(side)\n    return record\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_record_by_pkey","title":"<code>get_record_by_pkey(side, pkey)</code>","text":"<p>Retrieves a record by primary key from the appropriate data source as specified by direction.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>str</code> <p>The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.</p> required <code>pkey</code> <code>str</code> <p>The primary key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: The record if found, otherwise None.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_record_by_pkey(self, side: str, pkey: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a record by primary key from the appropriate data source as specified by direction.\n\n    Args:\n        side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n        pkey (str): The primary key of the record to retrieve.\n\n    Returns:\n        Optional[Dict[str, Any]]: The record if found, otherwise None.\n    \"\"\"\n    record = None\n    if side in self.sides[\"left\"]:  # retrieve from left\n        record = self.pair.l_by_pkey.get(pkey)\n    elif side in self.sides[\"right\"]:  # retrieve from right\n        record = self.pair.r_by_pkey.get(pkey)\n    else:\n        self.handle_side_error(side)\n    return record\n</code></pre>"},{"location":"#lodstorage.sync.Sync.status_table","title":"<code>status_table(tablefmt='grid')</code>","text":"<p>Create a table representing the synchronization status.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def status_table(self, tablefmt: str = \"grid\") -&gt; str:\n    \"\"\"\n    Create a table representing the synchronization status.\n    \"\"\"\n    total_records = sum(len(keys) for keys in self.sync_dict.values())\n    if total_records == 0:  # Avoid division by zero\n        total_records = 1\n\n    table_data = []\n    for direction, keys in self.sync_dict.items():\n        num_records = len(keys)\n        percentage = (num_records / total_records) * 100\n        table_data.append(\n            {\n                \"left\": self.pair.l_name,\n                \"\u2194\": direction,\n                \"right\": self.pair.r_name,\n                \"#\": num_records,\n                \"%\": f\"{percentage:7.2f}%\",\n            }\n        )\n\n    markup = tabulate(\n        table_data,\n        headers=\"keys\",\n        tablefmt=tablefmt,\n        colalign=(\"right\", \"center\", \"left\", \"right\", \"right\"),\n    )\n    return markup\n</code></pre>"},{"location":"#lodstorage.sync.SyncPair","title":"<code>SyncPair</code>  <code>dataclass</code>","text":"<p>A class to represent a pair of data sources for synchronization.</p> <p>Attributes:        title (str): The title of the synchronization pair.        l_name (str): Name of the left data source (e.g., 'local').        r_name (str): Name of the right data source (e.g., 'wikidata').        l_data (List[Dict[str, Any]]): A list of dictionaries from the left data source.        r_data (List[Dict[str, Any]]): A list of dictionaries from the right data source.        l_key (str): The field name in the left data source dictionaries used as a unique identifier for synchronization.        r_key (str): The field name in the right data source dictionaries used as a unique identifier for synchronization.        l_pkey(str): the primary key field of the left data source        r_pkey(str): the primary key field of the right data source</p> <p>Example usage: l_data = [{'id_l': '1', 'value': 'a'}, {'id_l': '2', 'value': 'b'}] r_data = [{'id_r': '2', 'value': 'b'}, {'id_r': '3', 'value': 'c'}] pair = SyncPair(\"Title\", \"local\", \"wikidata\", l_data, r_data, 'id_l', 'id_r') sync = Sync(pair) print(sync.status_table())</p> Source code in <code>lodstorage/sync.py</code> <pre><code>@dataclass\nclass SyncPair:\n    \"\"\"\n       A class to represent a pair of data sources for synchronization.\n\n       Attributes:\n           title (str): The title of the synchronization pair.\n           l_name (str): Name of the left data source (e.g., 'local').\n           r_name (str): Name of the right data source (e.g., 'wikidata').\n           l_data (List[Dict[str, Any]]): A list of dictionaries from the left data source.\n           r_data (List[Dict[str, Any]]): A list of dictionaries from the right data source.\n           l_key (str): The field name in the left data source dictionaries used as a unique identifier for synchronization.\n           r_key (str): The field name in the right data source dictionaries used as a unique identifier for synchronization.\n           l_pkey(str): the primary key field of the left data source\n           r_pkey(str): the primary key field of the right data source\n\n    Example usage:\n    l_data = [{'id_l': '1', 'value': 'a'}, {'id_l': '2', 'value': 'b'}]\n    r_data = [{'id_r': '2', 'value': 'b'}, {'id_r': '3', 'value': 'c'}]\n    pair = SyncPair(\"Title\", \"local\", \"wikidata\", l_data, r_data, 'id_l', 'id_r')\n    sync = Sync(pair)\n    print(sync.status_table())\n    \"\"\"\n\n    title: str\n    l_name: str\n    r_name: str\n    l_data: List[Dict[str, Any]]\n    r_data: List[Dict[str, Any]]\n    l_key: str\n    r_key: str\n    l_pkey: Optional[str] = None\n    r_pkey: Optional[str] = None\n    # Add dictionaries for quick primary key access\n    l_by_pkey: Dict[str, Dict[str, Any]] = field(init=False)\n    r_by_pkey: Dict[str, Dict[str, Any]] = field(init=False)\n\n    def __post_init__(self):\n        # Set the l_pkey to l_key if not provided\n        if self.l_pkey is None:\n            self.l_pkey = self.l_key\n        # Set the r_pkey to r_key if not provided\n        if self.r_pkey is None:\n            self.r_pkey = self.r_key\n        self.l_by_pkey = {d[self.l_pkey]: d for d in self.l_data if self.l_pkey in d}\n        self.r_by_pkey = {d[self.r_pkey]: d for d in self.r_data if self.r_pkey in d}\n</code></pre>"},{"location":"#lodstorage.tabulateCounter","title":"<code>tabulateCounter</code>","text":"<p>Created on 2021-06-13</p> <p>@author: wf</p>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter","title":"<code>TabulateCounter</code>","text":"<p>               Bases: <code>object</code></p> <p>helper for tabulating Counters</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>class TabulateCounter(object):\n    \"\"\"\n    helper for tabulating Counters\n    \"\"\"\n\n    def __init__(self, counter):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.counter = counter\n\n    def mostCommonTable(\n        self, headers=[\"#\", \"key\", \"count\", \"%\"], tablefmt=\"pretty\", limit=50\n    ):\n        \"\"\"\n        get the most common Table\n        \"\"\"\n        bins = len(self.counter.keys())\n        limit = min(bins, limit)\n        total = sum(self.counter.values())\n        binTable = [(\"total\", bins, total)]\n        for i, bintuple in enumerate(self.counter.most_common(limit)):\n            key, count = bintuple\n            binTable.append((i + 1, key, count, count / total * 100.0))\n\n        table = tabulate(binTable, headers=headers, tablefmt=tablefmt, floatfmt=\".2f\")\n        return table\n</code></pre>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter.__init__","title":"<code>__init__(counter)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>def __init__(self, counter):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.counter = counter\n</code></pre>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter.mostCommonTable","title":"<code>mostCommonTable(headers=['#', 'key', 'count', '%'], tablefmt='pretty', limit=50)</code>","text":"<p>get the most common Table</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>def mostCommonTable(\n    self, headers=[\"#\", \"key\", \"count\", \"%\"], tablefmt=\"pretty\", limit=50\n):\n    \"\"\"\n    get the most common Table\n    \"\"\"\n    bins = len(self.counter.keys())\n    limit = min(bins, limit)\n    total = sum(self.counter.values())\n    binTable = [(\"total\", bins, total)]\n    for i, bintuple in enumerate(self.counter.most_common(limit)):\n        key, count = bintuple\n        binTable.append((i + 1, key, count, count / total * 100.0))\n\n    table = tabulate(binTable, headers=headers, tablefmt=tablefmt, floatfmt=\".2f\")\n    return table\n</code></pre>"},{"location":"#lodstorage.uml","title":"<code>uml</code>","text":"<p>Created on 2020-09-04</p> <p>@author: wf</p>"},{"location":"#lodstorage.uml.UML","title":"<code>UML</code>","text":"<p>               Bases: <code>object</code></p> <p>UML diagrams via plantuml</p> Source code in <code>lodstorage/uml.py</code> <pre><code>class UML(object):\n    \"\"\"\n    UML diagrams via plantuml\n\n    \"\"\"\n\n    skinparams = \"\"\"\n' BITPlan Corporate identity skin params\n' Copyright (c) 2015-2020 BITPlan GmbH\n' see http://wiki.bitplan.com/PlantUmlSkinParams#BITPlanCI\n' skinparams generated by com.bitplan.restmodelmanager\nskinparam note {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam component {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam package {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam usecase {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam activity {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam classAttribute {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam interface {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam class {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam object {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nhide Circle\n' end of skinparams '\n\"\"\"\n\n    def __init__(self, debug=False):\n        \"\"\"\n        Constructor\n        Args:\n            debug(boolean): True if debug information should be shown\n        \"\"\"\n        self.debug = debug\n\n    def tableListToPlantUml(\n        self, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True\n    ):\n        \"\"\"\n        convert tableList to PlantUml notation\n\n        Args:\n            tableList(list): the tableList list of Dicts from getTableList() to convert\n            title(string): optional title to be added\n            packageName(string): optional packageName to be added\n            generalizeTo(string): optional name of a general table to be derived\n            withSkin(boolean): if True add default BITPlan skin parameters\n\n        Returns:\n            string: the Plantuml notation for the entities in columns of the given tablelist\n        \"\"\"\n        uml = \"\"\n        indent = \"\"\n        inherit = \"\"\n        if title is not None:\n            uml += \"title\\n%s\\nend title\\n\" % title\n        if packageName is not None:\n            uml += \"package %s {\\n\" % packageName\n            indent = \"  \"\n        if generalizeTo is not None:\n            generalTable = Schema.getGeneral(tableList, generalizeTo)\n            for table in tableList:\n                inherit += \"%s%s &lt;|-- %s\\n\" % (indent, generalizeTo, table[\"name\"])\n            tableList.insert(0, generalTable)\n        for table in tableList:\n            classUml = \"\"\n            sortedColumns = sorted(table[\"columns\"], key=lambda col: col[\"name\"])\n            for col in sortedColumns:\n                mandatory = \"*\" if col[\"notnull\"] == 1 else \"\"\n                pk = \" &lt;&lt;PK&gt;&gt;\" if col[\"pk\"] == 1 else \"\"\n                colName = col[\"name\"].strip()\n                colType = col[\"type\"].strip()\n                if \"link\" in col:\n                    colName = col[\"link\"]\n                colUml = f\"{indent} {mandatory}{colName} : {colType}{pk}\\n\"\n                classUml += colUml\n            tableName = table[\"name\"]\n            if \"notes\" in table:\n                uml += \"Note top of %s\\n%s\\nEnd note\\n\" % (tableName, table[\"notes\"])\n            uml += f\"{indent}class {tableName} &lt;&lt; Entity &gt;&gt; {{\\n{classUml}{indent}}}\\n\"\n        uml += inherit\n        if packageName is not None:\n            uml += \"}\\n\"\n        if withSkin:\n            uml += UML.skinparams\n        return uml\n\n    def mergeSchema(\n        self,\n        schemaManager,\n        tableList,\n        title=None,\n        packageName=None,\n        generalizeTo=None,\n        withSkin=True,\n    ):\n        \"\"\"\n        merge Schema and tableList to PlantUml notation\n\n        Args:\n            schemaManager(SchemaManager): a schema manager to be used\n            tableList(list): the tableList list of Dicts from getTableList() to convert\n            title(string): optional title to be added\n            packageName(string): optional packageName to be added\n            generalizeTo(string): optional name of a general table to be derived\n            withSkin(boolean): if True add default BITPlan skin parameters\n\n        Returns:\n            string: the Plantuml notation for the entities in columns of the given tablelist\n\n        \"\"\"\n        if schemaManager is not None:\n            for table in tableList:\n                if \"schema\" in table:\n                    schema = schemaManager.schemasByName[table[\"schema\"]]\n                    url = \"%s/%s\" % (schemaManager.baseUrl, schema.name)\n                    url = url.replace(\" \", \"_\")  # mediawiki\n                    instanceNote = \"\"\n                    if \"instances\" in table:\n                        instanceNote = \"\\n%d instances \" % (table[\"instances\"])\n                    table[\"notes\"] = \"\"\"[[%s %s]]%s\"\"\" % (\n                        url,\n                        schema.name,\n                        instanceNote,\n                    )\n                    for col in table[\"columns\"]:\n                        colName = col[\"name\"]\n                        if colName in schema.propsByName:\n                            prop = schema.propsByName[colName]\n                            if prop.iri is not None:\n                                tooltip = \"\"\n                                if prop.definition is not None:\n                                    tooltip = \"{%s}\" % prop.definition\n                                col[\"link\"] = \"[[%s%s %s]]\" % (\n                                    prop.iri,\n                                    tooltip,\n                                    colName,\n                                )\n                                col[\"special\"] = True  # keep column even if generalized\n                    pass\n        plantuml = self.tableListToPlantUml(\n            tableList,\n            title=title,\n            packageName=packageName,\n            generalizeTo=generalizeTo,\n            withSkin=withSkin,\n        )\n        return plantuml\n</code></pre>"},{"location":"#lodstorage.uml.UML.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>Constructor Args:     debug(boolean): True if debug information should be shown</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def __init__(self, debug=False):\n    \"\"\"\n    Constructor\n    Args:\n        debug(boolean): True if debug information should be shown\n    \"\"\"\n    self.debug = debug\n</code></pre>"},{"location":"#lodstorage.uml.UML.mergeSchema","title":"<code>mergeSchema(schemaManager, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True)</code>","text":"<p>merge Schema and tableList to PlantUml notation</p> <p>Parameters:</p> Name Type Description Default <code>schemaManager(SchemaManager)</code> <p>a schema manager to be used</p> required <code>tableList(list)</code> <p>the tableList list of Dicts from getTableList() to convert</p> required <code>title(string)</code> <p>optional title to be added</p> required <code>packageName(string)</code> <p>optional packageName to be added</p> required <code>generalizeTo(string)</code> <p>optional name of a general table to be derived</p> required <code>withSkin(boolean)</code> <p>if True add default BITPlan skin parameters</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the Plantuml notation for the entities in columns of the given tablelist</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def mergeSchema(\n    self,\n    schemaManager,\n    tableList,\n    title=None,\n    packageName=None,\n    generalizeTo=None,\n    withSkin=True,\n):\n    \"\"\"\n    merge Schema and tableList to PlantUml notation\n\n    Args:\n        schemaManager(SchemaManager): a schema manager to be used\n        tableList(list): the tableList list of Dicts from getTableList() to convert\n        title(string): optional title to be added\n        packageName(string): optional packageName to be added\n        generalizeTo(string): optional name of a general table to be derived\n        withSkin(boolean): if True add default BITPlan skin parameters\n\n    Returns:\n        string: the Plantuml notation for the entities in columns of the given tablelist\n\n    \"\"\"\n    if schemaManager is not None:\n        for table in tableList:\n            if \"schema\" in table:\n                schema = schemaManager.schemasByName[table[\"schema\"]]\n                url = \"%s/%s\" % (schemaManager.baseUrl, schema.name)\n                url = url.replace(\" \", \"_\")  # mediawiki\n                instanceNote = \"\"\n                if \"instances\" in table:\n                    instanceNote = \"\\n%d instances \" % (table[\"instances\"])\n                table[\"notes\"] = \"\"\"[[%s %s]]%s\"\"\" % (\n                    url,\n                    schema.name,\n                    instanceNote,\n                )\n                for col in table[\"columns\"]:\n                    colName = col[\"name\"]\n                    if colName in schema.propsByName:\n                        prop = schema.propsByName[colName]\n                        if prop.iri is not None:\n                            tooltip = \"\"\n                            if prop.definition is not None:\n                                tooltip = \"{%s}\" % prop.definition\n                            col[\"link\"] = \"[[%s%s %s]]\" % (\n                                prop.iri,\n                                tooltip,\n                                colName,\n                            )\n                            col[\"special\"] = True  # keep column even if generalized\n                pass\n    plantuml = self.tableListToPlantUml(\n        tableList,\n        title=title,\n        packageName=packageName,\n        generalizeTo=generalizeTo,\n        withSkin=withSkin,\n    )\n    return plantuml\n</code></pre>"},{"location":"#lodstorage.uml.UML.tableListToPlantUml","title":"<code>tableListToPlantUml(tableList, title=None, packageName=None, generalizeTo=None, withSkin=True)</code>","text":"<p>convert tableList to PlantUml notation</p> <p>Parameters:</p> Name Type Description Default <code>tableList(list)</code> <p>the tableList list of Dicts from getTableList() to convert</p> required <code>title(string)</code> <p>optional title to be added</p> required <code>packageName(string)</code> <p>optional packageName to be added</p> required <code>generalizeTo(string)</code> <p>optional name of a general table to be derived</p> required <code>withSkin(boolean)</code> <p>if True add default BITPlan skin parameters</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the Plantuml notation for the entities in columns of the given tablelist</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def tableListToPlantUml(\n    self, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True\n):\n    \"\"\"\n    convert tableList to PlantUml notation\n\n    Args:\n        tableList(list): the tableList list of Dicts from getTableList() to convert\n        title(string): optional title to be added\n        packageName(string): optional packageName to be added\n        generalizeTo(string): optional name of a general table to be derived\n        withSkin(boolean): if True add default BITPlan skin parameters\n\n    Returns:\n        string: the Plantuml notation for the entities in columns of the given tablelist\n    \"\"\"\n    uml = \"\"\n    indent = \"\"\n    inherit = \"\"\n    if title is not None:\n        uml += \"title\\n%s\\nend title\\n\" % title\n    if packageName is not None:\n        uml += \"package %s {\\n\" % packageName\n        indent = \"  \"\n    if generalizeTo is not None:\n        generalTable = Schema.getGeneral(tableList, generalizeTo)\n        for table in tableList:\n            inherit += \"%s%s &lt;|-- %s\\n\" % (indent, generalizeTo, table[\"name\"])\n        tableList.insert(0, generalTable)\n    for table in tableList:\n        classUml = \"\"\n        sortedColumns = sorted(table[\"columns\"], key=lambda col: col[\"name\"])\n        for col in sortedColumns:\n            mandatory = \"*\" if col[\"notnull\"] == 1 else \"\"\n            pk = \" &lt;&lt;PK&gt;&gt;\" if col[\"pk\"] == 1 else \"\"\n            colName = col[\"name\"].strip()\n            colType = col[\"type\"].strip()\n            if \"link\" in col:\n                colName = col[\"link\"]\n            colUml = f\"{indent} {mandatory}{colName} : {colType}{pk}\\n\"\n            classUml += colUml\n        tableName = table[\"name\"]\n        if \"notes\" in table:\n            uml += \"Note top of %s\\n%s\\nEnd note\\n\" % (tableName, table[\"notes\"])\n        uml += f\"{indent}class {tableName} &lt;&lt; Entity &gt;&gt; {{\\n{classUml}{indent}}}\\n\"\n    uml += inherit\n    if packageName is not None:\n        uml += \"}\\n\"\n    if withSkin:\n        uml += UML.skinparams\n    return uml\n</code></pre>"},{"location":"#lodstorage.version","title":"<code>version</code>","text":"<p>Created on 2022-03-06</p> <p>@author: wf</p>"},{"location":"#lodstorage.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyLoDStorage</p> Source code in <code>lodstorage/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyLoDStorage\n    \"\"\"\n\n    name = \"pylodstorage\"\n    version = lodstorage.__version__\n    date = \"2020-09-10\"\n    updated = \"2025-12-01\"\n    description = \"python List of Dict (Table) Storage library\"\n</code></pre>"},{"location":"#lodstorage.yaml_path","title":"<code>yaml_path</code>","text":"<p>Created on 2025-11-23</p> <p>@author: wf</p>"},{"location":"#lodstorage.yaml_path.YamlPath","title":"<code>YamlPath</code>","text":"<p>provide path to loading configuration or data files by checking: - a provided path or an optional user-specific location (~/.pylodstorage).</p> Source code in <code>lodstorage/yaml_path.py</code> <pre><code>class YamlPath:\n    \"\"\"\n    provide path to loading configuration or data files by checking:\n    - a provided path or an optional user-specific location (~/.pylodstorage).\n    \"\"\"\n\n    @classmethod\n    def getSamplePath(cls, yamlFileName: str) -&gt; str:\n        \"\"\"\n        Get the path to the sample YAML file usually located in ../sampledata relative to this script.\n\n        Args:\n            yamlFileName (str): The name of the YAML file.\n\n        Returns:\n            str: The absolute path to the sample file.\n        \"\"\"\n        base_dir = os.path.dirname(__file__)\n        sample_path = os.path.abspath(\n            os.path.join(base_dir, \"..\", \"sampledata\", yamlFileName)\n        )\n        return sample_path\n\n    @classmethod\n    def getDefaultPath(cls, yamlFileName: str) -&gt; str:\n        \"\"\"\n        Get the path to the YAML file in the default user home location (.pylodstorage).\n\n        Args:\n            yamlFileName (str): The name of the YAML file.\n\n        Returns:\n            str: The full path to the file in the user's home directory.\n        \"\"\"\n        home = str(Path.home())\n        default_path = f\"{home}/.pylodstorage/{yamlFileName}\"\n        return default_path\n\n    @classmethod\n    def getPaths(\n        cls, yamlFileName: str, yamlPath: str = None, with_default: bool = True\n    ):\n        \"\"\"\n        Get a list of YAML file paths to be used for loading configuration/data.\n\n        Args:\n            yamlFileName (str): The name of the YAML file.\n            yamlPath (str, optional): The full path to read from. Defaults to None (uses getSamplePath).\n            with_default (bool, optional): Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.\n\n        Returns:\n            list: A list of file paths found.\n        \"\"\"\n        if yamlPath is None:\n            yamlPath = cls.getSamplePath(yamlFileName)\n\n        yamlPaths = [yamlPath]\n\n        if with_default:\n            homepath = cls.getDefaultPath(yamlFileName)\n            if os.path.isfile(homepath):\n                yamlPaths.append(homepath)\n\n        return yamlPaths\n</code></pre>"},{"location":"#lodstorage.yaml_path.YamlPath.getDefaultPath","title":"<code>getDefaultPath(yamlFileName)</code>  <code>classmethod</code>","text":"<p>Get the path to the YAML file in the default user home location (.pylodstorage).</p> <p>Parameters:</p> Name Type Description Default <code>yamlFileName</code> <code>str</code> <p>The name of the YAML file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the file in the user's home directory.</p> Source code in <code>lodstorage/yaml_path.py</code> <pre><code>@classmethod\ndef getDefaultPath(cls, yamlFileName: str) -&gt; str:\n    \"\"\"\n    Get the path to the YAML file in the default user home location (.pylodstorage).\n\n    Args:\n        yamlFileName (str): The name of the YAML file.\n\n    Returns:\n        str: The full path to the file in the user's home directory.\n    \"\"\"\n    home = str(Path.home())\n    default_path = f\"{home}/.pylodstorage/{yamlFileName}\"\n    return default_path\n</code></pre>"},{"location":"#lodstorage.yaml_path.YamlPath.getPaths","title":"<code>getPaths(yamlFileName, yamlPath=None, with_default=True)</code>  <code>classmethod</code>","text":"<p>Get a list of YAML file paths to be used for loading configuration/data.</p> <p>Parameters:</p> Name Type Description Default <code>yamlFileName</code> <code>str</code> <p>The name of the YAML file.</p> required <code>yamlPath</code> <code>str</code> <p>The full path to read from. Defaults to None (uses getSamplePath).</p> <code>None</code> <code>with_default</code> <code>bool</code> <p>Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of file paths found.</p> Source code in <code>lodstorage/yaml_path.py</code> <pre><code>@classmethod\ndef getPaths(\n    cls, yamlFileName: str, yamlPath: str = None, with_default: bool = True\n):\n    \"\"\"\n    Get a list of YAML file paths to be used for loading configuration/data.\n\n    Args:\n        yamlFileName (str): The name of the YAML file.\n        yamlPath (str, optional): The full path to read from. Defaults to None (uses getSamplePath).\n        with_default (bool, optional): Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.\n\n    Returns:\n        list: A list of file paths found.\n    \"\"\"\n    if yamlPath is None:\n        yamlPath = cls.getSamplePath(yamlFileName)\n\n    yamlPaths = [yamlPath]\n\n    if with_default:\n        homepath = cls.getDefaultPath(yamlFileName)\n        if os.path.isfile(homepath):\n            yamlPaths.append(homepath)\n\n    return yamlPaths\n</code></pre>"},{"location":"#lodstorage.yaml_path.YamlPath.getSamplePath","title":"<code>getSamplePath(yamlFileName)</code>  <code>classmethod</code>","text":"<p>Get the path to the sample YAML file usually located in ../sampledata relative to this script.</p> <p>Parameters:</p> Name Type Description Default <code>yamlFileName</code> <code>str</code> <p>The name of the YAML file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The absolute path to the sample file.</p> Source code in <code>lodstorage/yaml_path.py</code> <pre><code>@classmethod\ndef getSamplePath(cls, yamlFileName: str) -&gt; str:\n    \"\"\"\n    Get the path to the sample YAML file usually located in ../sampledata relative to this script.\n\n    Args:\n        yamlFileName (str): The name of the YAML file.\n\n    Returns:\n        str: The absolute path to the sample file.\n    \"\"\"\n    base_dir = os.path.dirname(__file__)\n    sample_path = os.path.abspath(\n        os.path.join(base_dir, \"..\", \"sampledata\", yamlFileName)\n    )\n    return sample_path\n</code></pre>"}]}