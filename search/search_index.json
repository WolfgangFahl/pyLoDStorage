{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyLodStorage API Documentation","text":""},{"location":"#lodstorage.cache","title":"<code>cache</code>","text":"<p>Created on 2024-03-09</p> <p>@author: wf</p> <p>refactored from https://github.com/WolfgangFahl/pyCEURmake/blob/main/ceurws/utils/json_cache.py by Tim Holzheim</p>"},{"location":"#lodstorage.cache.Cache","title":"<code>Cache</code>","text":"<p>Represents cache metadata and its file extension.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the cache.</p> <code>extension</code> <code>str</code> <p>The file extension for the cache (e.g., 'json', 'csv').</p> <code>size</code> <code>int</code> <p>The size of the cache file in bytes.</p> <code>count</code> <code>Optional[int]</code> <p>Optional; the number of items in the cache, if applicable.</p> <code>count_attr</code> <code>str</code> <p>the name of the attribute to determine the number of items, if applicable</p> <code>last_accessed</code> <code>datetime</code> <p>Optional; the last accessed timestamp of the cache.</p> Source code in <code>lodstorage/cache.py</code> <pre><code>@lod_storable\nclass Cache:\n    \"\"\"\n    Represents cache metadata and its file extension.\n\n    Attributes:\n        name: The name of the cache.\n        extension: The file extension for the cache (e.g., 'json', 'csv').\n        size: The size of the cache file in bytes.\n        count: Optional; the number of items in the cache, if applicable.\n        count_attr: the name of the attribute to determine the number of items, if applicable\n        last_accessed: Optional; the last accessed timestamp of the cache.\n    \"\"\"\n\n    name: str\n    extension: str\n    count_attr: str = None\n    count: Optional[int] = None\n\n    def set_path(self, base_path: str):\n        \"\"\"\n        Set my path based on the given base_path and ensure the parent directory is created.\n\n        Args:\n            base_path (str): The base path where the directory should be created.\n        \"\"\"\n        self.path = Path(f\"{base_path}/{self.name}{self.extension}\")\n        # Ensure parent directory is created\n        self.path.parent.mkdir(parents=True, exist_ok=True)\n\n    @property\n    def is_stored(self) -&gt; bool:\n        \"\"\"Determines if the cache file exists and is not empty.\"\"\"\n        return self.path.is_file() and self.path.stat().st_size &gt; 1\n\n    @property\n    def size(self) -&gt; int:\n        cache_size = os.path.getsize(self.path) if os.path.isfile(self.path) else 0\n        return cache_size\n\n    @property\n    def last_accessed(self) -&gt; datetime:\n        cache_last_accessed = (\n            datetime.fromtimestamp(os.path.getmtime(self.path))\n            if os.path.isfile(self.path)\n            else None\n        )\n        return cache_last_accessed\n</code></pre>"},{"location":"#lodstorage.cache.Cache.is_stored","title":"<code>is_stored: bool</code>  <code>property</code>","text":"<p>Determines if the cache file exists and is not empty.</p>"},{"location":"#lodstorage.cache.Cache.set_path","title":"<code>set_path(base_path)</code>","text":"<p>Set my path based on the given base_path and ensure the parent directory is created.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>The base path where the directory should be created.</p> required Source code in <code>lodstorage/cache.py</code> <pre><code>def set_path(self, base_path: str):\n    \"\"\"\n    Set my path based on the given base_path and ensure the parent directory is created.\n\n    Args:\n        base_path (str): The base path where the directory should be created.\n    \"\"\"\n    self.path = Path(f\"{base_path}/{self.name}{self.extension}\")\n    # Ensure parent directory is created\n    self.path.parent.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"#lodstorage.cache.CacheManager","title":"<code>CacheManager</code>","text":"<p>Manages multiple cache files with various extensions.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name used for the base directory where cache files are stored.</p> <code>caches</code> <code>Dict[str, Cache]</code> <p>A dictionary to track each cache's metadata.</p> Source code in <code>lodstorage/cache.py</code> <pre><code>@lod_storable\nclass CacheManager:\n    \"\"\"Manages multiple cache files with various extensions.\n\n    Attributes:\n        name: The name used for the base directory where cache files are stored.\n        caches: A dictionary to track each cache's metadata.\n    \"\"\"\n\n    name: str\n    caches: Dict[str, Cache] = field(default_factory=dict)\n\n    def __post_init__(self):\n        self.base_dir = None\n\n    def base_path(self) -&gt; str:\n        \"\"\"Fetches the base path for this cache manager.\n\n        Args:\n            cache: The cache for which to generate the file path.\n\n        Returns:\n            The base path\n        \"\"\"\n        if self.base_dir is None:\n            self.base_dir = os.path.expanduser(\"~\")\n        base_path = os.path.join(self.base_dir, f\".{self.name}\")\n        os.makedirs(base_path, exist_ok=True)\n        return base_path\n\n    def get_cache_by_name(self, lod_name, ext=\".json\") -&gt; Cache:\n        \"\"\"\n        Retrieves or creates a cache object by name and extension.\n\n        Args:\n            cache_name (str): The name of the cache to retrieve or create.\n            ext (str): The file extension for the cache.\n\n        Returns:\n            Cache: An existing or newly created Cache object.\n        \"\"\"\n        if lod_name in self.caches:\n            cache = self.caches[lod_name + ext]\n        else:\n            cache = Cache(lod_name, ext)\n            self.caches[lod_name + ext] = cache\n        base_path = self.base_path()\n        cache.set_path(base_path)\n        return cache\n\n    def load(\n        self,\n        lod_name: str,\n        ext: str = \".json\",\n        cls: Optional[Type[YamlAble]] = None,\n        count_attr: str = None,\n    ) -&gt; Union[List, Dict, None]:\n        \"\"\"\n        Load data from a cache file. This method supports JSON and, if a relevant class is provided, other formats like YAML.\n\n        Args:\n            lod_name (str): The name of the list of dicts or class instances to read from cache.\n            ext (str): The extension of the cache file, indicating the format (default is \".json\").\n            cls (Optional[Type[YamlAble]]): The class type for deserialization. This class must have from_json() or from_yaml()\n                                             class methods for deserialization, depending on the file extension.\n            count_attr(str): the name of attribute data_to_store for updating the cache.count s\n        Returns:\n            Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.\n        \"\"\"\n        cache = self.get_cache_by_name(lod_name, ext)\n        cache.count_attr = count_attr\n        result = None\n        if cache.is_stored:\n            if ext == \".json\":\n                if cls and hasattr(cls, \"load_from_yaml_file\"):\n                    result = cls.load_from_json_file(\n                        cache.path\n                    )  # Adjusted for class method\n                else:\n                    with open(cache.path, encoding=\"utf-8\") as json_file:\n                        result = orjson.loads(json_file.read())\n            elif ext == \".yaml\":\n                if cls and hasattr(cls, \"load_from_yaml_file\"):\n                    result = cls.load_from_yaml_file(\n                        cache.path\n                    )  # Adjusted for class method\n                else:\n                    raise ValueError(\n                        \"YAML deserialization requires a cls parameter that is a subclass of YamlAble.\"\n                    )\n            else:\n                raise ValueError(f\"Unsupported file extension {ext} for loading.\")\n\n            # Dynamic count update based on count_attr if applicable\n            if count_attr and hasattr(result, count_attr):\n                cache.count = len(getattr(result, count_attr))\n            elif isinstance(result, list):\n                cache.count = len(result)\n\n        return result\n\n    def store(\n        self,\n        cache_name: str,\n        data_to_store: Union[List, Dict],\n        ext: str = \".json\",\n        count_attr: str = None,\n    ) -&gt; Cache:\n        \"\"\"\n        Stores data into a cache file, handling serialization based on the specified file extension.\n        Supports JSON and YAML formats, and custom serialization for classes that provide specific\n        serialization methods.\n\n        Args:\n            cache_name (str): The identifier for the cache where the data will be stored.\n            data_to_store (Union[List, Dict]): The data to be stored in the cache. This can be a list of dictionaries,\n                                               a single dictionary, or instances of data classes if `cls` is provided.\n            ext (str): The file extension indicating the serialization format (e.g., '.json', '.yaml').\n                       Defaults to '.json'.\n            count_attr(str): the name of attribute data_to_store for updating the cache.count s\n\n        Raises:\n            ValueError: If the file extension is unsupported or if required methods for serialization are not implemented in `cls`.\n        \"\"\"\n        cache = self.get_cache_by_name(cache_name, ext)\n        cache.count_attr = count_attr\n        cache.set_path(self.base_path())\n\n        if ext == \".json\":\n            # Check if  cls has a method `save_to_json_file`\n            # that accepts a file path and data to store\n            if isinstance(data_to_store, list):\n                json_str = orjson.dumps(data_to_store, option=orjson.OPT_INDENT_2)\n                with cache.path.open(\"wb\") as json_file:\n                    json_file.write(json_str)\n            else:\n                if hasattr(data_to_store, \"save_to_json_file\"):\n                    data_to_store.save_to_json_file(str(cache.path))\n                else:\n                    raise ValueError(\n                        \"JSON serialization requires a 'save_to_json_file' method\"\n                    )\n        elif ext == \".yaml\":\n            if hasattr(data_to_store, \"save_to_yaml_file\"):\n                # Assuming cls has a method `save_to_yaml_file` that accepts a file path and data to store\n                data_to_store.save_to_yaml_file(str(cache.path))\n            else:\n                raise ValueError(\n                    \"YAML serialization requires a 'save_to_yaml_file' method.\"\n                )\n        else:\n            raise ValueError(f\"Unsupported file extension {ext}.\")\n\n        # Update cache metadata post storing\n        if count_attr and hasattr(data_to_store, count_attr):\n            cache.count = len(getattr(data_to_store, count_attr))\n        elif isinstance(data_to_store, list):\n            cache.count = len(data_to_store)\n\n        return cache\n</code></pre>"},{"location":"#lodstorage.cache.CacheManager.base_path","title":"<code>base_path()</code>","text":"<p>Fetches the base path for this cache manager.</p> <p>Parameters:</p> Name Type Description Default <code>cache</code> <p>The cache for which to generate the file path.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The base path</p> Source code in <code>lodstorage/cache.py</code> <pre><code>def base_path(self) -&gt; str:\n    \"\"\"Fetches the base path for this cache manager.\n\n    Args:\n        cache: The cache for which to generate the file path.\n\n    Returns:\n        The base path\n    \"\"\"\n    if self.base_dir is None:\n        self.base_dir = os.path.expanduser(\"~\")\n    base_path = os.path.join(self.base_dir, f\".{self.name}\")\n    os.makedirs(base_path, exist_ok=True)\n    return base_path\n</code></pre>"},{"location":"#lodstorage.cache.CacheManager.get_cache_by_name","title":"<code>get_cache_by_name(lod_name, ext='.json')</code>","text":"<p>Retrieves or creates a cache object by name and extension.</p> <p>Parameters:</p> Name Type Description Default <code>cache_name</code> <code>str</code> <p>The name of the cache to retrieve or create.</p> required <code>ext</code> <code>str</code> <p>The file extension for the cache.</p> <code>'.json'</code> <p>Returns:</p> Name Type Description <code>Cache</code> <code>Cache</code> <p>An existing or newly created Cache object.</p> Source code in <code>lodstorage/cache.py</code> <pre><code>def get_cache_by_name(self, lod_name, ext=\".json\") -&gt; Cache:\n    \"\"\"\n    Retrieves or creates a cache object by name and extension.\n\n    Args:\n        cache_name (str): The name of the cache to retrieve or create.\n        ext (str): The file extension for the cache.\n\n    Returns:\n        Cache: An existing or newly created Cache object.\n    \"\"\"\n    if lod_name in self.caches:\n        cache = self.caches[lod_name + ext]\n    else:\n        cache = Cache(lod_name, ext)\n        self.caches[lod_name + ext] = cache\n    base_path = self.base_path()\n    cache.set_path(base_path)\n    return cache\n</code></pre>"},{"location":"#lodstorage.cache.CacheManager.load","title":"<code>load(lod_name, ext='.json', cls=None, count_attr=None)</code>","text":"<p>Load data from a cache file. This method supports JSON and, if a relevant class is provided, other formats like YAML.</p> <p>Parameters:</p> Name Type Description Default <code>lod_name</code> <code>str</code> <p>The name of the list of dicts or class instances to read from cache.</p> required <code>ext</code> <code>str</code> <p>The extension of the cache file, indicating the format (default is \".json\").</p> <code>'.json'</code> <code>cls</code> <code>Optional[Type[YamlAble]]</code> <p>The class type for deserialization. This class must have from_json() or from_yaml()                              class methods for deserialization, depending on the file extension.</p> <code>None</code> <code>count_attr(str)</code> <p>the name of attribute data_to_store for updating the cache.count s</p> required <p>Returns:     Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.</p> Source code in <code>lodstorage/cache.py</code> <pre><code>def load(\n    self,\n    lod_name: str,\n    ext: str = \".json\",\n    cls: Optional[Type[YamlAble]] = None,\n    count_attr: str = None,\n) -&gt; Union[List, Dict, None]:\n    \"\"\"\n    Load data from a cache file. This method supports JSON and, if a relevant class is provided, other formats like YAML.\n\n    Args:\n        lod_name (str): The name of the list of dicts or class instances to read from cache.\n        ext (str): The extension of the cache file, indicating the format (default is \".json\").\n        cls (Optional[Type[YamlAble]]): The class type for deserialization. This class must have from_json() or from_yaml()\n                                         class methods for deserialization, depending on the file extension.\n        count_attr(str): the name of attribute data_to_store for updating the cache.count s\n    Returns:\n        Union[List, Dict, None]: A list of dicts, a list of class instances, a single dict, or None if the cache is not stored.\n    \"\"\"\n    cache = self.get_cache_by_name(lod_name, ext)\n    cache.count_attr = count_attr\n    result = None\n    if cache.is_stored:\n        if ext == \".json\":\n            if cls and hasattr(cls, \"load_from_yaml_file\"):\n                result = cls.load_from_json_file(\n                    cache.path\n                )  # Adjusted for class method\n            else:\n                with open(cache.path, encoding=\"utf-8\") as json_file:\n                    result = orjson.loads(json_file.read())\n        elif ext == \".yaml\":\n            if cls and hasattr(cls, \"load_from_yaml_file\"):\n                result = cls.load_from_yaml_file(\n                    cache.path\n                )  # Adjusted for class method\n            else:\n                raise ValueError(\n                    \"YAML deserialization requires a cls parameter that is a subclass of YamlAble.\"\n                )\n        else:\n            raise ValueError(f\"Unsupported file extension {ext} for loading.\")\n\n        # Dynamic count update based on count_attr if applicable\n        if count_attr and hasattr(result, count_attr):\n            cache.count = len(getattr(result, count_attr))\n        elif isinstance(result, list):\n            cache.count = len(result)\n\n    return result\n</code></pre>"},{"location":"#lodstorage.cache.CacheManager.store","title":"<code>store(cache_name, data_to_store, ext='.json', count_attr=None)</code>","text":"<p>Stores data into a cache file, handling serialization based on the specified file extension. Supports JSON and YAML formats, and custom serialization for classes that provide specific serialization methods.</p> <p>Parameters:</p> Name Type Description Default <code>cache_name</code> <code>str</code> <p>The identifier for the cache where the data will be stored.</p> required <code>data_to_store</code> <code>Union[List, Dict]</code> <p>The data to be stored in the cache. This can be a list of dictionaries,                                a single dictionary, or instances of data classes if <code>cls</code> is provided.</p> required <code>ext</code> <code>str</code> <p>The file extension indicating the serialization format (e.g., '.json', '.yaml').        Defaults to '.json'.</p> <code>'.json'</code> <code>count_attr(str)</code> <p>the name of attribute data_to_store for updating the cache.count s</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is unsupported or if required methods for serialization are not implemented in <code>cls</code>.</p> Source code in <code>lodstorage/cache.py</code> <pre><code>def store(\n    self,\n    cache_name: str,\n    data_to_store: Union[List, Dict],\n    ext: str = \".json\",\n    count_attr: str = None,\n) -&gt; Cache:\n    \"\"\"\n    Stores data into a cache file, handling serialization based on the specified file extension.\n    Supports JSON and YAML formats, and custom serialization for classes that provide specific\n    serialization methods.\n\n    Args:\n        cache_name (str): The identifier for the cache where the data will be stored.\n        data_to_store (Union[List, Dict]): The data to be stored in the cache. This can be a list of dictionaries,\n                                           a single dictionary, or instances of data classes if `cls` is provided.\n        ext (str): The file extension indicating the serialization format (e.g., '.json', '.yaml').\n                   Defaults to '.json'.\n        count_attr(str): the name of attribute data_to_store for updating the cache.count s\n\n    Raises:\n        ValueError: If the file extension is unsupported or if required methods for serialization are not implemented in `cls`.\n    \"\"\"\n    cache = self.get_cache_by_name(cache_name, ext)\n    cache.count_attr = count_attr\n    cache.set_path(self.base_path())\n\n    if ext == \".json\":\n        # Check if  cls has a method `save_to_json_file`\n        # that accepts a file path and data to store\n        if isinstance(data_to_store, list):\n            json_str = orjson.dumps(data_to_store, option=orjson.OPT_INDENT_2)\n            with cache.path.open(\"wb\") as json_file:\n                json_file.write(json_str)\n        else:\n            if hasattr(data_to_store, \"save_to_json_file\"):\n                data_to_store.save_to_json_file(str(cache.path))\n            else:\n                raise ValueError(\n                    \"JSON serialization requires a 'save_to_json_file' method\"\n                )\n    elif ext == \".yaml\":\n        if hasattr(data_to_store, \"save_to_yaml_file\"):\n            # Assuming cls has a method `save_to_yaml_file` that accepts a file path and data to store\n            data_to_store.save_to_yaml_file(str(cache.path))\n        else:\n            raise ValueError(\n                \"YAML serialization requires a 'save_to_yaml_file' method.\"\n            )\n    else:\n        raise ValueError(f\"Unsupported file extension {ext}.\")\n\n    # Update cache metadata post storing\n    if count_attr and hasattr(data_to_store, count_attr):\n        cache.count = len(getattr(data_to_store, count_attr))\n    elif isinstance(data_to_store, list):\n        cache.count = len(data_to_store)\n\n    return cache\n</code></pre>"},{"location":"#lodstorage.docstring_parser","title":"<code>docstring_parser</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.docstring_parser.DocstringParser","title":"<code>DocstringParser</code>","text":"<p>A Python docstring parser.</p> Source code in <code>lodstorage/docstring_parser.py</code> <pre><code>class DocstringParser:\n    \"\"\"\n    A Python docstring parser.\n    \"\"\"\n\n    def __init__(self):\n        # Define basic elements\n        identifier = Word(alphas, alphanums + \"_\")\n        type_identifier = Word(alphas, alphanums + \"_.[]\")\n        description = restOfLine\n\n        # Define patterns for capturing attributes\n        attribute_start = Suppress(Literal(\"Attributes:\"))\n        self.attribute = Group(\n            identifier(\"name\")\n            + Suppress(\"(\")\n            + Optional(type_identifier(\"type\"))\n            + Suppress(\"):\")\n            + description(\"description\")\n        )\n\n        # Define pattern for class docstring\n        class_docstring = restOfLine(\"class_description\") + Optional(\n            attribute_start + OneOrMore(self.attribute)(\"attributes\")\n        )\n\n        # Updated class_docstring pattern to correctly handle multi-line class descriptions\n        self.class_docstring = class_docstring + Optional(\n            OneOrMore(~attribute_start + restOfLine)(\"class_description\")\n            + attribute_start\n            + OneOrMore(self.attribute)(\"attributes\")\n        )\n\n    def parse(self, docstring: str):\n        \"\"\"\n        Parse the given docstring.\n        \"\"\"\n        result = self.class_docstring.parseString(docstring, parseAll=True)\n        class_description = \" \".join(result.class_description).strip()\n        attributes = {\n            attr.name: {\"type\": attr.type, \"description\": attr.description.strip()}\n            for attr in result.attributes\n        }\n        return class_description, attributes\n</code></pre>"},{"location":"#lodstorage.docstring_parser.DocstringParser.parse","title":"<code>parse(docstring)</code>","text":"<p>Parse the given docstring.</p> Source code in <code>lodstorage/docstring_parser.py</code> <pre><code>def parse(self, docstring: str):\n    \"\"\"\n    Parse the given docstring.\n    \"\"\"\n    result = self.class_docstring.parseString(docstring, parseAll=True)\n    class_description = \" \".join(result.class_description).strip()\n    attributes = {\n        attr.name: {\"type\": attr.type, \"description\": attr.description.strip()}\n        for attr in result.attributes\n    }\n    return class_description, attributes\n</code></pre>"},{"location":"#lodstorage.entity","title":"<code>entity</code>","text":"<p>Created on 2020-08-19</p> <p>@author: wf</p>"},{"location":"#lodstorage.entity.EntityManager","title":"<code>EntityManager</code>","text":"<p>               Bases: <code>YamlAbleMixin</code>, <code>JsonPickleMixin</code>, <code>JSONAbleList</code></p> <p>generic entity manager</p> Source code in <code>lodstorage/entity.py</code> <pre><code>class EntityManager(YamlAbleMixin, JsonPickleMixin, JSONAbleList):\n    \"\"\"\n    generic entity manager\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        entityName,\n        entityPluralName: str,\n        listName: str = None,\n        clazz=None,\n        tableName: str = None,\n        primaryKey: str = None,\n        config=None,\n        handleInvalidListTypes=False,\n        filterInvalidListTypes=False,\n        listSeparator=\"\u21f9\",\n        debug=False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            name(string): name of this eventManager\n            entityName(string): entityType to be managed e.g. Country\n            entityPluralName(string): plural of the the entityType e.g. Countries\n            config(StorageConfig): the configuration to be used if None a default configuration will be used\n            handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n            filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n            listSeparator(str): the symbol to use as a list separator\n            debug(boolean): override debug setting when default of config is used via config=None\n        \"\"\"\n        self.name = name\n        self.entityName = entityName\n        self.entityPluralName = entityPluralName\n        if listName is None:\n            listName = entityPluralName\n        if tableName is None:\n            tableName = entityName\n        self.primaryKey = primaryKey\n        if config is None:\n            config = StorageConfig.getDefault()\n            if debug:\n                config.debug = debug\n        self.config = config\n        super(EntityManager, self).__init__(\n            listName=listName,\n            clazz=clazz,\n            tableName=tableName,\n            handleInvalidListTypes=handleInvalidListTypes,\n            filterInvalidListTypes=filterInvalidListTypes,\n        )\n        cacheFile = self.getCacheFile(config=config, mode=config.mode)\n        self.showProgress(\n            \"Creating %smanager(%s) for %s using cache %s\"\n            % (self.entityName, config.mode, self.name, cacheFile)\n        )\n        if config.mode is StoreMode.SPARQL:\n            if config.endpoint is None:\n                raise Exception(\"no endpoint set for mode sparql\")\n            self.endpoint = config.endpoint\n            self.sparql = SPARQL(\n                config.endpoint, debug=config.debug, profile=config.profile\n            )\n        elif config.mode is StoreMode.SQL:\n            self.executeMany = False  # may be True when issues are fixed\n        self.listSeparator = listSeparator\n\n    def storeMode(self):\n        \"\"\"\n        return my store mode\n        \"\"\"\n        return self.config.mode\n\n    def showProgress(self, msg):\n        \"\"\"display a progress message\n\n        Args:\n          msg(string): the message to display\n        \"\"\"\n        if self.config.withShowProgress:\n            print(msg, flush=True)\n\n    def getCacheFile(self, config=None, mode=StoreMode.SQL):\n        \"\"\"\n        get the cache file for this event manager\n        Args:\n            config(StorageConfig): if None get the cache for my mode\n            mode(StoreMode): the storeMode to use\n        \"\"\"\n        if config is None:\n            config = self.config\n        cachedir = config.getCachePath()\n        if config.cacheFile is not None:\n            return config.cacheFile\n        \"\"\" get the path to the file for my cached data \"\"\"\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            extension = f\".{mode.name.lower()}\"\n            cachepath = f\"{cachedir}/{self.name}-{self.listName}{extension}\"\n        elif mode is StoreMode.SPARQL:\n            cachepath = f\"SPAQRL {self.name}:{config.endpoint}\"\n        elif mode is StoreMode.SQL:\n            cachepath = f\"{cachedir}/{self.name}.db\"\n        else:\n            cachepath = f\"undefined cachepath for StoreMode {mode}\"\n        return cachepath\n\n    def removeCacheFile(self):\n        \"\"\"remove my cache file\"\"\"\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            cacheFile = self.getCacheFile(mode=mode)\n            if os.path.isfile(cacheFile):\n                os.remove(cacheFile)\n\n    def getSQLDB(self, cacheFile):\n        \"\"\"\n        get the SQL database for the given cacheFile\n\n        Args:\n            cacheFile(string): the file to get the SQL db from\n        \"\"\"\n        config = self.config\n        sqldb = self.sqldb = SQLDB(\n            cacheFile, debug=config.debug, errorDebug=config.errorDebug\n        )\n        return sqldb\n\n    def initSQLDB(\n        self,\n        sqldb,\n        listOfDicts=None,\n        withCreate: bool = True,\n        withDrop: bool = True,\n        sampleRecordCount=-1,\n    ):\n        \"\"\"\n        initialize my sql DB\n\n        Args:\n            listOfDicts(list): the list of dicts to analyze for type information\n            withDrop(boolean): true if the existing Table should be dropped\n            withCreate(boolean): true if the create Table command should be executed - false if only the entityInfo should be returned\n            sampleRecordCount(int): the number of records to analyze for type information\n        Return:\n            EntityInfo: the entity information such as CREATE Table command\n        \"\"\"\n        if listOfDicts is None:\n            listOfDicts = JSONAble.getJsonTypeSamplesForClass(self.clazz)\n        entityInfo = sqldb.createTable(\n            listOfDicts,\n            self.tableName,\n            primaryKey=self.primaryKey,\n            withCreate=withCreate,\n            withDrop=withDrop,\n            sampleRecordCount=sampleRecordCount,\n        )\n        return entityInfo\n\n    def setNone(self, record, fields):\n        \"\"\"\n        make sure the given fields in the given record are set to none\n        Args:\n            record(dict): the record to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        LOD.setNone(record, fields)\n\n    def isCached(self):\n        \"\"\"check whether there is a file containing cached\n        data for me\"\"\"\n        result = False\n        config = self.config\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            result = os.path.isfile(self.getCacheFile(config=self.config, mode=mode))\n        elif mode is StoreMode.SPARQL:\n            # @FIXME - make abstract\n            query = (\n                config.prefix\n                + \"\"\"\nSELECT  ?source (COUNT(?source) AS ?sourcecount)\nWHERE { \n   ?event cr:Event_source ?source.\n}\nGROUP by ?source\n\"\"\"\n            )\n            sourceCountList = self.sparql.queryAsListOfDicts(query)\n            for sourceCount in sourceCountList:\n                source = sourceCount[\"source\"]\n                recordCount = sourceCount[\"sourcecount\"]\n                if source == self.name and recordCount &gt; 100:\n                    result = True\n        elif mode is StoreMode.SQL:\n            cacheFile = self.getCacheFile(config=self.config, mode=StoreMode.SQL)\n            if os.path.isfile(cacheFile):\n                sqlQuery = f\"SELECT COUNT(*) AS count FROM {self.tableName}\"\n                try:\n                    sqlDB = self.getSQLDB(cacheFile)\n                    countResults = sqlDB.query(sqlQuery)\n                    countResult = countResults[0]\n                    count = countResult[\"count\"]\n                    result = count &gt;= 0\n                except Exception as ex:\n                    msg = str(ex)\n                    if self.debug:\n                        print(msg, file=sys.stderr)\n                        sys.stderr.flush()\n                    # e.g. sqlite3.OperationalError: no such table: Event_crossref\n                    pass\n        else:\n            raise Exception(\"unsupported mode %s\" % self.mode)\n        return result\n\n    def fromCache(\n        self,\n        force: bool = False,\n        getListOfDicts=None,\n        append=False,\n        sampleRecordCount=-1,\n    ):\n        \"\"\"\n        get my entries from the cache or from the callback provided\n\n        Args:\n            force(bool): force ignoring the cache\n            getListOfDicts(callable): a function to call for getting the data\n            append(bool): True if records should be appended\n            sampleRecordCount(int): the number of records to analyze for type information\n\n        Returns:\n            the list of Dicts and as a side effect setting self.cacheFile\n        \"\"\"\n        if not self.isCached() or force:\n            startTime = time.time()\n            self.showProgress(f\"getting {self.entityPluralName} for {self.name} ...\")\n            if getListOfDicts is None:\n                if hasattr(self, \"getListOfDicts\"):\n                    getListOfDicts = self.getListOfDicts\n                else:\n                    raise Exception(\n                        \"from Cache failed and no secondary cache via getListOfDicts specified\"\n                    )\n            listOfDicts = getListOfDicts()\n            duration = time.time() - startTime\n            self.showProgress(\n                f\"got {len(listOfDicts)} {self.entityPluralName} in {duration:5.1f} s\"\n            )\n            self.cacheFile = self.storeLoD(\n                listOfDicts, append=append, sampleRecordCount=sampleRecordCount\n            )\n            self.setListFromLoD(listOfDicts)\n        else:\n            # fromStore also sets self.cacheFile\n            listOfDicts = self.fromStore()\n        return listOfDicts\n\n    def fromStore(self, cacheFile=None, setList: bool = True) -&gt; list:\n        \"\"\"\n        restore me from the store\n        Args:\n            cacheFile(String): the cacheFile to use if None use the pre configured cachefile\n            setList(bool): if True set my list with the data from the cache file\n\n        Returns:\n            list: list of dicts or JSON entitymanager\n        \"\"\"\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        self.cacheFile = cacheFile\n        self.showProgress(\n            \"reading %s for %s from cache %s\"\n            % (self.entityPluralName, self.name, cacheFile)\n        )\n        mode = self.config.mode\n        if mode is StoreMode.JSONPICKLE:\n            JSONem = JsonPickleMixin.readJsonPickle(cacheFile)\n            if self.clazz is not None:\n                listOfDicts = JSONem.getLoD()\n            else:\n                listOfDicts = JSONem.getList()\n        elif mode is StoreMode.JSON:\n            listOfDicts = self.readLodFromJsonFile(cacheFile)\n            pass\n        elif mode is StoreMode.SPARQL:\n            # @FIXME make abstract\n            eventQuery = (\n                \"\"\"\nPREFIX cr: &lt;http://cr.bitplan.com/&gt;\nSELECT ?eventId ?acronym ?series ?title ?year ?country ?city ?startDate ?endDate ?url ?source WHERE { \n   OPTIONAL { ?event cr:Event_eventId ?eventId. }\n   OPTIONAL { ?event cr:Event_acronym ?acronym. }\n   OPTIONAL { ?event cr:Event_series ?series. }\n   OPTIONAL { ?event cr:Event_title ?title. }\n   OPTIONAL { ?event cr:Event_year ?year.  }\n   OPTIONAL { ?event cr:Event_country ?country. }\n   OPTIONAL { ?event cr:Event_city ?city. }\n   OPTIONAL { ?event cr:Event_startDate ?startDate. }\n   OPTIONAL { ?event cr:Event_endDate ?endDate. }\n   OPTIONAL { ?event cr:Event_url ?url. }\n   ?event cr:Event_source ?source FILTER(?source='%s').\n}\n\"\"\"\n                % self.name\n            )\n            listOfDicts = self.sparql.queryAsListOfDicts(eventQuery)\n        elif mode is StoreMode.SQL:\n            sqlQuery = \"SELECT * FROM %s\" % self.tableName\n            sqlDB = self.getSQLDB(cacheFile)\n            listOfDicts = sqlDB.query(sqlQuery)\n            sqlDB.close()\n            pass\n        else:\n            raise Exception(\"unsupported store mode %s\" % self.mode)\n\n        self.showProgress(\n            \"read %d %s from %s in %5.1f s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                time.time() - startTime,\n            )\n        )\n        if setList:\n            self.setListFromLoD(listOfDicts)\n        return listOfDicts\n\n    def getLoD(self):\n        \"\"\"\n        Return the LoD of the entities in the list\n\n        Return:\n            list: a list of Dicts\n\n        \"\"\"\n        lod = []\n        for entity in self.getList():\n            # TODO - optionally filter by samples\n            lod.append(entity.__dict__)\n        return lod\n\n    def store(\n        self,\n        limit=10000000,\n        batchSize=250,\n        append=False,\n        fixNone=True,\n        sampleRecordCount=-1,\n        replace: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        store my list of dicts\n\n        Args:\n            limit(int): maximum number of records to store per batch\n            batchSize(int): size of batch for storing\n            append(bool): True if records should be appended\n            fixNone(bool): if True make sure the dicts are filled with None references for each record\n            sampleRecordCount(int): the number of records to analyze for type information\n            replace(bool): if True allow replace for insert\n\n        Return:\n            str: The cachefile being used\n        \"\"\"\n        lod = self.getLoD()\n        return self.storeLoD(\n            lod,\n            limit=limit,\n            batchSize=batchSize,\n            append=append,\n            fixNone=fixNone,\n            sampleRecordCount=sampleRecordCount,\n            replace=replace,\n        )\n\n    def storeLoD(\n        self,\n        listOfDicts,\n        limit=10000000,\n        batchSize=250,\n        cacheFile=None,\n        append=False,\n        fixNone=True,\n        sampleRecordCount=1,\n        replace: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        store my entities\n\n        Args:\n            listOfDicts(list): the list of dicts to store\n            limit(int): maximum number of records to store\n            batchSize(int): size of batch for storing\n            cacheFile(string): the name of the storage e.g path to JSON or sqlite3 file\n            append(bool): True if records should be appended\n            fixNone(bool): if True make sure the dicts are filled with None references for each record\n            sampleRecordCount(int): the number of records to analyze for type information\n            replace(bool): if True allow replace for insert\n        Return:\n            str: The cachefile being used\n        \"\"\"\n        config = self.config\n        mode = config.mode\n        if self.handleInvalidListTypes:\n            LOD.handleListTypes(\n                lod=listOfDicts,\n                doFilter=self.filterInvalidListTypes,\n                separator=self.listSeparator,\n            )\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            if cacheFile is None:\n                cacheFile = self.getCacheFile(config=self.config, mode=mode)\n            self.showProgress(\n                f\"storing {len(listOfDicts)} {self.entityPluralName} for {self.name} to cache {cacheFile}\"\n            )\n            if mode is StoreMode.JSONPICKLE:\n                self.writeJsonPickle(cacheFile)\n            if mode is StoreMode.JSON:\n                self.storeToJsonFile(cacheFile)\n                pass\n        elif mode is StoreMode.SPARQL:\n            startTime = time.time()\n            msg = f\"storing {len(listOfDicts)} {self.entityPluralName} to {self.config.mode} ({self.config.endpoint})\"\n            self.showProgress(msg)\n            # @ FIXME make abstract /configurable\n            entityType = \"cr:Event\"\n            prefixes = self.config.prefix\n            self.sparql.insertListOfDicts(\n                listOfDicts,\n                entityType,\n                self.primaryKey,\n                prefixes,\n                limit=limit,\n                batchSize=batchSize,\n            )\n            self.showProgress(\n                \"store for %s done after %5.1f secs\"\n                % (self.name, time.time() - startTime)\n            )\n        elif mode is StoreMode.SQL:\n            startTime = time.time()\n            if cacheFile is None:\n                cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n            sqldb = self.getSQLDB(cacheFile)\n            self.showProgress(\n                \"storing %d %s for %s to %s:%s\"\n                % (\n                    len(listOfDicts),\n                    self.entityPluralName,\n                    self.name,\n                    config.mode,\n                    cacheFile,\n                )\n            )\n            if append:\n                withDrop = False\n                withCreate = False\n            else:\n                withDrop = True\n                withCreate = True\n            entityInfo = self.initSQLDB(\n                sqldb,\n                listOfDicts,\n                withCreate=withCreate,\n                withDrop=withDrop,\n                sampleRecordCount=sampleRecordCount,\n            )\n            self.sqldb.store(\n                listOfDicts,\n                entityInfo,\n                executeMany=self.executeMany,\n                fixNone=fixNone,\n                replace=replace,\n            )\n            self.showProgress(\n                \"store for %s done after %5.1f secs\"\n                % (self.name, time.time() - startTime)\n            )\n        else:\n            raise Exception(f\"unsupported store mode {self.mode}\")\n        return cacheFile\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.__init__","title":"<code>__init__(name, entityName, entityPluralName, listName=None, clazz=None, tableName=None, primaryKey=None, config=None, handleInvalidListTypes=False, filterInvalidListTypes=False, listSeparator='\u21f9', debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(string)</code> <p>name of this eventManager</p> required <code>entityName(string)</code> <p>entityType to be managed e.g. Country</p> required <code>entityPluralName(string)</code> <p>plural of the the entityType e.g. Countries</p> required <code>config(StorageConfig)</code> <p>the configuration to be used if None a default configuration will be used</p> required <code>handleInvalidListTypes(bool)</code> <p>True if invalidListTypes should be converted or filtered</p> required <code>filterInvalidListTypes(bool)</code> <p>True if invalidListTypes should be deleted</p> required <code>listSeparator(str)</code> <p>the symbol to use as a list separator</p> required <code>debug(boolean)</code> <p>override debug setting when default of config is used via config=None</p> required Source code in <code>lodstorage/entity.py</code> <pre><code>def __init__(\n    self,\n    name,\n    entityName,\n    entityPluralName: str,\n    listName: str = None,\n    clazz=None,\n    tableName: str = None,\n    primaryKey: str = None,\n    config=None,\n    handleInvalidListTypes=False,\n    filterInvalidListTypes=False,\n    listSeparator=\"\u21f9\",\n    debug=False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        name(string): name of this eventManager\n        entityName(string): entityType to be managed e.g. Country\n        entityPluralName(string): plural of the the entityType e.g. Countries\n        config(StorageConfig): the configuration to be used if None a default configuration will be used\n        handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n        filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n        listSeparator(str): the symbol to use as a list separator\n        debug(boolean): override debug setting when default of config is used via config=None\n    \"\"\"\n    self.name = name\n    self.entityName = entityName\n    self.entityPluralName = entityPluralName\n    if listName is None:\n        listName = entityPluralName\n    if tableName is None:\n        tableName = entityName\n    self.primaryKey = primaryKey\n    if config is None:\n        config = StorageConfig.getDefault()\n        if debug:\n            config.debug = debug\n    self.config = config\n    super(EntityManager, self).__init__(\n        listName=listName,\n        clazz=clazz,\n        tableName=tableName,\n        handleInvalidListTypes=handleInvalidListTypes,\n        filterInvalidListTypes=filterInvalidListTypes,\n    )\n    cacheFile = self.getCacheFile(config=config, mode=config.mode)\n    self.showProgress(\n        \"Creating %smanager(%s) for %s using cache %s\"\n        % (self.entityName, config.mode, self.name, cacheFile)\n    )\n    if config.mode is StoreMode.SPARQL:\n        if config.endpoint is None:\n            raise Exception(\"no endpoint set for mode sparql\")\n        self.endpoint = config.endpoint\n        self.sparql = SPARQL(\n            config.endpoint, debug=config.debug, profile=config.profile\n        )\n    elif config.mode is StoreMode.SQL:\n        self.executeMany = False  # may be True when issues are fixed\n    self.listSeparator = listSeparator\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.fromCache","title":"<code>fromCache(force=False, getListOfDicts=None, append=False, sampleRecordCount=-1)</code>","text":"<p>get my entries from the cache or from the callback provided</p> <p>Parameters:</p> Name Type Description Default <code>force(bool)</code> <p>force ignoring the cache</p> required <code>getListOfDicts(callable)</code> <p>a function to call for getting the data</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <p>Returns:</p> Type Description <p>the list of Dicts and as a side effect setting self.cacheFile</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def fromCache(\n    self,\n    force: bool = False,\n    getListOfDicts=None,\n    append=False,\n    sampleRecordCount=-1,\n):\n    \"\"\"\n    get my entries from the cache or from the callback provided\n\n    Args:\n        force(bool): force ignoring the cache\n        getListOfDicts(callable): a function to call for getting the data\n        append(bool): True if records should be appended\n        sampleRecordCount(int): the number of records to analyze for type information\n\n    Returns:\n        the list of Dicts and as a side effect setting self.cacheFile\n    \"\"\"\n    if not self.isCached() or force:\n        startTime = time.time()\n        self.showProgress(f\"getting {self.entityPluralName} for {self.name} ...\")\n        if getListOfDicts is None:\n            if hasattr(self, \"getListOfDicts\"):\n                getListOfDicts = self.getListOfDicts\n            else:\n                raise Exception(\n                    \"from Cache failed and no secondary cache via getListOfDicts specified\"\n                )\n        listOfDicts = getListOfDicts()\n        duration = time.time() - startTime\n        self.showProgress(\n            f\"got {len(listOfDicts)} {self.entityPluralName} in {duration:5.1f} s\"\n        )\n        self.cacheFile = self.storeLoD(\n            listOfDicts, append=append, sampleRecordCount=sampleRecordCount\n        )\n        self.setListFromLoD(listOfDicts)\n    else:\n        # fromStore also sets self.cacheFile\n        listOfDicts = self.fromStore()\n    return listOfDicts\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.fromStore","title":"<code>fromStore(cacheFile=None, setList=True)</code>","text":"<p>restore me from the store Args:     cacheFile(String): the cacheFile to use if None use the pre configured cachefile     setList(bool): if True set my list with the data from the cache file</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of dicts or JSON entitymanager</p> Source code in <code>lodstorage/entity.py</code> <pre><code>    def fromStore(self, cacheFile=None, setList: bool = True) -&gt; list:\n        \"\"\"\n        restore me from the store\n        Args:\n            cacheFile(String): the cacheFile to use if None use the pre configured cachefile\n            setList(bool): if True set my list with the data from the cache file\n\n        Returns:\n            list: list of dicts or JSON entitymanager\n        \"\"\"\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        self.cacheFile = cacheFile\n        self.showProgress(\n            \"reading %s for %s from cache %s\"\n            % (self.entityPluralName, self.name, cacheFile)\n        )\n        mode = self.config.mode\n        if mode is StoreMode.JSONPICKLE:\n            JSONem = JsonPickleMixin.readJsonPickle(cacheFile)\n            if self.clazz is not None:\n                listOfDicts = JSONem.getLoD()\n            else:\n                listOfDicts = JSONem.getList()\n        elif mode is StoreMode.JSON:\n            listOfDicts = self.readLodFromJsonFile(cacheFile)\n            pass\n        elif mode is StoreMode.SPARQL:\n            # @FIXME make abstract\n            eventQuery = (\n                \"\"\"\nPREFIX cr: &lt;http://cr.bitplan.com/&gt;\nSELECT ?eventId ?acronym ?series ?title ?year ?country ?city ?startDate ?endDate ?url ?source WHERE { \n   OPTIONAL { ?event cr:Event_eventId ?eventId. }\n   OPTIONAL { ?event cr:Event_acronym ?acronym. }\n   OPTIONAL { ?event cr:Event_series ?series. }\n   OPTIONAL { ?event cr:Event_title ?title. }\n   OPTIONAL { ?event cr:Event_year ?year.  }\n   OPTIONAL { ?event cr:Event_country ?country. }\n   OPTIONAL { ?event cr:Event_city ?city. }\n   OPTIONAL { ?event cr:Event_startDate ?startDate. }\n   OPTIONAL { ?event cr:Event_endDate ?endDate. }\n   OPTIONAL { ?event cr:Event_url ?url. }\n   ?event cr:Event_source ?source FILTER(?source='%s').\n}\n\"\"\"\n                % self.name\n            )\n            listOfDicts = self.sparql.queryAsListOfDicts(eventQuery)\n        elif mode is StoreMode.SQL:\n            sqlQuery = \"SELECT * FROM %s\" % self.tableName\n            sqlDB = self.getSQLDB(cacheFile)\n            listOfDicts = sqlDB.query(sqlQuery)\n            sqlDB.close()\n            pass\n        else:\n            raise Exception(\"unsupported store mode %s\" % self.mode)\n\n        self.showProgress(\n            \"read %d %s from %s in %5.1f s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                time.time() - startTime,\n            )\n        )\n        if setList:\n            self.setListFromLoD(listOfDicts)\n        return listOfDicts\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.getCacheFile","title":"<code>getCacheFile(config=None, mode=StoreMode.SQL)</code>","text":"<p>get the cache file for this event manager Args:     config(StorageConfig): if None get the cache for my mode     mode(StoreMode): the storeMode to use</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def getCacheFile(self, config=None, mode=StoreMode.SQL):\n    \"\"\"\n    get the cache file for this event manager\n    Args:\n        config(StorageConfig): if None get the cache for my mode\n        mode(StoreMode): the storeMode to use\n    \"\"\"\n    if config is None:\n        config = self.config\n    cachedir = config.getCachePath()\n    if config.cacheFile is not None:\n        return config.cacheFile\n    \"\"\" get the path to the file for my cached data \"\"\"\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        extension = f\".{mode.name.lower()}\"\n        cachepath = f\"{cachedir}/{self.name}-{self.listName}{extension}\"\n    elif mode is StoreMode.SPARQL:\n        cachepath = f\"SPAQRL {self.name}:{config.endpoint}\"\n    elif mode is StoreMode.SQL:\n        cachepath = f\"{cachedir}/{self.name}.db\"\n    else:\n        cachepath = f\"undefined cachepath for StoreMode {mode}\"\n    return cachepath\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.getLoD","title":"<code>getLoD()</code>","text":"<p>Return the LoD of the entities in the list</p> Return <p>list: a list of Dicts</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def getLoD(self):\n    \"\"\"\n    Return the LoD of the entities in the list\n\n    Return:\n        list: a list of Dicts\n\n    \"\"\"\n    lod = []\n    for entity in self.getList():\n        # TODO - optionally filter by samples\n        lod.append(entity.__dict__)\n    return lod\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.getSQLDB","title":"<code>getSQLDB(cacheFile)</code>","text":"<p>get the SQL database for the given cacheFile</p> <p>Parameters:</p> Name Type Description Default <code>cacheFile(string)</code> <p>the file to get the SQL db from</p> required Source code in <code>lodstorage/entity.py</code> <pre><code>def getSQLDB(self, cacheFile):\n    \"\"\"\n    get the SQL database for the given cacheFile\n\n    Args:\n        cacheFile(string): the file to get the SQL db from\n    \"\"\"\n    config = self.config\n    sqldb = self.sqldb = SQLDB(\n        cacheFile, debug=config.debug, errorDebug=config.errorDebug\n    )\n    return sqldb\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.initSQLDB","title":"<code>initSQLDB(sqldb, listOfDicts=None, withCreate=True, withDrop=True, sampleRecordCount=-1)</code>","text":"<p>initialize my sql DB</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of dicts to analyze for type information</p> required <code>withDrop(boolean)</code> <p>true if the existing Table should be dropped</p> required <code>withCreate(boolean)</code> <p>true if the create Table command should be executed - false if only the entityInfo should be returned</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <p>Return:     EntityInfo: the entity information such as CREATE Table command</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def initSQLDB(\n    self,\n    sqldb,\n    listOfDicts=None,\n    withCreate: bool = True,\n    withDrop: bool = True,\n    sampleRecordCount=-1,\n):\n    \"\"\"\n    initialize my sql DB\n\n    Args:\n        listOfDicts(list): the list of dicts to analyze for type information\n        withDrop(boolean): true if the existing Table should be dropped\n        withCreate(boolean): true if the create Table command should be executed - false if only the entityInfo should be returned\n        sampleRecordCount(int): the number of records to analyze for type information\n    Return:\n        EntityInfo: the entity information such as CREATE Table command\n    \"\"\"\n    if listOfDicts is None:\n        listOfDicts = JSONAble.getJsonTypeSamplesForClass(self.clazz)\n    entityInfo = sqldb.createTable(\n        listOfDicts,\n        self.tableName,\n        primaryKey=self.primaryKey,\n        withCreate=withCreate,\n        withDrop=withDrop,\n        sampleRecordCount=sampleRecordCount,\n    )\n    return entityInfo\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.isCached","title":"<code>isCached()</code>","text":"<p>check whether there is a file containing cached data for me</p> Source code in <code>lodstorage/entity.py</code> <pre><code>    def isCached(self):\n        \"\"\"check whether there is a file containing cached\n        data for me\"\"\"\n        result = False\n        config = self.config\n        mode = self.config.mode\n        if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n            result = os.path.isfile(self.getCacheFile(config=self.config, mode=mode))\n        elif mode is StoreMode.SPARQL:\n            # @FIXME - make abstract\n            query = (\n                config.prefix\n                + \"\"\"\nSELECT  ?source (COUNT(?source) AS ?sourcecount)\nWHERE { \n   ?event cr:Event_source ?source.\n}\nGROUP by ?source\n\"\"\"\n            )\n            sourceCountList = self.sparql.queryAsListOfDicts(query)\n            for sourceCount in sourceCountList:\n                source = sourceCount[\"source\"]\n                recordCount = sourceCount[\"sourcecount\"]\n                if source == self.name and recordCount &gt; 100:\n                    result = True\n        elif mode is StoreMode.SQL:\n            cacheFile = self.getCacheFile(config=self.config, mode=StoreMode.SQL)\n            if os.path.isfile(cacheFile):\n                sqlQuery = f\"SELECT COUNT(*) AS count FROM {self.tableName}\"\n                try:\n                    sqlDB = self.getSQLDB(cacheFile)\n                    countResults = sqlDB.query(sqlQuery)\n                    countResult = countResults[0]\n                    count = countResult[\"count\"]\n                    result = count &gt;= 0\n                except Exception as ex:\n                    msg = str(ex)\n                    if self.debug:\n                        print(msg, file=sys.stderr)\n                        sys.stderr.flush()\n                    # e.g. sqlite3.OperationalError: no such table: Event_crossref\n                    pass\n        else:\n            raise Exception(\"unsupported mode %s\" % self.mode)\n        return result\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.removeCacheFile","title":"<code>removeCacheFile()</code>","text":"<p>remove my cache file</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def removeCacheFile(self):\n    \"\"\"remove my cache file\"\"\"\n    mode = self.config.mode\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        cacheFile = self.getCacheFile(mode=mode)\n        if os.path.isfile(cacheFile):\n            os.remove(cacheFile)\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.setNone","title":"<code>setNone(record, fields)</code>","text":"<p>make sure the given fields in the given record are set to none Args:     record(dict): the record to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def setNone(self, record, fields):\n    \"\"\"\n    make sure the given fields in the given record are set to none\n    Args:\n        record(dict): the record to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    LOD.setNone(record, fields)\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.showProgress","title":"<code>showProgress(msg)</code>","text":"<p>display a progress message</p> <p>Parameters:</p> Name Type Description Default <code>msg(string)</code> <p>the message to display</p> required Source code in <code>lodstorage/entity.py</code> <pre><code>def showProgress(self, msg):\n    \"\"\"display a progress message\n\n    Args:\n      msg(string): the message to display\n    \"\"\"\n    if self.config.withShowProgress:\n        print(msg, flush=True)\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.store","title":"<code>store(limit=10000000, batchSize=250, append=False, fixNone=True, sampleRecordCount=-1, replace=False)</code>","text":"<p>store my list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>limit(int)</code> <p>maximum number of records to store per batch</p> required <code>batchSize(int)</code> <p>size of batch for storing</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>fixNone(bool)</code> <p>if True make sure the dicts are filled with None references for each record</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <code>replace(bool)</code> <p>if True allow replace for insert</p> required Return <p>str: The cachefile being used</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def store(\n    self,\n    limit=10000000,\n    batchSize=250,\n    append=False,\n    fixNone=True,\n    sampleRecordCount=-1,\n    replace: bool = False,\n) -&gt; str:\n    \"\"\"\n    store my list of dicts\n\n    Args:\n        limit(int): maximum number of records to store per batch\n        batchSize(int): size of batch for storing\n        append(bool): True if records should be appended\n        fixNone(bool): if True make sure the dicts are filled with None references for each record\n        sampleRecordCount(int): the number of records to analyze for type information\n        replace(bool): if True allow replace for insert\n\n    Return:\n        str: The cachefile being used\n    \"\"\"\n    lod = self.getLoD()\n    return self.storeLoD(\n        lod,\n        limit=limit,\n        batchSize=batchSize,\n        append=append,\n        fixNone=fixNone,\n        sampleRecordCount=sampleRecordCount,\n        replace=replace,\n    )\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.storeLoD","title":"<code>storeLoD(listOfDicts, limit=10000000, batchSize=250, cacheFile=None, append=False, fixNone=True, sampleRecordCount=1, replace=False)</code>","text":"<p>store my entities</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of dicts to store</p> required <code>limit(int)</code> <p>maximum number of records to store</p> required <code>batchSize(int)</code> <p>size of batch for storing</p> required <code>cacheFile(string)</code> <p>the name of the storage e.g path to JSON or sqlite3 file</p> required <code>append(bool)</code> <p>True if records should be appended</p> required <code>fixNone(bool)</code> <p>if True make sure the dicts are filled with None references for each record</p> required <code>sampleRecordCount(int)</code> <p>the number of records to analyze for type information</p> required <code>replace(bool)</code> <p>if True allow replace for insert</p> required <p>Return:     str: The cachefile being used</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def storeLoD(\n    self,\n    listOfDicts,\n    limit=10000000,\n    batchSize=250,\n    cacheFile=None,\n    append=False,\n    fixNone=True,\n    sampleRecordCount=1,\n    replace: bool = False,\n) -&gt; str:\n    \"\"\"\n    store my entities\n\n    Args:\n        listOfDicts(list): the list of dicts to store\n        limit(int): maximum number of records to store\n        batchSize(int): size of batch for storing\n        cacheFile(string): the name of the storage e.g path to JSON or sqlite3 file\n        append(bool): True if records should be appended\n        fixNone(bool): if True make sure the dicts are filled with None references for each record\n        sampleRecordCount(int): the number of records to analyze for type information\n        replace(bool): if True allow replace for insert\n    Return:\n        str: The cachefile being used\n    \"\"\"\n    config = self.config\n    mode = config.mode\n    if self.handleInvalidListTypes:\n        LOD.handleListTypes(\n            lod=listOfDicts,\n            doFilter=self.filterInvalidListTypes,\n            separator=self.listSeparator,\n        )\n    if mode is StoreMode.JSON or mode is StoreMode.JSONPICKLE:\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=mode)\n        self.showProgress(\n            f\"storing {len(listOfDicts)} {self.entityPluralName} for {self.name} to cache {cacheFile}\"\n        )\n        if mode is StoreMode.JSONPICKLE:\n            self.writeJsonPickle(cacheFile)\n        if mode is StoreMode.JSON:\n            self.storeToJsonFile(cacheFile)\n            pass\n    elif mode is StoreMode.SPARQL:\n        startTime = time.time()\n        msg = f\"storing {len(listOfDicts)} {self.entityPluralName} to {self.config.mode} ({self.config.endpoint})\"\n        self.showProgress(msg)\n        # @ FIXME make abstract /configurable\n        entityType = \"cr:Event\"\n        prefixes = self.config.prefix\n        self.sparql.insertListOfDicts(\n            listOfDicts,\n            entityType,\n            self.primaryKey,\n            prefixes,\n            limit=limit,\n            batchSize=batchSize,\n        )\n        self.showProgress(\n            \"store for %s done after %5.1f secs\"\n            % (self.name, time.time() - startTime)\n        )\n    elif mode is StoreMode.SQL:\n        startTime = time.time()\n        if cacheFile is None:\n            cacheFile = self.getCacheFile(config=self.config, mode=self.config.mode)\n        sqldb = self.getSQLDB(cacheFile)\n        self.showProgress(\n            \"storing %d %s for %s to %s:%s\"\n            % (\n                len(listOfDicts),\n                self.entityPluralName,\n                self.name,\n                config.mode,\n                cacheFile,\n            )\n        )\n        if append:\n            withDrop = False\n            withCreate = False\n        else:\n            withDrop = True\n            withCreate = True\n        entityInfo = self.initSQLDB(\n            sqldb,\n            listOfDicts,\n            withCreate=withCreate,\n            withDrop=withDrop,\n            sampleRecordCount=sampleRecordCount,\n        )\n        self.sqldb.store(\n            listOfDicts,\n            entityInfo,\n            executeMany=self.executeMany,\n            fixNone=fixNone,\n            replace=replace,\n        )\n        self.showProgress(\n            \"store for %s done after %5.1f secs\"\n            % (self.name, time.time() - startTime)\n        )\n    else:\n        raise Exception(f\"unsupported store mode {self.mode}\")\n    return cacheFile\n</code></pre>"},{"location":"#lodstorage.entity.EntityManager.storeMode","title":"<code>storeMode()</code>","text":"<p>return my store mode</p> Source code in <code>lodstorage/entity.py</code> <pre><code>def storeMode(self):\n    \"\"\"\n    return my store mode\n    \"\"\"\n    return self.config.mode\n</code></pre>"},{"location":"#lodstorage.jsonable","title":"<code>jsonable</code>","text":"<p>This module has a class JSONAble for serialization of tables/list of dicts to and from JSON encoding</p> <p>Created on 2020-09-03</p> <p>@author: wf</p>"},{"location":"#lodstorage.jsonable.JSONAble","title":"<code>JSONAble</code>","text":"<p>               Bases: <code>object</code></p> <p>mixin to allow classes to be JSON serializable see</p> <ul> <li>https://stackoverflow.com/questions/3768895/how-to-make-a-class-json-serializable</li> </ul> Source code in <code>lodstorage/jsonable.py</code> <pre><code>class JSONAble(object):\n    \"\"\"\n    mixin to allow classes to be JSON serializable see\n\n    - https://stackoverflow.com/questions/3768895/how-to-make-a-class-json-serializable\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n\n    @classmethod\n    def getPluralname(cls):\n        return \"%ss\" % cls.__name__\n\n    @staticmethod\n    def singleQuoteToDoubleQuote(singleQuoted, useRegex=False):\n        \"\"\"\n        convert a single quoted string to a double quoted one\n\n        Args:\n            singleQuoted (str): a single quoted string e.g.\n\n                .. highlight:: json\n\n                {'cities': [{'name': \"Upper Hell's Gate\"}]}\n\n            useRegex (boolean): True if a regular expression shall be used for matching\n\n        Returns:\n            string: the double quoted version of the string\n\n        Note:\n            see\n            - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q\n\n        \"\"\"\n        if useRegex:\n            doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingRegex(singleQuoted)\n        else:\n            doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop(\n                singleQuoted\n            )\n        return doubleQuoted\n\n    @staticmethod\n    def singleQuoteToDoubleQuoteUsingRegex(singleQuoted):\n        \"\"\"\n        convert a single quoted string to a double quoted one using a regular expression\n\n        Args:\n            singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n            useRegex(boolean): True if a regular expression shall be used for matching\n        Returns:\n            string: the double quoted version of the string e.g.\n        Note:\n            see https://stackoverflow.com/a/50257217/1497139\n        \"\"\"\n        doubleQuoted = JSONAbleSettings.singleQuoteRegex.sub('\"', singleQuoted)\n        return doubleQuoted\n\n    @staticmethod\n    def singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted):\n        \"\"\"\n        convert a single quoted string to a double quoted one using a regular expression\n\n        Args:\n            singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n            useRegex(boolean): True if a regular expression shall be used for matching\n        Returns:\n            string: the double quoted version of the string e.g.\n        Note:\n            see https://stackoverflow.com/a/63862387/1497139\n\n        \"\"\"\n        cList = list(singleQuoted)\n        inDouble = False\n        inSingle = False\n        for i, c in enumerate(cList):\n            # print (\"%d:%s %r %r\" %(i,c,inSingle,inDouble))\n            if c == \"'\":\n                if not inDouble:\n                    inSingle = not inSingle\n                    cList[i] = '\"'\n            elif c == '\"':\n                inDouble = not inDouble\n                inSingle = False\n        doubleQuoted = \"\".join(cList)\n        return doubleQuoted\n\n    def getJsonTypeSamples(self):\n        \"\"\"\n        does my class provide a \"getSamples\" method?\n        \"\"\"\n        if hasattr(self, \"__class__\"):\n            cls = self.__class__\n            if isinstance(self, JSONAbleList) and not hasattr(cls, \"getSamples\"):\n                cls = self.clazz\n            return JSONAble.getJsonTypeSamplesForClass(cls)\n        return None\n\n    @staticmethod\n    def getJsonTypeSamplesForClass(cls):\n        \"\"\"\n        return the type samples for the given class\n\n        Return:\n            list: a list of dict that specify the types by example\n        \"\"\"\n        if hasattr(cls, \"getSamples\"):\n            getSamples = getattr(cls, \"getSamples\")\n            if callable(getSamples):\n                return getSamples()\n        return None\n\n    @staticmethod\n    def readJsonFromFile(jsonFilePath):\n        \"\"\"\n        read json string from the given jsonFilePath\n\n        Args:\n            jsonFilePath(string): the path of the file where to read the result from\n\n        Returns:\n            the JSON string read from the file\n        \"\"\"\n        with open(jsonFilePath, \"r\") as jsonFile:\n            jsonStr = jsonFile.read()\n        return jsonStr\n\n    @staticmethod\n    def storeJsonToFile(jsonStr, jsonFilePath):\n        \"\"\"\n        store the given json string to the given jsonFilePath\n\n        Args:\n            jsonStr(string): the string to store\n            jsonFilePath(string): the path of the file where to store the result\n\n        \"\"\"\n        with open(jsonFilePath, \"w\") as jsonFile:\n            jsonFile.write(jsonStr)\n\n    def checkExtension(self, jsonFile: str, extension: str = \".json\") -&gt; str:\n        \"\"\"\n        make sure the jsonFile has the given extension e.g. \".json\"\n\n        Args:\n            jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n        Returns:\n            str: the jsonFile name with \".json\" as an extension guaranteed\n        \"\"\"\n        if not jsonFile.endswith(extension):\n            jsonFile = f\"{jsonFile}{extension}\"\n        return jsonFile\n\n    def storeToJsonFile(\n        self, jsonFile: str, extension: str = \".json\", limitToSampleFields: bool = False\n    ):\n        \"\"\"\n        store me to the given jsonFile\n\n        Args:\n            jsonFile(str): the JSON file name (optionally without extension)\n            exension(str): the extension to use if not part of the jsonFile name\n            limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile, extension)\n        JSONAble.storeJsonToFile(self.toJSON(limitToSampleFields), jsonFile)\n\n    def restoreFromJsonFile(self, jsonFile: str):\n        \"\"\"\n        restore me from the given jsonFile\n\n        Args:\n            jsonFile(string): the jsonFile to restore me from\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile)\n        jsonStr = JSONAble.readJsonFromFile(jsonFile)\n        self.fromJson(jsonStr)\n\n    def fromJson(self, jsonStr):\n        \"\"\"\n        initialize me from the given JSON string\n\n        Args:\n            jsonStr(str): the JSON string\n        \"\"\"\n        jsonMap = json.loads(jsonStr)\n        self.fromDict(jsonMap)\n\n    def fromDict(self, data: dict):\n        \"\"\"\n        initialize me from the given data\n\n        Args:\n            data(dict): the dictionary to initialize me from\n        \"\"\"\n        # https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python-taking-union-o\n        for key in data.keys():\n            value = data[key]\n            setattr(self, key, value)\n\n    def toJsonAbleValue(self, v):\n        \"\"\"\n        return the JSON able value of the given value v\n        Args:\n            v(object): the value to convert\n        \"\"\"\n        # objects have __dict__ hash tables which can be JSON-converted\n        if hasattr(v, \"__dict__\"):\n            return v.__dict__\n        elif isinstance(v, datetime.datetime):\n            return v.isoformat()\n        elif isinstance(v, datetime.date):\n            return v.isoformat()\n        else:\n            return \"\"\n\n    def toJSON(self, limitToSampleFields: bool = False):\n        \"\"\"\n\n        Args:\n            limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n\n        Returns:\n            a recursive JSON dump of the dicts of my objects\n        \"\"\"\n        data = {}\n        if limitToSampleFields:\n            samples = self.getJsonTypeSamples()\n            sampleFields = LOD.getFields(samples)\n            if isinstance(self, JSONAbleList):\n                limitedRecords = []\n                for record in self.__dict__[self.listName]:\n                    limitedRecord = {}\n                    for key, value in record.__dict__.items():\n                        if key in sampleFields:\n                            limitedRecord[key] = value\n                    limitedRecords.append(limitedRecord)\n                data[self.listName] = limitedRecords\n            else:\n                for key, value in self.__dict__.items():\n                    if key in sampleFields:\n                        data[key] = value\n        else:\n            data = self\n        jsonStr = json.dumps(\n            data,\n            default=lambda v: self.toJsonAbleValue(v),\n            sort_keys=True,\n            indent=JSONAbleSettings.indent,\n        )\n        return jsonStr\n\n    def getJSONValue(self, v):\n        \"\"\"\n        get the value of the given v as JSON\n\n        Args:\n            v(object): the value to get\n\n        Returns:\n            the the value making sure objects are return as dicts\n        \"\"\"\n        if hasattr(v, \"asJSON\"):\n            return v.asJSON(asString=False)\n        elif type(v) is dict:\n            return self.reprDict(v)\n        elif type(v) is list:\n            vlist = []\n            for vitem in v:\n                vlist.append(self.getJSONValue(vitem))\n            return vlist\n        elif isinstance(v, datetime.datetime):\n            return v.isoformat()\n        elif isinstance(v, datetime.date):\n            return v.isoformat()\n        elif isinstance(v, bool):\n            # convert True,False to -&gt; true,false\n            return str(v).lower()\n        else:\n            return v\n\n    def reprDict(self, srcDict):\n        \"\"\"\n        get the given srcDict as new dict with fields being converted with getJSONValue\n\n        Args:\n            scrcDict(dict): the source dictionary\n\n        Returns\n            dict: the converted dictionary\n        \"\"\"\n        d = dict()\n        for a, v in srcDict.items():\n            d[a] = self.getJSONValue(v)\n        return d\n\n    def asJSON(self, asString=True, data=None):\n        \"\"\"\n        recursively return my dict elements\n\n        Args:\n            asString(boolean): if True return my result as a string\n        \"\"\"\n        if data is None:\n            data = self.__dict__\n        jsonDict = self.reprDict(data)\n        if asString:\n            jsonStr = str(jsonDict)\n            jsonStr = JSONAble.singleQuoteToDoubleQuote(jsonStr)\n            return jsonStr\n        return jsonDict\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.asJSON","title":"<code>asJSON(asString=True, data=None)</code>","text":"<p>recursively return my dict elements</p> <p>Parameters:</p> Name Type Description Default <code>asString(boolean)</code> <p>if True return my result as a string</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def asJSON(self, asString=True, data=None):\n    \"\"\"\n    recursively return my dict elements\n\n    Args:\n        asString(boolean): if True return my result as a string\n    \"\"\"\n    if data is None:\n        data = self.__dict__\n    jsonDict = self.reprDict(data)\n    if asString:\n        jsonStr = str(jsonDict)\n        jsonStr = JSONAble.singleQuoteToDoubleQuote(jsonStr)\n        return jsonStr\n    return jsonDict\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.checkExtension","title":"<code>checkExtension(jsonFile, extension='.json')</code>","text":"<p>make sure the jsonFile has the given extension e.g. \".json\"</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the jsonFile name - potentially without \".json\" suffix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the jsonFile name with \".json\" as an extension guaranteed</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def checkExtension(self, jsonFile: str, extension: str = \".json\") -&gt; str:\n    \"\"\"\n    make sure the jsonFile has the given extension e.g. \".json\"\n\n    Args:\n        jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n    Returns:\n        str: the jsonFile name with \".json\" as an extension guaranteed\n    \"\"\"\n    if not jsonFile.endswith(extension):\n        jsonFile = f\"{jsonFile}{extension}\"\n    return jsonFile\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.fromDict","title":"<code>fromDict(data)</code>","text":"<p>initialize me from the given data</p> <p>Parameters:</p> Name Type Description Default <code>data(dict)</code> <p>the dictionary to initialize me from</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fromDict(self, data: dict):\n    \"\"\"\n    initialize me from the given data\n\n    Args:\n        data(dict): the dictionary to initialize me from\n    \"\"\"\n    # https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python-taking-union-o\n    for key in data.keys():\n        value = data[key]\n        setattr(self, key, value)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.fromJson","title":"<code>fromJson(jsonStr)</code>","text":"<p>initialize me from the given JSON string</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fromJson(self, jsonStr):\n    \"\"\"\n    initialize me from the given JSON string\n\n    Args:\n        jsonStr(str): the JSON string\n    \"\"\"\n    jsonMap = json.loads(jsonStr)\n    self.fromDict(jsonMap)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.getJSONValue","title":"<code>getJSONValue(v)</code>","text":"<p>get the value of the given v as JSON</p> <p>Parameters:</p> Name Type Description Default <code>v(object)</code> <p>the value to get</p> required <p>Returns:</p> Type Description <p>the the value making sure objects are return as dicts</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getJSONValue(self, v):\n    \"\"\"\n    get the value of the given v as JSON\n\n    Args:\n        v(object): the value to get\n\n    Returns:\n        the the value making sure objects are return as dicts\n    \"\"\"\n    if hasattr(v, \"asJSON\"):\n        return v.asJSON(asString=False)\n    elif type(v) is dict:\n        return self.reprDict(v)\n    elif type(v) is list:\n        vlist = []\n        for vitem in v:\n            vlist.append(self.getJSONValue(vitem))\n        return vlist\n    elif isinstance(v, datetime.datetime):\n        return v.isoformat()\n    elif isinstance(v, datetime.date):\n        return v.isoformat()\n    elif isinstance(v, bool):\n        # convert True,False to -&gt; true,false\n        return str(v).lower()\n    else:\n        return v\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.getJsonTypeSamples","title":"<code>getJsonTypeSamples()</code>","text":"<p>does my class provide a \"getSamples\" method?</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getJsonTypeSamples(self):\n    \"\"\"\n    does my class provide a \"getSamples\" method?\n    \"\"\"\n    if hasattr(self, \"__class__\"):\n        cls = self.__class__\n        if isinstance(self, JSONAbleList) and not hasattr(cls, \"getSamples\"):\n            cls = self.clazz\n        return JSONAble.getJsonTypeSamplesForClass(cls)\n    return None\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.getJsonTypeSamplesForClass","title":"<code>getJsonTypeSamplesForClass()</code>  <code>staticmethod</code>","text":"<p>return the type samples for the given class</p> Return <p>list: a list of dict that specify the types by example</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef getJsonTypeSamplesForClass(cls):\n    \"\"\"\n    return the type samples for the given class\n\n    Return:\n        list: a list of dict that specify the types by example\n    \"\"\"\n    if hasattr(cls, \"getSamples\"):\n        getSamples = getattr(cls, \"getSamples\")\n        if callable(getSamples):\n            return getSamples()\n    return None\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.readJsonFromFile","title":"<code>readJsonFromFile(jsonFilePath)</code>  <code>staticmethod</code>","text":"<p>read json string from the given jsonFilePath</p> <p>Parameters:</p> Name Type Description Default <code>jsonFilePath(string)</code> <p>the path of the file where to read the result from</p> required <p>Returns:</p> Type Description <p>the JSON string read from the file</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef readJsonFromFile(jsonFilePath):\n    \"\"\"\n    read json string from the given jsonFilePath\n\n    Args:\n        jsonFilePath(string): the path of the file where to read the result from\n\n    Returns:\n        the JSON string read from the file\n    \"\"\"\n    with open(jsonFilePath, \"r\") as jsonFile:\n        jsonStr = jsonFile.read()\n    return jsonStr\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.reprDict","title":"<code>reprDict(srcDict)</code>","text":"<p>get the given srcDict as new dict with fields being converted with getJSONValue</p> <p>Parameters:</p> Name Type Description Default <code>scrcDict(dict)</code> <p>the source dictionary</p> required <p>Returns     dict: the converted dictionary</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def reprDict(self, srcDict):\n    \"\"\"\n    get the given srcDict as new dict with fields being converted with getJSONValue\n\n    Args:\n        scrcDict(dict): the source dictionary\n\n    Returns\n        dict: the converted dictionary\n    \"\"\"\n    d = dict()\n    for a, v in srcDict.items():\n        d[a] = self.getJSONValue(v)\n    return d\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.restoreFromJsonFile","title":"<code>restoreFromJsonFile(jsonFile)</code>","text":"<p>restore me from the given jsonFile</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(string)</code> <p>the jsonFile to restore me from</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def restoreFromJsonFile(self, jsonFile: str):\n    \"\"\"\n    restore me from the given jsonFile\n\n    Args:\n        jsonFile(string): the jsonFile to restore me from\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile)\n    jsonStr = JSONAble.readJsonFromFile(jsonFile)\n    self.fromJson(jsonStr)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.singleQuoteToDoubleQuote","title":"<code>singleQuoteToDoubleQuote(singleQuoted, useRegex=False)</code>  <code>staticmethod</code>","text":"<p>convert a single quoted string to a double quoted one</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted</code> <code>str</code> <p>a single quoted string e.g.</p> <p>.. highlight:: json</p> <p>{'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex</code> <code>boolean</code> <p>True if a regular expression shall be used for matching</p> <code>False</code> <p>Returns:</p> Name Type Description <code>string</code> <p>the double quoted version of the string</p> Note <p>see - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuote(singleQuoted, useRegex=False):\n    \"\"\"\n    convert a single quoted string to a double quoted one\n\n    Args:\n        singleQuoted (str): a single quoted string e.g.\n\n            .. highlight:: json\n\n            {'cities': [{'name': \"Upper Hell's Gate\"}]}\n\n        useRegex (boolean): True if a regular expression shall be used for matching\n\n    Returns:\n        string: the double quoted version of the string\n\n    Note:\n        see\n        - https://stackoverflow.com/questions/55600788/python-replace-single-quotes-with-double-quotes-but-leave-ones-within-double-q\n\n    \"\"\"\n    if useRegex:\n        doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingRegex(singleQuoted)\n    else:\n        doubleQuoted = JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop(\n            singleQuoted\n        )\n    return doubleQuoted\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.singleQuoteToDoubleQuoteUsingBracketLoop","title":"<code>singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted)</code>  <code>staticmethod</code>","text":"<p>convert a single quoted string to a double quoted one using a regular expression</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted(string)</code> <p>a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex(boolean)</code> <p>True if a regular expression shall be used for matching</p> required <p>Returns:     string: the double quoted version of the string e.g. Note:     see https://stackoverflow.com/a/63862387/1497139</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuoteUsingBracketLoop(singleQuoted):\n    \"\"\"\n    convert a single quoted string to a double quoted one using a regular expression\n\n    Args:\n        singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n        useRegex(boolean): True if a regular expression shall be used for matching\n    Returns:\n        string: the double quoted version of the string e.g.\n    Note:\n        see https://stackoverflow.com/a/63862387/1497139\n\n    \"\"\"\n    cList = list(singleQuoted)\n    inDouble = False\n    inSingle = False\n    for i, c in enumerate(cList):\n        # print (\"%d:%s %r %r\" %(i,c,inSingle,inDouble))\n        if c == \"'\":\n            if not inDouble:\n                inSingle = not inSingle\n                cList[i] = '\"'\n        elif c == '\"':\n            inDouble = not inDouble\n            inSingle = False\n    doubleQuoted = \"\".join(cList)\n    return doubleQuoted\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.singleQuoteToDoubleQuoteUsingRegex","title":"<code>singleQuoteToDoubleQuoteUsingRegex(singleQuoted)</code>  <code>staticmethod</code>","text":"<p>convert a single quoted string to a double quoted one using a regular expression</p> <p>Parameters:</p> Name Type Description Default <code>singleQuoted(string)</code> <p>a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}</p> required <code>useRegex(boolean)</code> <p>True if a regular expression shall be used for matching</p> required <p>Returns:     string: the double quoted version of the string e.g. Note:     see https://stackoverflow.com/a/50257217/1497139</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef singleQuoteToDoubleQuoteUsingRegex(singleQuoted):\n    \"\"\"\n    convert a single quoted string to a double quoted one using a regular expression\n\n    Args:\n        singleQuoted(string): a single quoted string e.g. {'cities': [{'name': \"Upper Hell's Gate\"}]}\n        useRegex(boolean): True if a regular expression shall be used for matching\n    Returns:\n        string: the double quoted version of the string e.g.\n    Note:\n        see https://stackoverflow.com/a/50257217/1497139\n    \"\"\"\n    doubleQuoted = JSONAbleSettings.singleQuoteRegex.sub('\"', singleQuoted)\n    return doubleQuoted\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.storeJsonToFile","title":"<code>storeJsonToFile(jsonStr, jsonFilePath)</code>  <code>staticmethod</code>","text":"<p>store the given json string to the given jsonFilePath</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(string)</code> <p>the string to store</p> required <code>jsonFilePath(string)</code> <p>the path of the file where to store the result</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef storeJsonToFile(jsonStr, jsonFilePath):\n    \"\"\"\n    store the given json string to the given jsonFilePath\n\n    Args:\n        jsonStr(string): the string to store\n        jsonFilePath(string): the path of the file where to store the result\n\n    \"\"\"\n    with open(jsonFilePath, \"w\") as jsonFile:\n        jsonFile.write(jsonStr)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.storeToJsonFile","title":"<code>storeToJsonFile(jsonFile, extension='.json', limitToSampleFields=False)</code>","text":"<p>store me to the given jsonFile</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the JSON file name (optionally without extension)</p> required <code>exension(str)</code> <p>the extension to use if not part of the jsonFile name</p> required <code>limitToSampleFields(bool)</code> <p>If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def storeToJsonFile(\n    self, jsonFile: str, extension: str = \".json\", limitToSampleFields: bool = False\n):\n    \"\"\"\n    store me to the given jsonFile\n\n    Args:\n        jsonFile(str): the JSON file name (optionally without extension)\n        exension(str): the extension to use if not part of the jsonFile name\n        limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile, extension)\n    JSONAble.storeJsonToFile(self.toJSON(limitToSampleFields), jsonFile)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.toJSON","title":"<code>toJSON(limitToSampleFields=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>limitToSampleFields(bool)</code> <p>If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.</p> required <p>Returns:</p> Type Description <p>a recursive JSON dump of the dicts of my objects</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def toJSON(self, limitToSampleFields: bool = False):\n    \"\"\"\n\n    Args:\n        limitToSampleFields(bool): If True the returned JSON is limited to the attributes/fields that are present in the samples. Otherwise all attributes of the object will be included. Default is False.\n\n    Returns:\n        a recursive JSON dump of the dicts of my objects\n    \"\"\"\n    data = {}\n    if limitToSampleFields:\n        samples = self.getJsonTypeSamples()\n        sampleFields = LOD.getFields(samples)\n        if isinstance(self, JSONAbleList):\n            limitedRecords = []\n            for record in self.__dict__[self.listName]:\n                limitedRecord = {}\n                for key, value in record.__dict__.items():\n                    if key in sampleFields:\n                        limitedRecord[key] = value\n                limitedRecords.append(limitedRecord)\n            data[self.listName] = limitedRecords\n        else:\n            for key, value in self.__dict__.items():\n                if key in sampleFields:\n                    data[key] = value\n    else:\n        data = self\n    jsonStr = json.dumps(\n        data,\n        default=lambda v: self.toJsonAbleValue(v),\n        sort_keys=True,\n        indent=JSONAbleSettings.indent,\n    )\n    return jsonStr\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAble.toJsonAbleValue","title":"<code>toJsonAbleValue(v)</code>","text":"<p>return the JSON able value of the given value v Args:     v(object): the value to convert</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def toJsonAbleValue(self, v):\n    \"\"\"\n    return the JSON able value of the given value v\n    Args:\n        v(object): the value to convert\n    \"\"\"\n    # objects have __dict__ hash tables which can be JSON-converted\n    if hasattr(v, \"__dict__\"):\n        return v.__dict__\n    elif isinstance(v, datetime.datetime):\n        return v.isoformat()\n    elif isinstance(v, datetime.date):\n        return v.isoformat()\n    else:\n        return \"\"\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList","title":"<code>JSONAbleList</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>Container class</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>class JSONAbleList(JSONAble):\n    \"\"\"\n    Container class\n    \"\"\"\n\n    def __init__(\n        self,\n        listName: str = None,\n        clazz=None,\n        tableName: str = None,\n        initList: bool = True,\n        handleInvalidListTypes=False,\n        filterInvalidListTypes=False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            listName(str): the name of the list attribute to be used for storing the List\n            clazz(class): a class to be used for Object relational mapping (if any)\n            tableName(str): the name of the \"table\" to be used\n            initList(bool): True if the list should be initialized\n            handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n            filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n        \"\"\"\n        self.clazz = clazz\n        self.handleInvalidListTypes = handleInvalidListTypes\n        self.filterInvalidListTypes = filterInvalidListTypes\n        if listName is None:\n            if self.clazz is not None:\n                listName = self.clazz.getPluralname()\n            else:\n                listName = self.__class__.name.lower()\n        self.listName = listName\n        if tableName is None:\n            self.tableName = listName\n        else:\n            self.tableName = tableName\n        if initList:\n            self.__dict__[self.listName] = []\n\n    def getList(self):\n        \"\"\"\n        get my list\n        \"\"\"\n        return self.__dict__[self.listName]\n\n    def setListFromLoD(self, lod: list) -&gt; list:\n        \"\"\"\n        set my list from the given list of dicts\n\n        Args:\n            lod(list) a raw record list of dicts\n\n        Returns:\n            list: a list of dicts if no clazz is set\n                otherwise a list of objects\n        \"\"\"\n        # non OO mode\n        if self.clazz is None:\n            result = lod\n            self.__dict__[self.listName] = result\n        else:\n            # ORM mode\n            # TODO - handle errors\n            self.fromLoD(lod, append=False)\n        return self.getList()\n\n    def getLoDfromJson(self, jsonStr: str, types=None, listName: str = None):\n        \"\"\"\n        get a list of Dicts form the given JSON String\n\n        Args:\n            jsonStr(str): the JSON string\n            fixType(Types): the types to be fixed\n        Returns:\n            list: a list of dicts\n        \"\"\"\n        # read a data structe from the given JSON string\n        lodOrDict = json.loads(jsonStr)\n        # it should be a list only of dict with my list\n        if not isinstance(lodOrDict, dict) and listName is not None:\n            lod = lodOrDict\n        else:\n            if self.listName in lodOrDict:\n                # get the relevant list of dicts\n                lod = lodOrDict[self.listName]\n            else:\n                msg = f\"invalid JSON for getLoD from Json\\nexpecting a list of dicts or a dict with '{self.listName}' as list\\nfound a dict with keys: {lodOrDict.keys()} instead\"\n                raise Exception(msg)\n        if types is not None:\n            types.fixTypes(lod, self.listName)\n        return lod\n\n    def fromLoD(self, lod, append: bool = True, debug: bool = False):\n        \"\"\"\n        load my entityList from the given list of dicts\n\n        Args:\n            lod(list): the list of dicts to load\n            append(bool): if True append to my existing entries\n\n        Return:\n            list: a list of errors (if any)\n\n        \"\"\"\n        errors = []\n        entityList = self.getList()\n        if not append:\n            del entityList[:]\n        if self.handleInvalidListTypes:\n            LOD.handleListTypes(lod=lod, doFilter=self.filterInvalidListTypes)\n\n        for record in lod:\n            # call the constructor to get a new instance\n            try:\n                entity = self.clazz()\n                entity.fromDict(record)\n                entityList.append(entity)\n            except Exception as ex:\n                error = {self.listName: record, \"error\": ex}\n                errors.append(error)\n                if debug:\n                    print(error)\n        return errors\n\n    def getLookup(self, attrName: str, withDuplicates: bool = False):\n        \"\"\"\n        create a lookup dictionary by the given attribute name\n\n        Args:\n            attrName(str): the attribute to lookup\n            withDuplicates(bool): whether to retain single values or lists\n\n        Return:\n            a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates\n        \"\"\"\n        return LOD.getLookup(self.getList(), attrName, withDuplicates)\n\n    def getJsonData(self):\n        \"\"\"\n        get my Jsondata\n        \"\"\"\n        jsonData = {self.listName: self.__dict__[self.listName]}\n        return jsonData\n\n    def toJsonAbleValue(self, v):\n        \"\"\"\n        make sure we don't store our meta information\n        clazz, tableName and listName but just the list we are holding\n        \"\"\"\n        if v == self:\n            return self.getJsonData()\n        else:\n            return super().toJsonAbleValue(v)\n\n    def fromJson(self, jsonStr, types=None):\n        \"\"\"\n        initialize me from the given JSON string\n\n        Args:\n            jsonStr(str): the JSON string\n            fixType(Types): the types to be fixed\n        \"\"\"\n        lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n        self.setListFromLoD(lod)\n\n    def asJSON(self, asString=True):\n        jsonData = self.getJsonData()\n        return super().asJSON(asString, data=jsonData)\n\n    def restoreFromJsonFile(self, jsonFile: str) -&gt; list:\n        \"\"\"\n        read my list of dicts and restore it\n        \"\"\"\n        lod = self.readLodFromJsonFile(jsonFile)\n        return self.setListFromLoD(lod)\n\n    def restoreFromJsonStr(self, jsonStr: str) -&gt; list:\n        \"\"\"\n        restore me from the given jsonStr\n\n        Args:\n            jsonStr(str): the json string to restore me from\n        \"\"\"\n        lod = self.readLodFromJsonStr(jsonStr)\n        return self.setListFromLoD(lod)\n\n    def readLodFromJsonFile(self, jsonFile: str, extension: str = \".json\"):\n        \"\"\"\n        read the list of dicts from the given jsonFile\n\n        Args:\n            jsonFile(string): the jsonFile to read from\n\n        Returns:\n            list: a list of dicts\n        \"\"\"\n        jsonFile = self.checkExtension(jsonFile, extension)\n        jsonStr = JSONAble.readJsonFromFile(jsonFile)\n        lod = self.readLodFromJsonStr(jsonStr)\n        return lod\n\n    def readLodFromJsonStr(self, jsonStr) -&gt; list:\n        \"\"\"\n        restore me from the given jsonStr\n\n        Args:\n            storeFilePrefix(string): the prefix for the JSON file name\n        \"\"\"\n        if self.clazz is None:\n            typeSamples = self.getJsonTypeSamples()\n        else:\n            typeSamples = self.clazz.getSamples()\n        if typeSamples is None:\n            types = None\n        else:\n            types = Types(\n                self.listName, warnOnUnsupportedTypes=not self.handleInvalidListTypes\n            )\n            types.getTypes(self.listName, typeSamples, len(typeSamples))\n        lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n        return lod\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.__init__","title":"<code>__init__(listName=None, clazz=None, tableName=None, initList=True, handleInvalidListTypes=False, filterInvalidListTypes=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list attribute to be used for storing the List</p> required <code>clazz(class)</code> <p>a class to be used for Object relational mapping (if any)</p> required <code>tableName(str)</code> <p>the name of the \"table\" to be used</p> required <code>initList(bool)</code> <p>True if the list should be initialized</p> required <code>handleInvalidListTypes(bool)</code> <p>True if invalidListTypes should be converted or filtered</p> required <code>filterInvalidListTypes(bool)</code> <p>True if invalidListTypes should be deleted</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def __init__(\n    self,\n    listName: str = None,\n    clazz=None,\n    tableName: str = None,\n    initList: bool = True,\n    handleInvalidListTypes=False,\n    filterInvalidListTypes=False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        listName(str): the name of the list attribute to be used for storing the List\n        clazz(class): a class to be used for Object relational mapping (if any)\n        tableName(str): the name of the \"table\" to be used\n        initList(bool): True if the list should be initialized\n        handleInvalidListTypes(bool): True if invalidListTypes should be converted or filtered\n        filterInvalidListTypes(bool): True if invalidListTypes should be deleted\n    \"\"\"\n    self.clazz = clazz\n    self.handleInvalidListTypes = handleInvalidListTypes\n    self.filterInvalidListTypes = filterInvalidListTypes\n    if listName is None:\n        if self.clazz is not None:\n            listName = self.clazz.getPluralname()\n        else:\n            listName = self.__class__.name.lower()\n    self.listName = listName\n    if tableName is None:\n        self.tableName = listName\n    else:\n        self.tableName = tableName\n    if initList:\n        self.__dict__[self.listName] = []\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.fromJson","title":"<code>fromJson(jsonStr, types=None)</code>","text":"<p>initialize me from the given JSON string</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required <code>fixType(Types)</code> <p>the types to be fixed</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fromJson(self, jsonStr, types=None):\n    \"\"\"\n    initialize me from the given JSON string\n\n    Args:\n        jsonStr(str): the JSON string\n        fixType(Types): the types to be fixed\n    \"\"\"\n    lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n    self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.fromLoD","title":"<code>fromLoD(lod, append=True, debug=False)</code>","text":"<p>load my entityList from the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to load</p> required <code>append(bool)</code> <p>if True append to my existing entries</p> required Return <p>list: a list of errors (if any)</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fromLoD(self, lod, append: bool = True, debug: bool = False):\n    \"\"\"\n    load my entityList from the given list of dicts\n\n    Args:\n        lod(list): the list of dicts to load\n        append(bool): if True append to my existing entries\n\n    Return:\n        list: a list of errors (if any)\n\n    \"\"\"\n    errors = []\n    entityList = self.getList()\n    if not append:\n        del entityList[:]\n    if self.handleInvalidListTypes:\n        LOD.handleListTypes(lod=lod, doFilter=self.filterInvalidListTypes)\n\n    for record in lod:\n        # call the constructor to get a new instance\n        try:\n            entity = self.clazz()\n            entity.fromDict(record)\n            entityList.append(entity)\n        except Exception as ex:\n            error = {self.listName: record, \"error\": ex}\n            errors.append(error)\n            if debug:\n                print(error)\n    return errors\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.getJsonData","title":"<code>getJsonData()</code>","text":"<p>get my Jsondata</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getJsonData(self):\n    \"\"\"\n    get my Jsondata\n    \"\"\"\n    jsonData = {self.listName: self.__dict__[self.listName]}\n    return jsonData\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.getList","title":"<code>getList()</code>","text":"<p>get my list</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getList(self):\n    \"\"\"\n    get my list\n    \"\"\"\n    return self.__dict__[self.listName]\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.getLoDfromJson","title":"<code>getLoDfromJson(jsonStr, types=None, listName=None)</code>","text":"<p>get a list of Dicts form the given JSON String</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the JSON string</p> required <code>fixType(Types)</code> <p>the types to be fixed</p> required <p>Returns:     list: a list of dicts</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getLoDfromJson(self, jsonStr: str, types=None, listName: str = None):\n    \"\"\"\n    get a list of Dicts form the given JSON String\n\n    Args:\n        jsonStr(str): the JSON string\n        fixType(Types): the types to be fixed\n    Returns:\n        list: a list of dicts\n    \"\"\"\n    # read a data structe from the given JSON string\n    lodOrDict = json.loads(jsonStr)\n    # it should be a list only of dict with my list\n    if not isinstance(lodOrDict, dict) and listName is not None:\n        lod = lodOrDict\n    else:\n        if self.listName in lodOrDict:\n            # get the relevant list of dicts\n            lod = lodOrDict[self.listName]\n        else:\n            msg = f\"invalid JSON for getLoD from Json\\nexpecting a list of dicts or a dict with '{self.listName}' as list\\nfound a dict with keys: {lodOrDict.keys()} instead\"\n            raise Exception(msg)\n    if types is not None:\n        types.fixTypes(lod, self.listName)\n    return lod\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.getLookup","title":"<code>getLookup(attrName, withDuplicates=False)</code>","text":"<p>create a lookup dictionary by the given attribute name</p> <p>Parameters:</p> Name Type Description Default <code>attrName(str)</code> <p>the attribute to lookup</p> required <code>withDuplicates(bool)</code> <p>whether to retain single values or lists</p> required Return <p>a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getLookup(self, attrName: str, withDuplicates: bool = False):\n    \"\"\"\n    create a lookup dictionary by the given attribute name\n\n    Args:\n        attrName(str): the attribute to lookup\n        withDuplicates(bool): whether to retain single values or lists\n\n    Return:\n        a dictionary for lookup or a tuple dictionary,list of duplicates depending on withDuplicates\n    \"\"\"\n    return LOD.getLookup(self.getList(), attrName, withDuplicates)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.readLodFromJsonFile","title":"<code>readLodFromJsonFile(jsonFile, extension='.json')</code>","text":"<p>read the list of dicts from the given jsonFile</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(string)</code> <p>the jsonFile to read from</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of dicts</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def readLodFromJsonFile(self, jsonFile: str, extension: str = \".json\"):\n    \"\"\"\n    read the list of dicts from the given jsonFile\n\n    Args:\n        jsonFile(string): the jsonFile to read from\n\n    Returns:\n        list: a list of dicts\n    \"\"\"\n    jsonFile = self.checkExtension(jsonFile, extension)\n    jsonStr = JSONAble.readJsonFromFile(jsonFile)\n    lod = self.readLodFromJsonStr(jsonStr)\n    return lod\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.readLodFromJsonStr","title":"<code>readLodFromJsonStr(jsonStr)</code>","text":"<p>restore me from the given jsonStr</p> <p>Parameters:</p> Name Type Description Default <code>storeFilePrefix(string)</code> <p>the prefix for the JSON file name</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def readLodFromJsonStr(self, jsonStr) -&gt; list:\n    \"\"\"\n    restore me from the given jsonStr\n\n    Args:\n        storeFilePrefix(string): the prefix for the JSON file name\n    \"\"\"\n    if self.clazz is None:\n        typeSamples = self.getJsonTypeSamples()\n    else:\n        typeSamples = self.clazz.getSamples()\n    if typeSamples is None:\n        types = None\n    else:\n        types = Types(\n            self.listName, warnOnUnsupportedTypes=not self.handleInvalidListTypes\n        )\n        types.getTypes(self.listName, typeSamples, len(typeSamples))\n    lod = self.getLoDfromJson(jsonStr, types, listName=self.listName)\n    return lod\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.restoreFromJsonFile","title":"<code>restoreFromJsonFile(jsonFile)</code>","text":"<p>read my list of dicts and restore it</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def restoreFromJsonFile(self, jsonFile: str) -&gt; list:\n    \"\"\"\n    read my list of dicts and restore it\n    \"\"\"\n    lod = self.readLodFromJsonFile(jsonFile)\n    return self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.restoreFromJsonStr","title":"<code>restoreFromJsonStr(jsonStr)</code>","text":"<p>restore me from the given jsonStr</p> <p>Parameters:</p> Name Type Description Default <code>jsonStr(str)</code> <p>the json string to restore me from</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def restoreFromJsonStr(self, jsonStr: str) -&gt; list:\n    \"\"\"\n    restore me from the given jsonStr\n\n    Args:\n        jsonStr(str): the json string to restore me from\n    \"\"\"\n    lod = self.readLodFromJsonStr(jsonStr)\n    return self.setListFromLoD(lod)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.setListFromLoD","title":"<code>setListFromLoD(lod)</code>","text":"<p>set my list from the given list of dicts</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of dicts if no clazz is set otherwise a list of objects</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def setListFromLoD(self, lod: list) -&gt; list:\n    \"\"\"\n    set my list from the given list of dicts\n\n    Args:\n        lod(list) a raw record list of dicts\n\n    Returns:\n        list: a list of dicts if no clazz is set\n            otherwise a list of objects\n    \"\"\"\n    # non OO mode\n    if self.clazz is None:\n        result = lod\n        self.__dict__[self.listName] = result\n    else:\n        # ORM mode\n        # TODO - handle errors\n        self.fromLoD(lod, append=False)\n    return self.getList()\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleList.toJsonAbleValue","title":"<code>toJsonAbleValue(v)</code>","text":"<p>make sure we don't store our meta information clazz, tableName and listName but just the list we are holding</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def toJsonAbleValue(self, v):\n    \"\"\"\n    make sure we don't store our meta information\n    clazz, tableName and listName but just the list we are holding\n    \"\"\"\n    if v == self:\n        return self.getJsonData()\n    else:\n        return super().toJsonAbleValue(v)\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleSettings","title":"<code>JSONAbleSettings</code>","text":"<p>settings for JSONAble - put in a separate class so they would not be serialized</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>class JSONAbleSettings:\n    \"\"\"\n    settings for JSONAble - put in a separate class so they would not be\n    serialized\n    \"\"\"\n\n    indent = 4\n    \"\"\"\n    regular expression to be used for conversion from singleQuote to doubleQuote\n    see https://stackoverflow.com/a/50257217/1497139\n    \"\"\"\n    singleQuoteRegex = re.compile(\"(?&lt;!\\\\\\\\)'\")\n</code></pre>"},{"location":"#lodstorage.jsonable.JSONAbleSettings.indent","title":"<code>indent = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>regular expression to be used for conversion from singleQuote to doubleQuote see https://stackoverflow.com/a/50257217/1497139</p>"},{"location":"#lodstorage.jsonable.Types","title":"<code>Types</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>Types</p> <p>holds entity meta Info</p> <p>:ivar name(string): entity name = table name</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>class Types(JSONAble):\n    \"\"\"\n    Types\n\n    holds entity meta Info\n\n    :ivar name(string): entity name = table name\n    \"\"\"\n\n    typeName2Type = {\n        \"bool\": bool,\n        \"date\": datetime.date,\n        \"datetime\": datetime.datetime,\n        \"float\": float,\n        \"int\": int,\n        \"str\": str,\n    }\n\n    def __init__(self, name: str, warnOnUnsupportedTypes=True, debug=False):\n        \"\"\"\n        Constructor\n\n        Args:\n            name(str): the name of the type map\n            warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n            debug(bool): if True - debugging information should be shown\n        \"\"\"\n        self.name = name\n        self.warnOnUnsupportedTypes = warnOnUnsupportedTypes\n        self.debug = debug\n        self.typeMap = {}\n\n    @staticmethod\n    def forTable(\n        instance, listName: str, warnOnUnsupportedTypes: bool = True, debug=False\n    ):\n        \"\"\"\n        get the types for the list of Dicts (table) in the given instance with the given listName\n        Args:\n            instance(object): the instance to inspect\n            listName(string): the list of dicts to inspect\n            warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n            debug(bool): True if debuggin information should be shown\n\n        Returns:\n            Types: a types object\n        \"\"\"\n        clazz = type(instance)\n        types = Types(\n            clazz.__name__, warnOnUnsupportedTypes=warnOnUnsupportedTypes, debug=debug\n        )\n        types.getTypes(listName, instance.__dict__[listName])\n        return types\n\n    def addType(self, listName, field, valueType):\n        \"\"\"\n        add the python type for the given field to the typeMap\n\n        Args:\n           listName(string): the name of the list of the field\n           field(string): the name of the field\n\n           valueType(type): the python type of the field\n        \"\"\"\n        if listName not in self.typeMap:\n            self.typeMap[listName] = {}\n        typeMap = self.typeMap[listName]\n        if not field in typeMap:\n            typeMap[field] = valueType\n\n    def getTypes(self, listName: str, sampleRecords: list, limit: int = 10):\n        \"\"\"\n        determine the types for the given sample records\n\n        Args:\n            listName(str): the name of the list\n            sampleRecords(list): a list of items\n            limit(int): the maximum number of items to check\n        \"\"\"\n        for sampleRecord in sampleRecords[:limit]:\n            items = sampleRecord.items()\n            self.getTypesForItems(listName, items, warnOnNone=len(sampleRecords) == 1)\n\n    def getTypesForItems(self, listName: str, items: list, warnOnNone: bool = False):\n        \"\"\"\n        get the types for the given items\n        side effect is setting my types\n\n        Args:\n            listName(str): the name of the list\n            items(list): a list of items\n            warnOnNone(bool): if TRUE warn if an item value is None\n\n        \"\"\"\n        for key, value in items:\n            valueType = None\n            if value is None:\n                if warnOnNone and self.debug:\n                    print(\n                        f\"Warning sampleRecord field {key} is None - using string as type\"\n                    )\n                    valueType = str\n            else:\n                valueType = type(value)\n            if valueType == str:\n                pass\n            elif valueType == int:\n                pass\n            elif valueType == float:\n                pass\n            elif valueType == bool:\n                pass\n            elif valueType == datetime.date:\n                pass\n            elif valueType == datetime.datetime:\n                pass\n            else:\n                if valueType is not None:\n                    msg = f\"warning: unsupported type {str(valueType)} for field {key}\"\n                    if self.debug and self.warnOnUnsupportedTypes:\n                        print(msg)\n            if valueType is not None:\n                self.addType(listName, key, valueType.__name__)\n\n    def fixTypes(self, lod: list, listName: str):\n        \"\"\"\n        fix the types in the given data structure\n\n        Args:\n            lod(list): a list of dicts\n            listName(str): the types to lookup by list name\n        \"\"\"\n        for listName in self.typeMap:\n            self.fixListOfDicts(self.typeMap[listName], lod)\n\n    def getType(self, typeName):\n        \"\"\"\n        get the type for the given type name\n        \"\"\"\n        if typeName in Types.typeName2Type:\n            return Types.typeName2Type[typeName]\n        else:\n            if self.debug:\n                print(\"Warning unsupported type %s\" % typeName)\n            return None\n\n    def fixListOfDicts(self, typeMap, listOfDicts):\n        \"\"\"\n        fix the type in the given list of Dicts\n        \"\"\"\n        for record in listOfDicts:\n            for keyValue in record.items():\n                key, value = keyValue\n                if value is None:\n                    record[key] = None\n                elif key in typeMap:\n                    valueType = self.getType(typeMap[key])\n                    if valueType == bool:\n                        if type(value) == str:\n                            b = value in [\"True\", \"TRUE\", \"true\"]\n                        else:\n                            b = value\n                        record[key] = b\n                    elif valueType == datetime.date:\n                        dt = datetime.datetime.strptime(value, \"%Y-%m-%d\")\n                        record[key] = dt.date()\n                    elif valueType == datetime.datetime:\n                        # see https://stackoverflow.com/questions/127803/how-do-i-parse-an-iso-8601-formatted-date\n                        if isinstance(value, str):\n                            if sys.version_info &gt;= (3, 7):\n                                dtime = datetime.datetime.fromisoformat(value)\n                            else:\n                                dtime = datetime.datetime.strptime(\n                                    value, \"%Y-%m-%dT%H:%M:%S.%f\"\n                                )\n                        else:\n                            # TODO: error handling\n                            dtime = None\n                        record[key] = dtime\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.__init__","title":"<code>__init__(name, warnOnUnsupportedTypes=True, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the type map</p> required <code>warnOnUnsupportedTypes(bool)</code> <p>if TRUE warn if an item value has an unsupported type</p> required <code>debug(bool)</code> <p>if True - debugging information should be shown</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def __init__(self, name: str, warnOnUnsupportedTypes=True, debug=False):\n    \"\"\"\n    Constructor\n\n    Args:\n        name(str): the name of the type map\n        warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n        debug(bool): if True - debugging information should be shown\n    \"\"\"\n    self.name = name\n    self.warnOnUnsupportedTypes = warnOnUnsupportedTypes\n    self.debug = debug\n    self.typeMap = {}\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.addType","title":"<code>addType(listName, field, valueType)</code>","text":"<p>add the python type for the given field to the typeMap</p> <p>Parameters:</p> Name Type Description Default <code>listName(string)</code> <p>the name of the list of the field</p> required <code>field(string)</code> <p>the name of the field</p> required <code>valueType(type)</code> <p>the python type of the field</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def addType(self, listName, field, valueType):\n    \"\"\"\n    add the python type for the given field to the typeMap\n\n    Args:\n       listName(string): the name of the list of the field\n       field(string): the name of the field\n\n       valueType(type): the python type of the field\n    \"\"\"\n    if listName not in self.typeMap:\n        self.typeMap[listName] = {}\n    typeMap = self.typeMap[listName]\n    if not field in typeMap:\n        typeMap[field] = valueType\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.fixListOfDicts","title":"<code>fixListOfDicts(typeMap, listOfDicts)</code>","text":"<p>fix the type in the given list of Dicts</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fixListOfDicts(self, typeMap, listOfDicts):\n    \"\"\"\n    fix the type in the given list of Dicts\n    \"\"\"\n    for record in listOfDicts:\n        for keyValue in record.items():\n            key, value = keyValue\n            if value is None:\n                record[key] = None\n            elif key in typeMap:\n                valueType = self.getType(typeMap[key])\n                if valueType == bool:\n                    if type(value) == str:\n                        b = value in [\"True\", \"TRUE\", \"true\"]\n                    else:\n                        b = value\n                    record[key] = b\n                elif valueType == datetime.date:\n                    dt = datetime.datetime.strptime(value, \"%Y-%m-%d\")\n                    record[key] = dt.date()\n                elif valueType == datetime.datetime:\n                    # see https://stackoverflow.com/questions/127803/how-do-i-parse-an-iso-8601-formatted-date\n                    if isinstance(value, str):\n                        if sys.version_info &gt;= (3, 7):\n                            dtime = datetime.datetime.fromisoformat(value)\n                        else:\n                            dtime = datetime.datetime.strptime(\n                                value, \"%Y-%m-%dT%H:%M:%S.%f\"\n                            )\n                    else:\n                        # TODO: error handling\n                        dtime = None\n                    record[key] = dtime\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.fixTypes","title":"<code>fixTypes(lod, listName)</code>","text":"<p>fix the types in the given data structure</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>a list of dicts</p> required <code>listName(str)</code> <p>the types to lookup by list name</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def fixTypes(self, lod: list, listName: str):\n    \"\"\"\n    fix the types in the given data structure\n\n    Args:\n        lod(list): a list of dicts\n        listName(str): the types to lookup by list name\n    \"\"\"\n    for listName in self.typeMap:\n        self.fixListOfDicts(self.typeMap[listName], lod)\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.forTable","title":"<code>forTable(instance, listName, warnOnUnsupportedTypes=True, debug=False)</code>  <code>staticmethod</code>","text":"<p>get the types for the list of Dicts (table) in the given instance with the given listName Args:     instance(object): the instance to inspect     listName(string): the list of dicts to inspect     warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type     debug(bool): True if debuggin information should be shown</p> <p>Returns:</p> Name Type Description <code>Types</code> <p>a types object</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>@staticmethod\ndef forTable(\n    instance, listName: str, warnOnUnsupportedTypes: bool = True, debug=False\n):\n    \"\"\"\n    get the types for the list of Dicts (table) in the given instance with the given listName\n    Args:\n        instance(object): the instance to inspect\n        listName(string): the list of dicts to inspect\n        warnOnUnsupportedTypes(bool): if TRUE warn if an item value has an unsupported type\n        debug(bool): True if debuggin information should be shown\n\n    Returns:\n        Types: a types object\n    \"\"\"\n    clazz = type(instance)\n    types = Types(\n        clazz.__name__, warnOnUnsupportedTypes=warnOnUnsupportedTypes, debug=debug\n    )\n    types.getTypes(listName, instance.__dict__[listName])\n    return types\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.getType","title":"<code>getType(typeName)</code>","text":"<p>get the type for the given type name</p> Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getType(self, typeName):\n    \"\"\"\n    get the type for the given type name\n    \"\"\"\n    if typeName in Types.typeName2Type:\n        return Types.typeName2Type[typeName]\n    else:\n        if self.debug:\n            print(\"Warning unsupported type %s\" % typeName)\n        return None\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.getTypes","title":"<code>getTypes(listName, sampleRecords, limit=10)</code>","text":"<p>determine the types for the given sample records</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list</p> required <code>sampleRecords(list)</code> <p>a list of items</p> required <code>limit(int)</code> <p>the maximum number of items to check</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getTypes(self, listName: str, sampleRecords: list, limit: int = 10):\n    \"\"\"\n    determine the types for the given sample records\n\n    Args:\n        listName(str): the name of the list\n        sampleRecords(list): a list of items\n        limit(int): the maximum number of items to check\n    \"\"\"\n    for sampleRecord in sampleRecords[:limit]:\n        items = sampleRecord.items()\n        self.getTypesForItems(listName, items, warnOnNone=len(sampleRecords) == 1)\n</code></pre>"},{"location":"#lodstorage.jsonable.Types.getTypesForItems","title":"<code>getTypesForItems(listName, items, warnOnNone=False)</code>","text":"<p>get the types for the given items side effect is setting my types</p> <p>Parameters:</p> Name Type Description Default <code>listName(str)</code> <p>the name of the list</p> required <code>items(list)</code> <p>a list of items</p> required <code>warnOnNone(bool)</code> <p>if TRUE warn if an item value is None</p> required Source code in <code>lodstorage/jsonable.py</code> <pre><code>def getTypesForItems(self, listName: str, items: list, warnOnNone: bool = False):\n    \"\"\"\n    get the types for the given items\n    side effect is setting my types\n\n    Args:\n        listName(str): the name of the list\n        items(list): a list of items\n        warnOnNone(bool): if TRUE warn if an item value is None\n\n    \"\"\"\n    for key, value in items:\n        valueType = None\n        if value is None:\n            if warnOnNone and self.debug:\n                print(\n                    f\"Warning sampleRecord field {key} is None - using string as type\"\n                )\n                valueType = str\n        else:\n            valueType = type(value)\n        if valueType == str:\n            pass\n        elif valueType == int:\n            pass\n        elif valueType == float:\n            pass\n        elif valueType == bool:\n            pass\n        elif valueType == datetime.date:\n            pass\n        elif valueType == datetime.datetime:\n            pass\n        else:\n            if valueType is not None:\n                msg = f\"warning: unsupported type {str(valueType)} for field {key}\"\n                if self.debug and self.warnOnUnsupportedTypes:\n                    print(msg)\n        if valueType is not None:\n            self.addType(listName, key, valueType.__name__)\n</code></pre>"},{"location":"#lodstorage.jsonpicklemixin","title":"<code>jsonpicklemixin</code>","text":""},{"location":"#lodstorage.jsonpicklemixin.JsonPickleMixin","title":"<code>JsonPickleMixin</code>","text":"<p>               Bases: <code>object</code></p> <p>allow reading and writing derived objects from a jsonpickle file</p> Source code in <code>lodstorage/jsonpicklemixin.py</code> <pre><code>class JsonPickleMixin(object):\n    \"\"\"\n    allow reading and writing derived objects from a jsonpickle file\n    \"\"\"\n\n    debug = False\n\n    @staticmethod\n    def checkExtension(jsonFile: str, extension: str = \".json\") -&gt; str:\n        \"\"\"\n        make sure the jsonFile has the given extension e.g. \".json\"\n\n        Args:\n            jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n        Returns:\n            str: the jsonFile name with \".json\" as an extension guaranteed\n        \"\"\"\n        if not jsonFile.endswith(extension):\n            jsonFile = f\"{jsonFile}{extension}\"\n        return jsonFile\n\n    # read me from a json pickle file\n    @staticmethod\n    def readJsonPickle(jsonFileName, extension=\".jsonpickle\"):\n        \"\"\"\n        Args:\n            jsonFileName(str): name of the file (optionally without \".json\" postfix)\n            extension(str): default file extension\n        \"\"\"\n        jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n        # is there a jsonFile for the given name\n        if os.path.isfile(jsonFileName):\n            if JsonPickleMixin.debug:\n                print(\"reading %s\" % (jsonFileName))\n            with open(jsonFileName) as jsonFile:\n                json = jsonFile.read()\n            result = jsonpickle.decode(json)\n            if JsonPickleMixin.debug:\n                print(json)\n                print(result)\n            return result\n        else:\n            return None\n\n    def asJsonPickle(self) -&gt; str:\n        \"\"\"\n        convert me to JSON\n\n        Returns:\n            str: a JSON String with my JSON representation\n        \"\"\"\n        json = jsonpickle.encode(self)\n        return json\n\n    def writeJsonPickle(self, jsonFileName: str, extension: str = \".jsonpickle\"):\n        \"\"\"\n        write me to the json file with the given name (optionally without postfix)\n\n        Args:\n            jsonFileName(str): name of the file (optionally without \".json\" postfix)\n            extension(str): default file extension\n        \"\"\"\n        jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n        json = self.asJsonPickle()\n        if JsonPickleMixin.debug:\n            print(\"writing %s\" % (jsonFileName))\n            print(json)\n            print(self)\n        jsonFile = open(jsonFileName, \"w\")\n        jsonFile.write(json)\n        jsonFile.close()\n</code></pre>"},{"location":"#lodstorage.jsonpicklemixin.JsonPickleMixin.asJsonPickle","title":"<code>asJsonPickle()</code>","text":"<p>convert me to JSON</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a JSON String with my JSON representation</p> Source code in <code>lodstorage/jsonpicklemixin.py</code> <pre><code>def asJsonPickle(self) -&gt; str:\n    \"\"\"\n    convert me to JSON\n\n    Returns:\n        str: a JSON String with my JSON representation\n    \"\"\"\n    json = jsonpickle.encode(self)\n    return json\n</code></pre>"},{"location":"#lodstorage.jsonpicklemixin.JsonPickleMixin.checkExtension","title":"<code>checkExtension(jsonFile, extension='.json')</code>  <code>staticmethod</code>","text":"<p>make sure the jsonFile has the given extension e.g. \".json\"</p> <p>Parameters:</p> Name Type Description Default <code>jsonFile(str)</code> <p>the jsonFile name - potentially without \".json\" suffix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the jsonFile name with \".json\" as an extension guaranteed</p> Source code in <code>lodstorage/jsonpicklemixin.py</code> <pre><code>@staticmethod\ndef checkExtension(jsonFile: str, extension: str = \".json\") -&gt; str:\n    \"\"\"\n    make sure the jsonFile has the given extension e.g. \".json\"\n\n    Args:\n        jsonFile(str): the jsonFile name - potentially without \".json\" suffix\n\n    Returns:\n        str: the jsonFile name with \".json\" as an extension guaranteed\n    \"\"\"\n    if not jsonFile.endswith(extension):\n        jsonFile = f\"{jsonFile}{extension}\"\n    return jsonFile\n</code></pre>"},{"location":"#lodstorage.jsonpicklemixin.JsonPickleMixin.readJsonPickle","title":"<code>readJsonPickle(jsonFileName, extension='.jsonpickle')</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>jsonFileName(str)</code> <p>name of the file (optionally without \".json\" postfix)</p> required <code>extension(str)</code> <p>default file extension</p> required Source code in <code>lodstorage/jsonpicklemixin.py</code> <pre><code>@staticmethod\ndef readJsonPickle(jsonFileName, extension=\".jsonpickle\"):\n    \"\"\"\n    Args:\n        jsonFileName(str): name of the file (optionally without \".json\" postfix)\n        extension(str): default file extension\n    \"\"\"\n    jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n    # is there a jsonFile for the given name\n    if os.path.isfile(jsonFileName):\n        if JsonPickleMixin.debug:\n            print(\"reading %s\" % (jsonFileName))\n        with open(jsonFileName) as jsonFile:\n            json = jsonFile.read()\n        result = jsonpickle.decode(json)\n        if JsonPickleMixin.debug:\n            print(json)\n            print(result)\n        return result\n    else:\n        return None\n</code></pre>"},{"location":"#lodstorage.jsonpicklemixin.JsonPickleMixin.writeJsonPickle","title":"<code>writeJsonPickle(jsonFileName, extension='.jsonpickle')</code>","text":"<p>write me to the json file with the given name (optionally without postfix)</p> <p>Parameters:</p> Name Type Description Default <code>jsonFileName(str)</code> <p>name of the file (optionally without \".json\" postfix)</p> required <code>extension(str)</code> <p>default file extension</p> required Source code in <code>lodstorage/jsonpicklemixin.py</code> <pre><code>def writeJsonPickle(self, jsonFileName: str, extension: str = \".jsonpickle\"):\n    \"\"\"\n    write me to the json file with the given name (optionally without postfix)\n\n    Args:\n        jsonFileName(str): name of the file (optionally without \".json\" postfix)\n        extension(str): default file extension\n    \"\"\"\n    jsonFileName = JsonPickleMixin.checkExtension(jsonFileName, extension)\n    json = self.asJsonPickle()\n    if JsonPickleMixin.debug:\n        print(\"writing %s\" % (jsonFileName))\n        print(json)\n        print(self)\n    jsonFile = open(jsonFileName, \"w\")\n    jsonFile.write(json)\n    jsonFile.close()\n</code></pre>"},{"location":"#lodstorage.linkml","title":"<code>linkml</code>","text":"<p>Created on 2024-01-28</p> <p>@author: wf</p>"},{"location":"#lodstorage.linkml.Class","title":"<code>Class</code>","text":"<p>Represents a class in the LinkML schema.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Class:\n    \"\"\"\n    Represents a class in the LinkML schema.\n    \"\"\"\n\n    description: str\n    slots: List[Slot]\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes","title":"<code>PythonTypes</code>","text":"<p>python type handling</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>class PythonTypes:\n    \"\"\"\n    python type handling\n    \"\"\"\n\n    # Define a mapping from Python types to LinkML ranges\n    to_linkml_ranges = {\n        str: \"string\",\n        int: \"integer\",\n        float: \"float\",\n        bool: \"boolean\",\n        list: \"list\",\n        dict: \"dictionary\",\n    }\n    # Mapping from Python types to RDF (XSD) datatypes\n    to_rdf_datatypes = {\n        str: XSD.string,\n        int: XSD.integer,\n        float: XSD.float,\n        bool: XSD.boolean,\n        # Add more mappings if needed\n    }\n\n    @classmethod\n    def get_linkml_range(cls, ptype: Type) -&gt; str:\n        \"\"\"\n        Determines the LinkML range for a given Python type.\n\n        Args:\n            ptype (Type): The Python type for which the LinkML range is required.\n\n        Returns:\n            str: The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.\n        \"\"\"\n        return cls.to_linkml_ranges.get(ptype, \"string\")\n\n    @classmethod\n    def get_rdf_datatype(cls, ptype: Type) -&gt; Optional[XSD]:\n        \"\"\"\n        Determines the RDF (XSD) datatype for a given Python type.\n\n        Args:\n            ptype (Type): The Python type for which the RDF (XSD) datatype is required.\n\n        Returns:\n            XSD: The corresponding RDF (XSD) datatype. Returns None if the type is not found.\n        \"\"\"\n        return cls.to_rdf_datatypes.get(ptype)\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes.get_linkml_range","title":"<code>get_linkml_range(ptype)</code>  <code>classmethod</code>","text":"<p>Determines the LinkML range for a given Python type.</p> <p>Parameters:</p> Name Type Description Default <code>ptype</code> <code>Type</code> <p>The Python type for which the LinkML range is required.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@classmethod\ndef get_linkml_range(cls, ptype: Type) -&gt; str:\n    \"\"\"\n    Determines the LinkML range for a given Python type.\n\n    Args:\n        ptype (Type): The Python type for which the LinkML range is required.\n\n    Returns:\n        str: The corresponding LinkML range as a string. Defaults to \"string\" if the type is not found.\n    \"\"\"\n    return cls.to_linkml_ranges.get(ptype, \"string\")\n</code></pre>"},{"location":"#lodstorage.linkml.PythonTypes.get_rdf_datatype","title":"<code>get_rdf_datatype(ptype)</code>  <code>classmethod</code>","text":"<p>Determines the RDF (XSD) datatype for a given Python type.</p> <p>Parameters:</p> Name Type Description Default <code>ptype</code> <code>Type</code> <p>The Python type for which the RDF (XSD) datatype is required.</p> required <p>Returns:</p> Name Type Description <code>XSD</code> <code>Optional[XSD]</code> <p>The corresponding RDF (XSD) datatype. Returns None if the type is not found.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@classmethod\ndef get_rdf_datatype(cls, ptype: Type) -&gt; Optional[XSD]:\n    \"\"\"\n    Determines the RDF (XSD) datatype for a given Python type.\n\n    Args:\n        ptype (Type): The Python type for which the RDF (XSD) datatype is required.\n\n    Returns:\n        XSD: The corresponding RDF (XSD) datatype. Returns None if the type is not found.\n    \"\"\"\n    return cls.to_rdf_datatypes.get(ptype)\n</code></pre>"},{"location":"#lodstorage.linkml.Schema","title":"<code>Schema</code>","text":"<p>Represents the entire LinkML schema.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Schema:\n    \"\"\"\n    Represents the entire LinkML schema.\n    \"\"\"\n\n    name: str\n    id: str\n    description: str\n    title: Optional[str] = None\n    version: Optional[str] = None\n    license: Optional[str] = None\n\n    default_prefix: Optional[str] = None\n\n    prefixes: Dict[str, str] = field(default_factory=dict)\n    imports: List[str] = field(default_factory=list)\n    default_range: str = \"string\"\n    classes: Dict[str, Class] = field(default_factory=dict)\n    slots: Dict[str, Slot] = field(default_factory=dict)\n    types: Dict[str, Type] = field(default_factory=dict)\n\n    def __post_init__(self):\n        if not self.title:\n            self.title = self.name\n</code></pre>"},{"location":"#lodstorage.linkml.Slot","title":"<code>Slot</code>","text":"<p>Represents a slot in the LinkML schema, equivalent to a field or property.</p> Source code in <code>lodstorage/linkml.py</code> <pre><code>@lod_storable\nclass Slot:\n    \"\"\"\n    Represents a slot in the LinkML schema, equivalent to a field or property.\n    \"\"\"\n\n    description: str\n    range: str = \"string\"\n    multivalued: bool = False\n    identifier: bool = False\n</code></pre>"},{"location":"#lodstorage.linkml_gen","title":"<code>linkml_gen</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.linkml_gen.LinkMLGen","title":"<code>LinkMLGen</code>","text":"<p>Class for generating LinkML YAML schema from Python data models using dataclasses.</p> Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>class LinkMLGen:\n    \"\"\"\n    Class for generating LinkML YAML schema from Python data models using dataclasses.\n    \"\"\"\n\n    def __init__(self, schema: Schema):\n        \"\"\"\n        Initialize the LinkMLGen.\n\n        Args:\n            schema (Schema): The LinkML schema to be generated.\n        \"\"\"\n        self.schema = schema\n\n    def gen_schema(self, data_model_class) -&gt; Schema:\n        # Use DocstringParser to extract class description\n        parser = DocstringParser()\n        class_description, doc_attributes = parser.parse(data_model_class.__doc__)\n\n        class_name = data_model_class.__name__\n        new_class = Class(description=class_description, slots=[])\n\n        # Iterate over the fields of the dataclass\n        for field_info in fields(data_model_class):\n            attr_name = field_info.name\n            attr_type = field_info.type\n\n            # Handle Optional and List types\n            is_optional = False\n            is_list = False\n            content_type = None\n            if hasattr(attr_type, \"__origin__\"):\n                if attr_type.__origin__ is Union and type(None) in attr_type.__args__:\n                    is_optional = True\n                    attr_type = [t for t in attr_type.__args__ if t is not type(None)][\n                        0\n                    ]  # unwrap Optional type\n                elif attr_type.__origin__ is list:\n                    is_list = True\n                    content_type = attr_type.__args__[0]  # unwrap List type\n                elif attr_type.__origin__ is dict:\n                    # Assuming dictionary values are of interest, keys are strings\n                    content_type = attr_type.__args__[\n                        1\n                    ]  # unwrap Dict type, focusing on value type\n\n            # Check and handle nested dataclasses for lists or dicts\n            if is_dataclass(content_type):\n                # Recursive call to handle nested dataclass\n                self.gen_schema(content_type)\n                # Set the range to the name of the dataclass\n                linkml_range = (\n                    content_type.__name__\n                )  # Use the name of the dataclass as the range\n            elif is_list:\n                # If it's a list, get the LinkML range for the base type\n                # Use self.get_linkml_range to ensure consistent type mapping\n                linkml_range = PythonTypes.get_linkml_range(content_type)\n            else:\n                # For non-list and non-dataclass types, use self.get_linkml_range for consistent type mapping\n                linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n            # Extract description from doc_attributes\n            description = doc_attributes.get(attr_name, {}).get(\n                \"description\", f\"{attr_name} - missing description\"\n            )\n\n            # Create a new slot for the field\n            new_slot = Slot(\n                description=description, range=linkml_range, multivalued=is_list\n            )\n            self.schema.slots[attr_name] = new_slot\n            new_class.slots.append(attr_name)\n\n        self.schema.classes[class_name] = new_class\n        return self.schema\n\n    def gen_schema_from_instance(self, data_model_instance) -&gt; Schema:\n        \"\"\"\n        Generate a LinkML YAML schema from a Python data model using dataclasses.\n\n        Args:\n            data_model_instance: An instance of the Python data model.\n\n        Returns:\n            Schema: The LinkML schema generated from the data model.\n        \"\"\"\n        # Use DocstringParser to extract class description and attributes\n        parser = DocstringParser()\n        class_description, doc_attributes = parser.parse(data_model_instance.__doc__)\n\n        class_name = data_model_instance.__class__.__name__\n        new_class = Class(description=class_description, slots=[])\n\n        for field_info in fields(data_model_instance):\n            attr_name = field_info.name\n            attr_type = field_info.type\n\n            # Extract field type/range\n            linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n            # Check values for multivalued and type consistency\n            attr_value = getattr(data_model_instance, attr_name)\n            multivalued, actual_type = self.check_value(attr_value)\n\n            # Ensure documentation, declaration, and value type are consistent\n            self.ensure_consistency(\n                attr_name, linkml_range, actual_type, doc_attributes\n            )\n\n            # Prepare slot\n            description = doc_attributes.get(attr_name, {}).get(\n                \"description\", f\"{attr_name} - missing description\"\n            )\n            if attr_name not in self.schema.slots:\n                new_slot = Slot(\n                    description=description, range=linkml_range, multivalued=multivalued\n                )\n                self.schema.slots[attr_name] = new_slot\n                new_class.slots.append(attr_name)\n\n            if multivalued:\n                # recursive call if type of list or dict is a dataclass\n                if hasattr(attr_type, \"__args__\"):\n                    content_type = attr_type.__args__[\n                        0\n                    ]  # Get the declared content type\n                    if is_dataclass(content_type):\n                        self.gen_schema(content_type)\n\n        self.schema.classes[class_name] = new_class\n        return self.schema\n\n    def check_value(self, value):\n        # Method to check if the value is multivalued and determine its type\n        multivalued = isinstance(value, (Iterable, Mapping)) and not isinstance(\n            value, (str, bytes)\n        )\n        value_type = type(value).__name__\n        return multivalued, value_type\n\n    def ensure_consistency(self, name, declared_type, actual_type, doc_attributes):\n        # Adjust this method to handle complex types like list, dict, etc.\n\n        # Check if the actual type is a list or dict, and if so, get the type of its elements\n        if actual_type == \"list\" or actual_type == \"dict\":\n            # You may need a more complex logic here to handle lists of custom dataclasses\n            # For simplicity, let's assume it's a list of strings for now\n            actual_type = \"string\"\n\n        # Now compare the adjusted actual type with the declared type\n        if declared_type != actual_type:\n            raise ValueError(\n                f\"Type mismatch for '{name}': declared as '{declared_type}', actual type is '{actual_type}'\"\n            )\n\n        # Check for documentation\n        if name not in doc_attributes:\n            raise ValueError(f\"Missing documentation for field '{name}'\")\n</code></pre>"},{"location":"#lodstorage.linkml_gen.LinkMLGen.__init__","title":"<code>__init__(schema)</code>","text":"<p>Initialize the LinkMLGen.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The LinkML schema to be generated.</p> required Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>def __init__(self, schema: Schema):\n    \"\"\"\n    Initialize the LinkMLGen.\n\n    Args:\n        schema (Schema): The LinkML schema to be generated.\n    \"\"\"\n    self.schema = schema\n</code></pre>"},{"location":"#lodstorage.linkml_gen.LinkMLGen.gen_schema_from_instance","title":"<code>gen_schema_from_instance(data_model_instance)</code>","text":"<p>Generate a LinkML YAML schema from a Python data model using dataclasses.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_instance</code> <p>An instance of the Python data model.</p> required <p>Returns:</p> Name Type Description <code>Schema</code> <code>Schema</code> <p>The LinkML schema generated from the data model.</p> Source code in <code>lodstorage/linkml_gen.py</code> <pre><code>def gen_schema_from_instance(self, data_model_instance) -&gt; Schema:\n    \"\"\"\n    Generate a LinkML YAML schema from a Python data model using dataclasses.\n\n    Args:\n        data_model_instance: An instance of the Python data model.\n\n    Returns:\n        Schema: The LinkML schema generated from the data model.\n    \"\"\"\n    # Use DocstringParser to extract class description and attributes\n    parser = DocstringParser()\n    class_description, doc_attributes = parser.parse(data_model_instance.__doc__)\n\n    class_name = data_model_instance.__class__.__name__\n    new_class = Class(description=class_description, slots=[])\n\n    for field_info in fields(data_model_instance):\n        attr_name = field_info.name\n        attr_type = field_info.type\n\n        # Extract field type/range\n        linkml_range = PythonTypes.get_linkml_range(attr_type)\n\n        # Check values for multivalued and type consistency\n        attr_value = getattr(data_model_instance, attr_name)\n        multivalued, actual_type = self.check_value(attr_value)\n\n        # Ensure documentation, declaration, and value type are consistent\n        self.ensure_consistency(\n            attr_name, linkml_range, actual_type, doc_attributes\n        )\n\n        # Prepare slot\n        description = doc_attributes.get(attr_name, {}).get(\n            \"description\", f\"{attr_name} - missing description\"\n        )\n        if attr_name not in self.schema.slots:\n            new_slot = Slot(\n                description=description, range=linkml_range, multivalued=multivalued\n            )\n            self.schema.slots[attr_name] = new_slot\n            new_class.slots.append(attr_name)\n\n        if multivalued:\n            # recursive call if type of list or dict is a dataclass\n            if hasattr(attr_type, \"__args__\"):\n                content_type = attr_type.__args__[\n                    0\n                ]  # Get the declared content type\n                if is_dataclass(content_type):\n                    self.gen_schema(content_type)\n\n    self.schema.classes[class_name] = new_class\n    return self.schema\n</code></pre>"},{"location":"#lodstorage.lod","title":"<code>lod</code>","text":"<p>Created on 2021-01-31</p> <p>@author: wf</p>"},{"location":"#lodstorage.lod.LOD","title":"<code>LOD</code>","text":"<p>               Bases: <code>object</code></p> <p>list of Dict aka Table</p> Source code in <code>lodstorage/lod.py</code> <pre><code>class LOD(object):\n    \"\"\"\n    list of Dict aka Table\n    \"\"\"\n\n    def __init__(self, name):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.name = name\n        pass\n\n    @staticmethod\n    def getFields(listOfDicts, sampleCount: int = None):\n        if sampleCount is None:\n            if listOfDicts is None:\n                return None\n            sampleCount = len(listOfDicts)\n        fields = []\n        from lodstorage.jsonable import JSONAble\n\n        for row in listOfDicts:\n            if isinstance(row, JSONAble):\n                row = vars(row)\n            for key in row.keys():\n                if not key in fields:\n                    fields.append(key)\n        return fields\n\n    @staticmethod\n    def setNone4List(listOfDicts, fields):\n        \"\"\"\n        set the given fields to None for the records in the given listOfDicts\n        if they are not set\n        Args:\n            listOfDicts(list): the list of records to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        for record in listOfDicts:\n            LOD.setNone(record, fields)\n\n    @staticmethod\n    def setNone(record, fields):\n        \"\"\"\n        make sure the given fields in the given record are set to none\n        Args:\n            record(dict): the record to work on\n            fields(list): the list of fields to set to None\n        \"\"\"\n        for field in fields:\n            if not field in record:\n                record[field] = None\n\n    \"\"\"\n    https://stackoverflow.com/questions/33542997/python-intersection-of-2-lists-of-dictionaries/33543164\n    \"\"\"\n\n    @staticmethod\n    def sortKey(d, key=None):\n        \"\"\"get the sort key for the given dict d with the given key\"\"\"\n        if key is None:\n            # https://stackoverflow.com/a/60765557/1497139\n            return hash(tuple(d.items()))\n        else:\n            return d[key]\n\n    @staticmethod\n    def intersect(listOfDict1, listOfDict2, key=None):\n        \"\"\"\n        get the  intersection of the two lists of Dicts by the given key\n        \"\"\"\n        i1 = iter(sorted(listOfDict1, key=lambda k: LOD.sortKey(k, key)))\n        i2 = iter(sorted(listOfDict2, key=lambda k: LOD.sortKey(k, key)))\n        c1 = next(i1)\n        c2 = next(i2)\n        lr = []\n        while True:\n            try:\n                val1 = LOD.sortKey(c1, key)\n                val2 = LOD.sortKey(c2, key)\n                if val1 &lt; val2:\n                    c1 = next(i1)\n                elif val1 &gt; val2:\n                    c2 = next(i2)\n                else:\n                    lr.append(c1)\n                    c1 = next(i1)\n                    c2 = next(i2)\n            except StopIteration:\n                break\n        return lr\n\n    @staticmethod\n    def addLookup(lookup, duplicates, record, value, withDuplicates: bool):\n        \"\"\"\n        add a single lookup result\n\n        Args:\n            lookup(dict): the lookup map\n            duplicates(list): the list of duplicates\n            record(dict): the current record\n            value(object): the current value to lookup\n            withDuplicates(bool): if True duplicates should be allowed and lists returned if False a separate duplicates\n            list is created\n        \"\"\"\n        if value in lookup:\n            if withDuplicates:\n                lookupResult = lookup[value]\n                lookupResult.append(record)\n            else:\n                duplicates.append(record)\n                return\n        else:\n            if withDuplicates:\n                lookupResult = [record]\n            else:\n                lookupResult = record\n        lookup[value] = lookupResult\n\n    @staticmethod\n    def getLookup(lod: list, attrName: str, withDuplicates: bool = False):\n        \"\"\"\n        create a lookup dictionary by the given attribute name for the given list of dicts\n\n        Args:\n            lod(list): the list of dicts to get the lookup dictionary for\n            attrName(str): the attribute to lookup\n            withDuplicates(bool): whether to retain single values or lists\n\n        Return:\n            a dictionary for lookup\n        \"\"\"\n        lookup = {}\n        duplicates = []\n        for record in lod:\n            value = None\n            if isinstance(record, dict):\n                if attrName in record:\n                    value = record[attrName]\n            else:\n                if hasattr(record, attrName):\n                    value = getattr(record, attrName)\n            if value is not None:\n                if isinstance(value, list):\n                    for listValue in value:\n                        LOD.addLookup(\n                            lookup, duplicates, record, listValue, withDuplicates\n                        )\n                else:\n                    LOD.addLookup(lookup, duplicates, record, value, withDuplicates)\n        if withDuplicates:\n            return lookup\n        else:\n            return lookup, duplicates\n\n    @classmethod\n    def handleListTypes(cls, lod, doFilter=False, separator=\",\"):\n        \"\"\"\n        handle list types in the given list of dicts\n\n        Args:\n            cls: this class\n            lod(list): a list of dicts\n            doFilter(bool): True if records containing lists value items should be filtered\n            separator(str): the separator to use when converting lists\n        \"\"\"\n        # see https://stackoverflow.com/a/1207485/1497139\n        for i in range(len(lod) - 1, -1, -1):\n            record = lod[i]\n            if isinstance(record, dict):\n                for key in record:\n                    value = record[key]\n                    if isinstance(value, list):\n                        if doFilter:\n                            del lod[i]\n                            continue\n                        else:\n                            newValue = separator.join(filter(None, value))\n                            record[key] = newValue\n\n    @staticmethod\n    def filterFields(lod: list, fields: list, reverse: bool = False):\n        \"\"\"\n        filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the\n        fields contained in the list depending on the state of the reverse parameter\n\n        Args:\n            lod(list): list of dicts from which the fields should be excluded\n            fields(list): list of fields that should be excluded from the lod\n            reverse(bool): If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.\n\n        Returns:\n            LoD\n        \"\"\"\n        res = []\n        for record in lod:\n            if reverse:\n                recordReduced = {d: record[d] for d in record if d in fields}\n            else:\n                recordReduced = {d: record[d] for d in record if d not in fields}\n            res.append(recordReduced)\n        return res\n</code></pre>"},{"location":"#lodstorage.lod.LOD.__init__","title":"<code>__init__(name)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/lod.py</code> <pre><code>def __init__(self, name):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.name = name\n    pass\n</code></pre>"},{"location":"#lodstorage.lod.LOD.addLookup","title":"<code>addLookup(lookup, duplicates, record, value, withDuplicates)</code>  <code>staticmethod</code>","text":"<p>add a single lookup result</p> <p>Parameters:</p> Name Type Description Default <code>lookup(dict)</code> <p>the lookup map</p> required <code>duplicates(list)</code> <p>the list of duplicates</p> required <code>record(dict)</code> <p>the current record</p> required <code>value(object)</code> <p>the current value to lookup</p> required <code>withDuplicates(bool)</code> <p>if True duplicates should be allowed and lists returned if False a separate duplicates</p> required Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef addLookup(lookup, duplicates, record, value, withDuplicates: bool):\n    \"\"\"\n    add a single lookup result\n\n    Args:\n        lookup(dict): the lookup map\n        duplicates(list): the list of duplicates\n        record(dict): the current record\n        value(object): the current value to lookup\n        withDuplicates(bool): if True duplicates should be allowed and lists returned if False a separate duplicates\n        list is created\n    \"\"\"\n    if value in lookup:\n        if withDuplicates:\n            lookupResult = lookup[value]\n            lookupResult.append(record)\n        else:\n            duplicates.append(record)\n            return\n    else:\n        if withDuplicates:\n            lookupResult = [record]\n        else:\n            lookupResult = record\n    lookup[value] = lookupResult\n</code></pre>"},{"location":"#lodstorage.lod.LOD.filterFields","title":"<code>filterFields(lod, fields, reverse=False)</code>  <code>staticmethod</code>","text":"<p>filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the fields contained in the list depending on the state of the reverse parameter</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>list of dicts from which the fields should be excluded</p> required <code>fields(list)</code> <p>list of fields that should be excluded from the lod</p> required <code>reverse(bool)</code> <p>If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.</p> required <p>Returns:</p> Type Description <p>LoD</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef filterFields(lod: list, fields: list, reverse: bool = False):\n    \"\"\"\n    filter the given LoD with the given list of fields by either limiting the LoD to the fields or removing the\n    fields contained in the list depending on the state of the reverse parameter\n\n    Args:\n        lod(list): list of dicts from which the fields should be excluded\n        fields(list): list of fields that should be excluded from the lod\n        reverse(bool): If True limit dict to the list of given fields. Otherwise exclude the fields from the dict.\n\n    Returns:\n        LoD\n    \"\"\"\n    res = []\n    for record in lod:\n        if reverse:\n            recordReduced = {d: record[d] for d in record if d in fields}\n        else:\n            recordReduced = {d: record[d] for d in record if d not in fields}\n        res.append(recordReduced)\n    return res\n</code></pre>"},{"location":"#lodstorage.lod.LOD.getLookup","title":"<code>getLookup(lod, attrName, withDuplicates=False)</code>  <code>staticmethod</code>","text":"<p>create a lookup dictionary by the given attribute name for the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to get the lookup dictionary for</p> required <code>attrName(str)</code> <p>the attribute to lookup</p> required <code>withDuplicates(bool)</code> <p>whether to retain single values or lists</p> required Return <p>a dictionary for lookup</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef getLookup(lod: list, attrName: str, withDuplicates: bool = False):\n    \"\"\"\n    create a lookup dictionary by the given attribute name for the given list of dicts\n\n    Args:\n        lod(list): the list of dicts to get the lookup dictionary for\n        attrName(str): the attribute to lookup\n        withDuplicates(bool): whether to retain single values or lists\n\n    Return:\n        a dictionary for lookup\n    \"\"\"\n    lookup = {}\n    duplicates = []\n    for record in lod:\n        value = None\n        if isinstance(record, dict):\n            if attrName in record:\n                value = record[attrName]\n        else:\n            if hasattr(record, attrName):\n                value = getattr(record, attrName)\n        if value is not None:\n            if isinstance(value, list):\n                for listValue in value:\n                    LOD.addLookup(\n                        lookup, duplicates, record, listValue, withDuplicates\n                    )\n            else:\n                LOD.addLookup(lookup, duplicates, record, value, withDuplicates)\n    if withDuplicates:\n        return lookup\n    else:\n        return lookup, duplicates\n</code></pre>"},{"location":"#lodstorage.lod.LOD.handleListTypes","title":"<code>handleListTypes(lod, doFilter=False, separator=',')</code>  <code>classmethod</code>","text":"<p>handle list types in the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>this class</p> required <code>lod(list)</code> <p>a list of dicts</p> required <code>doFilter(bool)</code> <p>True if records containing lists value items should be filtered</p> required <code>separator(str)</code> <p>the separator to use when converting lists</p> required Source code in <code>lodstorage/lod.py</code> <pre><code>@classmethod\ndef handleListTypes(cls, lod, doFilter=False, separator=\",\"):\n    \"\"\"\n    handle list types in the given list of dicts\n\n    Args:\n        cls: this class\n        lod(list): a list of dicts\n        doFilter(bool): True if records containing lists value items should be filtered\n        separator(str): the separator to use when converting lists\n    \"\"\"\n    # see https://stackoverflow.com/a/1207485/1497139\n    for i in range(len(lod) - 1, -1, -1):\n        record = lod[i]\n        if isinstance(record, dict):\n            for key in record:\n                value = record[key]\n                if isinstance(value, list):\n                    if doFilter:\n                        del lod[i]\n                        continue\n                    else:\n                        newValue = separator.join(filter(None, value))\n                        record[key] = newValue\n</code></pre>"},{"location":"#lodstorage.lod.LOD.intersect","title":"<code>intersect(listOfDict1, listOfDict2, key=None)</code>  <code>staticmethod</code>","text":"<p>get the  intersection of the two lists of Dicts by the given key</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef intersect(listOfDict1, listOfDict2, key=None):\n    \"\"\"\n    get the  intersection of the two lists of Dicts by the given key\n    \"\"\"\n    i1 = iter(sorted(listOfDict1, key=lambda k: LOD.sortKey(k, key)))\n    i2 = iter(sorted(listOfDict2, key=lambda k: LOD.sortKey(k, key)))\n    c1 = next(i1)\n    c2 = next(i2)\n    lr = []\n    while True:\n        try:\n            val1 = LOD.sortKey(c1, key)\n            val2 = LOD.sortKey(c2, key)\n            if val1 &lt; val2:\n                c1 = next(i1)\n            elif val1 &gt; val2:\n                c2 = next(i2)\n            else:\n                lr.append(c1)\n                c1 = next(i1)\n                c2 = next(i2)\n        except StopIteration:\n            break\n    return lr\n</code></pre>"},{"location":"#lodstorage.lod.LOD.setNone","title":"<code>setNone(record, fields)</code>  <code>staticmethod</code>","text":"<p>make sure the given fields in the given record are set to none Args:     record(dict): the record to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef setNone(record, fields):\n    \"\"\"\n    make sure the given fields in the given record are set to none\n    Args:\n        record(dict): the record to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    for field in fields:\n        if not field in record:\n            record[field] = None\n</code></pre>"},{"location":"#lodstorage.lod.LOD.setNone4List","title":"<code>setNone4List(listOfDicts, fields)</code>  <code>staticmethod</code>","text":"<p>set the given fields to None for the records in the given listOfDicts if they are not set Args:     listOfDicts(list): the list of records to work on     fields(list): the list of fields to set to None</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef setNone4List(listOfDicts, fields):\n    \"\"\"\n    set the given fields to None for the records in the given listOfDicts\n    if they are not set\n    Args:\n        listOfDicts(list): the list of records to work on\n        fields(list): the list of fields to set to None\n    \"\"\"\n    for record in listOfDicts:\n        LOD.setNone(record, fields)\n</code></pre>"},{"location":"#lodstorage.lod.LOD.sortKey","title":"<code>sortKey(d, key=None)</code>  <code>staticmethod</code>","text":"<p>get the sort key for the given dict d with the given key</p> Source code in <code>lodstorage/lod.py</code> <pre><code>@staticmethod\ndef sortKey(d, key=None):\n    \"\"\"get the sort key for the given dict d with the given key\"\"\"\n    if key is None:\n        # https://stackoverflow.com/a/60765557/1497139\n        return hash(tuple(d.items()))\n    else:\n        return d[key]\n</code></pre>"},{"location":"#lodstorage.lod_csv","title":"<code>lod_csv</code>","text":""},{"location":"#lodstorage.lod_csv.CSV","title":"<code>CSV</code>","text":"<p>               Bases: <code>LOD</code></p> <p>helper for converting data in csv format to list of dicts (LoD) and vice versa</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>class CSV(LOD):\n    \"\"\"\n    helper for converting data in csv format to list of dicts (LoD) and vice versa\n    \"\"\"\n\n    @staticmethod\n    def restoreFromCSVFile(\n        filePath: str, headerNames: list = None, withPostfix: bool = False\n    ):\n        \"\"\"\n        restore LOD from given csv file\n\n        Args:\n            filePath(str): file name\n            headerNames(list): Names of the headers that should be used. If None it is assumed that the header is given.\n            withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n\n        Returns:\n            list of dicts (LoD) containing the content of the given csv file\n        \"\"\"\n        if not withPostfix:\n            filePath += \".csv\"\n        csvStr = CSV.readFile(filePath)\n        lod = CSV.fromCSV(csvStr, headerNames)\n        return lod\n\n    @staticmethod\n    def fromCSV(\n        csvString: str,\n        fields: list = None,\n        delimiter=\",\",\n        quoting=csv.QUOTE_NONNUMERIC,\n        **kwargs\n    ):\n        \"\"\"\n        convert given csv string to list of dicts (LOD)\n\n        Args:\n            csvStr(str): csv string that should be converted to LOD\n            headerNames(list): Names of the headers that should be used. If None it is assumed that the header is given.\n\n        Returns:\n            list of dicts (LoD) containing the content of the given csv string\n        \"\"\"\n        csvStream = io.StringIO(csvString)\n        reader = csv.DictReader(\n            csvStream, fieldnames=fields, delimiter=delimiter, quoting=quoting, **kwargs\n        )\n        lod = list(reader)\n        CSV.fixTypes(lod)\n        return lod\n\n    @staticmethod\n    def storeToCSVFile(lod: list, filePath: str, withPostfix: bool = False):\n        \"\"\"\n        converts the given lod to CSV file.\n\n        Args:\n            lod(list): lod that should be converted to csv file\n            filePath(str): file name the csv should be stored to\n            withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n        Returns:\n            csv string of the given lod\n        \"\"\"\n        if not withPostfix:\n            filePath += \".csv\"\n        csvStr = CSV.toCSV(lod)\n        CSV.writeFile(csvStr, filePath)\n\n    @staticmethod\n    def toCSV(\n        lod: list,\n        includeFields: list = None,\n        excludeFields: list = None,\n        delimiter=\",\",\n        quoting=csv.QUOTE_NONNUMERIC,\n        **kwargs\n    ):\n        \"\"\"\n        converts the given lod to CSV string.\n        For details about the csv dialect parameters see https://docs.python.org/3/library/csv.html#csv-fmt-params\n\n        Args:\n            lod(list): lod that should be converted to csv string\n            includeFields(list): list of fields that should be included in the csv (positive list)\n            excludeFields(list): list of fields that should be excluded from the csv (negative list)\n            kwargs: csv dialect parameters\n        Returns:\n            csv string of the given lod\n        \"\"\"\n        if lod is None:\n            return \"\"\n        if isinstance(lod[0], JSONAble):\n            lod = [vars(d) for d in lod]\n        if excludeFields is not None:\n            lod = LOD.filterFields(lod, excludeFields)\n        if includeFields is None:\n            fields = LOD.getFields(lod)\n        else:\n            fields = includeFields\n            lod = LOD.filterFields(lod, includeFields, reverse=True)\n        csvStream = io.StringIO()\n        dict_writer = csv.DictWriter(\n            csvStream, fieldnames=fields, delimiter=delimiter, quoting=quoting, **kwargs\n        )\n        dict_writer.writeheader()\n        dict_writer.writerows(lod)\n        csvString = csvStream.getvalue()\n        return csvString\n\n    @staticmethod\n    def readFile(filename: str) -&gt; str:\n        \"\"\"\n        Reads the given filename and returns it as string\n        Args:\n            filename: Name of the file that should be returned as string\n\n        Returns:\n            Content of the file as string\n        \"\"\"\n        with open(filename, \"r\") as file:\n            content = file.read()\n        return content\n\n    @staticmethod\n    def writeFile(content: str, filename: str) -&gt; str:\n        \"\"\"\n        Write the given str to the given filename\n        Args:\n            content(str): string that should be written into the file\n            filename: Name of the file the given str should be written to\n        Returns:\n            Nothing\n        \"\"\"\n        with open(filename, \"w\") as file:\n            file.write(content)\n\n    @staticmethod\n    def fixTypes(lod: list):\n        \"\"\"\n        fixes the types of the given LoD.\n\n        \"\"\"\n        for record in lod:\n            for key, value in record.items():\n                # fix empty csv value: \"cell1,,cell3\" converts the second value to empty string instead of None\n                if value == \"\":\n                    record[key] = None\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.fixTypes","title":"<code>fixTypes(lod)</code>  <code>staticmethod</code>","text":"<p>fixes the types of the given LoD.</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef fixTypes(lod: list):\n    \"\"\"\n    fixes the types of the given LoD.\n\n    \"\"\"\n    for record in lod:\n        for key, value in record.items():\n            # fix empty csv value: \"cell1,,cell3\" converts the second value to empty string instead of None\n            if value == \"\":\n                record[key] = None\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.fromCSV","title":"<code>fromCSV(csvString, fields=None, delimiter=',', quoting=csv.QUOTE_NONNUMERIC, **kwargs)</code>  <code>staticmethod</code>","text":"<p>convert given csv string to list of dicts (LOD)</p> <p>Parameters:</p> Name Type Description Default <code>csvStr(str)</code> <p>csv string that should be converted to LOD</p> required <code>headerNames(list)</code> <p>Names of the headers that should be used. If None it is assumed that the header is given.</p> required <p>Returns:</p> Type Description <p>list of dicts (LoD) containing the content of the given csv string</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef fromCSV(\n    csvString: str,\n    fields: list = None,\n    delimiter=\",\",\n    quoting=csv.QUOTE_NONNUMERIC,\n    **kwargs\n):\n    \"\"\"\n    convert given csv string to list of dicts (LOD)\n\n    Args:\n        csvStr(str): csv string that should be converted to LOD\n        headerNames(list): Names of the headers that should be used. If None it is assumed that the header is given.\n\n    Returns:\n        list of dicts (LoD) containing the content of the given csv string\n    \"\"\"\n    csvStream = io.StringIO(csvString)\n    reader = csv.DictReader(\n        csvStream, fieldnames=fields, delimiter=delimiter, quoting=quoting, **kwargs\n    )\n    lod = list(reader)\n    CSV.fixTypes(lod)\n    return lod\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.readFile","title":"<code>readFile(filename)</code>  <code>staticmethod</code>","text":"<p>Reads the given filename and returns it as string Args:     filename: Name of the file that should be returned as string</p> <p>Returns:</p> Type Description <code>str</code> <p>Content of the file as string</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef readFile(filename: str) -&gt; str:\n    \"\"\"\n    Reads the given filename and returns it as string\n    Args:\n        filename: Name of the file that should be returned as string\n\n    Returns:\n        Content of the file as string\n    \"\"\"\n    with open(filename, \"r\") as file:\n        content = file.read()\n    return content\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.restoreFromCSVFile","title":"<code>restoreFromCSVFile(filePath, headerNames=None, withPostfix=False)</code>  <code>staticmethod</code>","text":"<p>restore LOD from given csv file</p> <p>Parameters:</p> Name Type Description Default <code>filePath(str)</code> <p>file name</p> required <code>headerNames(list)</code> <p>Names of the headers that should be used. If None it is assumed that the header is given.</p> required <code>withPostfix(bool)</code> <p>If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.</p> required <p>Returns:</p> Type Description <p>list of dicts (LoD) containing the content of the given csv file</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef restoreFromCSVFile(\n    filePath: str, headerNames: list = None, withPostfix: bool = False\n):\n    \"\"\"\n    restore LOD from given csv file\n\n    Args:\n        filePath(str): file name\n        headerNames(list): Names of the headers that should be used. If None it is assumed that the header is given.\n        withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n\n    Returns:\n        list of dicts (LoD) containing the content of the given csv file\n    \"\"\"\n    if not withPostfix:\n        filePath += \".csv\"\n    csvStr = CSV.readFile(filePath)\n    lod = CSV.fromCSV(csvStr, headerNames)\n    return lod\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.storeToCSVFile","title":"<code>storeToCSVFile(lod, filePath, withPostfix=False)</code>  <code>staticmethod</code>","text":"<p>converts the given lod to CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>lod that should be converted to csv file</p> required <code>filePath(str)</code> <p>file name the csv should be stored to</p> required <code>withPostfix(bool)</code> <p>If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.</p> required <p>Returns:     csv string of the given lod</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef storeToCSVFile(lod: list, filePath: str, withPostfix: bool = False):\n    \"\"\"\n    converts the given lod to CSV file.\n\n    Args:\n        lod(list): lod that should be converted to csv file\n        filePath(str): file name the csv should be stored to\n        withPostfix(bool): If False the file type is appended to given filePath. Otherwise file type MUST be given with filePath.\n    Returns:\n        csv string of the given lod\n    \"\"\"\n    if not withPostfix:\n        filePath += \".csv\"\n    csvStr = CSV.toCSV(lod)\n    CSV.writeFile(csvStr, filePath)\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.toCSV","title":"<code>toCSV(lod, includeFields=None, excludeFields=None, delimiter=',', quoting=csv.QUOTE_NONNUMERIC, **kwargs)</code>  <code>staticmethod</code>","text":"<p>converts the given lod to CSV string. For details about the csv dialect parameters see https://docs.python.org/3/library/csv.html#csv-fmt-params</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>lod that should be converted to csv string</p> required <code>includeFields(list)</code> <p>list of fields that should be included in the csv (positive list)</p> required <code>excludeFields(list)</code> <p>list of fields that should be excluded from the csv (negative list)</p> required <code>kwargs</code> <p>csv dialect parameters</p> <code>{}</code> <p>Returns:     csv string of the given lod</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef toCSV(\n    lod: list,\n    includeFields: list = None,\n    excludeFields: list = None,\n    delimiter=\",\",\n    quoting=csv.QUOTE_NONNUMERIC,\n    **kwargs\n):\n    \"\"\"\n    converts the given lod to CSV string.\n    For details about the csv dialect parameters see https://docs.python.org/3/library/csv.html#csv-fmt-params\n\n    Args:\n        lod(list): lod that should be converted to csv string\n        includeFields(list): list of fields that should be included in the csv (positive list)\n        excludeFields(list): list of fields that should be excluded from the csv (negative list)\n        kwargs: csv dialect parameters\n    Returns:\n        csv string of the given lod\n    \"\"\"\n    if lod is None:\n        return \"\"\n    if isinstance(lod[0], JSONAble):\n        lod = [vars(d) for d in lod]\n    if excludeFields is not None:\n        lod = LOD.filterFields(lod, excludeFields)\n    if includeFields is None:\n        fields = LOD.getFields(lod)\n    else:\n        fields = includeFields\n        lod = LOD.filterFields(lod, includeFields, reverse=True)\n    csvStream = io.StringIO()\n    dict_writer = csv.DictWriter(\n        csvStream, fieldnames=fields, delimiter=delimiter, quoting=quoting, **kwargs\n    )\n    dict_writer.writeheader()\n    dict_writer.writerows(lod)\n    csvString = csvStream.getvalue()\n    return csvString\n</code></pre>"},{"location":"#lodstorage.lod_csv.CSV.writeFile","title":"<code>writeFile(content, filename)</code>  <code>staticmethod</code>","text":"<p>Write the given str to the given filename Args:     content(str): string that should be written into the file     filename: Name of the file the given str should be written to Returns:     Nothing</p> Source code in <code>lodstorage/lod_csv.py</code> <pre><code>@staticmethod\ndef writeFile(content: str, filename: str) -&gt; str:\n    \"\"\"\n    Write the given str to the given filename\n    Args:\n        content(str): string that should be written into the file\n        filename: Name of the file the given str should be written to\n    Returns:\n        Nothing\n    \"\"\"\n    with open(filename, \"w\") as file:\n        file.write(content)\n</code></pre>"},{"location":"#lodstorage.mwTable","title":"<code>mwTable</code>","text":"<p>Created on 2020-08-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.mwTable.MediaWikiTable","title":"<code>MediaWikiTable</code>","text":"<p>               Bases: <code>object</code></p> <p>helper for https://www.mediawiki.org/wiki/Help:Tables</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>class MediaWikiTable(object):\n    \"\"\"\n    helper for https://www.mediawiki.org/wiki/Help:Tables\n    \"\"\"\n\n    def __init__(\n        self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.colFormats = colFormats\n        cssDelim = \"\"\n        if wikiTable:\n            cWikiTable = \"wikitable\"\n            cssDelim = \" \"\n        else:\n            cWikiTable = \"\"\n        if sortable:\n            cSortable = \"sortable\"\n        else:\n            cSortable = \"\"\n\n        self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n        self.header = None\n        self.content = \"\"\n        self.end = \"\\n|}\\n\"\n        self.withNewLines = withNewLines\n        pass\n\n    def addHeader(self, record):\n        \"\"\"\n        add the given record as a \"sample\" header\n        \"\"\"\n        if self.withNewLines:\n            headerStart = \"|+\"\n            firstColDelim = \"\\n!\"\n            colDelim = firstColDelim\n        else:\n            headerStart = \"|+\\n\"\n            firstColDelim = \"!\"\n            colDelim = \"!!\"\n        self.header = headerStart\n        first = True\n        for key in record.keys():\n            if first:\n                delim = firstColDelim\n                first = False\n            else:\n                delim = colDelim\n            self.header += \"%s%s\" % (delim, key)\n\n    def addRow4Dict(self, record):\n        if self.header is None:\n            self.addHeader(record)\n        if self.withNewLines:\n            rowStart = \"\\n|-\"\n            colDelim = \"\\n|\"\n        else:\n            rowStart = \"\\n|-\\n\"\n            colDelim = \"||\"\n        self.content += rowStart\n        for key in record.keys():\n            value = record[key]\n            if self.colFormats is not None and key in self.colFormats:\n                colFormat = self.colFormats[key]\n            else:\n                colFormat = \"%s\"\n            self.content += (\"%s\" + colFormat) % (colDelim, value)\n\n    def fromListOfDicts(self, listOfDicts):\n        for record in listOfDicts:\n            self.addRow4Dict(record)\n        pass\n\n    def noneReplace(self, value):\n        return \"\" if value is None else value\n\n    def asWikiMarkup(self):\n        \"\"\"\n        convert me to MediaWiki markup\n\n        Returns:\n            string: the MediWiki Markup for this table\n        \"\"\"\n        markup = (\n            self.noneReplace(self.start)\n            + self.noneReplace(self.header)\n            + self.noneReplace(self.content)\n            + self.noneReplace(self.end)\n        )\n        return markup\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.__init__","title":"<code>__init__(wikiTable=True, colFormats=None, sortable=True, withNewLines=False)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def __init__(\n    self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.colFormats = colFormats\n    cssDelim = \"\"\n    if wikiTable:\n        cWikiTable = \"wikitable\"\n        cssDelim = \" \"\n    else:\n        cWikiTable = \"\"\n    if sortable:\n        cSortable = \"sortable\"\n    else:\n        cSortable = \"\"\n\n    self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n    self.header = None\n    self.content = \"\"\n    self.end = \"\\n|}\\n\"\n    self.withNewLines = withNewLines\n    pass\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.addHeader","title":"<code>addHeader(record)</code>","text":"<p>add the given record as a \"sample\" header</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def addHeader(self, record):\n    \"\"\"\n    add the given record as a \"sample\" header\n    \"\"\"\n    if self.withNewLines:\n        headerStart = \"|+\"\n        firstColDelim = \"\\n!\"\n        colDelim = firstColDelim\n    else:\n        headerStart = \"|+\\n\"\n        firstColDelim = \"!\"\n        colDelim = \"!!\"\n    self.header = headerStart\n    first = True\n    for key in record.keys():\n        if first:\n            delim = firstColDelim\n            first = False\n        else:\n            delim = colDelim\n        self.header += \"%s%s\" % (delim, key)\n</code></pre>"},{"location":"#lodstorage.mwTable.MediaWikiTable.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>convert me to MediaWiki markup</p> <p>Returns:</p> Name Type Description <code>string</code> <p>the MediWiki Markup for this table</p> Source code in <code>lodstorage/mwTable.py</code> <pre><code>def asWikiMarkup(self):\n    \"\"\"\n    convert me to MediaWiki markup\n\n    Returns:\n        string: the MediWiki Markup for this table\n    \"\"\"\n    markup = (\n        self.noneReplace(self.start)\n        + self.noneReplace(self.header)\n        + self.noneReplace(self.content)\n        + self.noneReplace(self.end)\n    )\n    return markup\n</code></pre>"},{"location":"#lodstorage.params","title":"<code>params</code>","text":"<p>Created on 2024-05-06</p> <p>@author: wf</p>"},{"location":"#lodstorage.params.Params","title":"<code>Params</code>","text":"<p>parameter handling</p> Source code in <code>lodstorage/params.py</code> <pre><code>class Params:\n    \"\"\"\n    parameter handling\n    \"\"\"\n\n    def __init__(self, query: str, illegal_chars: str = \"\"\"\"[;&lt;&gt;&amp;|]\"'\"\"\"):\n        \"\"\"\n        constructor\n\n        Args:\n            query(str): the query to analyze for parameters\n            illegal_chars: chars that may not be in the values\n        \"\"\"\n        self.illegal_chars = illegal_chars\n        self.query = query\n        self.pattern = re.compile(r\"{{\\s*(\\w+)\\s*}}\")\n        self.params = self.pattern.findall(query)\n        self.params_dict = {param: \"\" for param in self.params}\n        self.has_params = len(self.params) &gt; 0\n\n    def set(self, params_dict: Dict):\n        \"\"\"\n        set my params\n        \"\"\"\n        self.params_dict = params_dict\n\n    def audit(self) -&gt; None:\n        \"\"\"\n        Audit the usage of parameters in the query.\n\n        Raises:\n            ValueError: If potentially malicious values are detected in the parameter dictionary.\n        \"\"\"\n        for param, value in self.params_dict.items():\n            for char in self.illegal_chars:\n                if char in value:\n                    raise ValueError(\n                        f\"Potentially malicious value detected for parameter '{param}'\"\n                    )\n\n    def apply_parameters(self) -&gt; str:\n        \"\"\"\n        Replace Jinja templates in the query with corresponding parameter values.\n\n        Returns:\n            str: The query with Jinja templates replaced by parameter values.\n        \"\"\"\n        self.audit()\n        query = self.query\n        for param, value in self.params_dict.items():\n            pattern = re.compile(r\"{{\\s*\" + re.escape(param) + r\"\\s*\\}\\}\")\n            query = re.sub(pattern, value, query)\n        return query\n</code></pre>"},{"location":"#lodstorage.params.Params.__init__","title":"<code>__init__(query, illegal_chars='\"[;&lt;&gt;&amp;|]\"\\'')</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>query(str)</code> <p>the query to analyze for parameters</p> required <code>illegal_chars</code> <code>str</code> <p>chars that may not be in the values</p> <code>'\"[;&lt;&gt;&amp;|]\"\\''</code> Source code in <code>lodstorage/params.py</code> <pre><code>def __init__(self, query: str, illegal_chars: str = \"\"\"\"[;&lt;&gt;&amp;|]\"'\"\"\"):\n    \"\"\"\n    constructor\n\n    Args:\n        query(str): the query to analyze for parameters\n        illegal_chars: chars that may not be in the values\n    \"\"\"\n    self.illegal_chars = illegal_chars\n    self.query = query\n    self.pattern = re.compile(r\"{{\\s*(\\w+)\\s*}}\")\n    self.params = self.pattern.findall(query)\n    self.params_dict = {param: \"\" for param in self.params}\n    self.has_params = len(self.params) &gt; 0\n</code></pre>"},{"location":"#lodstorage.params.Params.apply_parameters","title":"<code>apply_parameters()</code>","text":"<p>Replace Jinja templates in the query with corresponding parameter values.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The query with Jinja templates replaced by parameter values.</p> Source code in <code>lodstorage/params.py</code> <pre><code>def apply_parameters(self) -&gt; str:\n    \"\"\"\n    Replace Jinja templates in the query with corresponding parameter values.\n\n    Returns:\n        str: The query with Jinja templates replaced by parameter values.\n    \"\"\"\n    self.audit()\n    query = self.query\n    for param, value in self.params_dict.items():\n        pattern = re.compile(r\"{{\\s*\" + re.escape(param) + r\"\\s*\\}\\}\")\n        query = re.sub(pattern, value, query)\n    return query\n</code></pre>"},{"location":"#lodstorage.params.Params.audit","title":"<code>audit()</code>","text":"<p>Audit the usage of parameters in the query.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If potentially malicious values are detected in the parameter dictionary.</p> Source code in <code>lodstorage/params.py</code> <pre><code>def audit(self) -&gt; None:\n    \"\"\"\n    Audit the usage of parameters in the query.\n\n    Raises:\n        ValueError: If potentially malicious values are detected in the parameter dictionary.\n    \"\"\"\n    for param, value in self.params_dict.items():\n        for char in self.illegal_chars:\n            if char in value:\n                raise ValueError(\n                    f\"Potentially malicious value detected for parameter '{param}'\"\n                )\n</code></pre>"},{"location":"#lodstorage.params.Params.set","title":"<code>set(params_dict)</code>","text":"<p>set my params</p> Source code in <code>lodstorage/params.py</code> <pre><code>def set(self, params_dict: Dict):\n    \"\"\"\n    set my params\n    \"\"\"\n    self.params_dict = params_dict\n</code></pre>"},{"location":"#lodstorage.params.StoreDictKeyPair","title":"<code>StoreDictKeyPair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Custom argparse action to store key-value pairs as a dictionary.</p> <p>This class implements an argparse action to parse and store command-line arguments in the form of key-value pairs. The pairs should be separated by a comma and each key-value pair should be separated by an equals sign.</p> Example <p>--option key1=value1,key2=value2,key3=value3</p> Reference <p>https://stackoverflow.com/a/42355279/1497139</p> Source code in <code>lodstorage/params.py</code> <pre><code>class StoreDictKeyPair(argparse.Action):\n    \"\"\"\n    Custom argparse action to store key-value pairs as a dictionary.\n\n    This class implements an argparse action to parse and store command-line\n    arguments in the form of key-value pairs. The pairs should be separated by\n    a comma and each key-value pair should be separated by an equals sign.\n\n    Example:\n        --option key1=value1,key2=value2,key3=value3\n\n    Reference:\n        https://stackoverflow.com/a/42355279/1497139\n    \"\"\"\n\n    def __call__(\n        self,\n        _parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: str,\n        _option_string: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Parse key-value pairs and store them as a dictionary in the namespace.\n\n        Args:\n            parser (argparse.ArgumentParser): The argument parser object.\n            namespace (argparse.Namespace): The namespace to store the parsed values.\n            values (str): The string containing key-value pairs separated by commas.\n            option_string (Optional[str]): The option string, if provided.\n        \"\"\"\n        my_dict = {}\n        for kv in values.split(\",\"):\n            k, v = kv.split(\"=\")\n            my_dict[k] = v\n        setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#lodstorage.params.StoreDictKeyPair.__call__","title":"<code>__call__(_parser, namespace, values, _option_string=None)</code>","text":"<p>Parse key-value pairs and store them as a dictionary in the namespace.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The argument parser object.</p> required <code>namespace</code> <code>Namespace</code> <p>The namespace to store the parsed values.</p> required <code>values</code> <code>str</code> <p>The string containing key-value pairs separated by commas.</p> required <code>option_string</code> <code>Optional[str]</code> <p>The option string, if provided.</p> required Source code in <code>lodstorage/params.py</code> <pre><code>def __call__(\n    self,\n    _parser: argparse.ArgumentParser,\n    namespace: argparse.Namespace,\n    values: str,\n    _option_string: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Parse key-value pairs and store them as a dictionary in the namespace.\n\n    Args:\n        parser (argparse.ArgumentParser): The argument parser object.\n        namespace (argparse.Namespace): The namespace to store the parsed values.\n        values (str): The string containing key-value pairs separated by commas.\n        option_string (Optional[str]): The option string, if provided.\n    \"\"\"\n    my_dict = {}\n    for kv in values.split(\",\"):\n        k, v = kv.split(\"=\")\n        my_dict[k] = v\n    setattr(namespace, self.dest, my_dict)\n</code></pre>"},{"location":"#lodstorage.plot","title":"<code>plot</code>","text":"<p>Created on 2020-07-05</p> <p>@author: wf</p>"},{"location":"#lodstorage.plot.Plot","title":"<code>Plot</code>","text":"<p>               Bases: <code>object</code></p> <p>create Plot based on counters see https://stackoverflow.com/questions/19198920/using-counter-in-python-to-build-histogram</p> Source code in <code>lodstorage/plot.py</code> <pre><code>class Plot(object):\n    \"\"\"\n    create Plot based on counters\n    see https://stackoverflow.com/questions/19198920/using-counter-in-python-to-build-histogram\n    \"\"\"\n\n    def __init__(\n        self,\n        valueList,\n        title,\n        xlabel=None,\n        ylabel=None,\n        gformat=\".png\",\n        fontsize=12,\n        plotdir=None,\n        debug=False,\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.counter = Counter(valueList)\n        self.valueList = valueList\n        self.title = title\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n        self.fontsize = fontsize\n        self.gformat = gformat\n        self.debug = debug\n        path = os.path.dirname(__file__)\n        if plotdir is not None:\n            self.plotdir = plotdir\n        else:\n            self.plotdir = path + \"/../plots/\"\n            os.makedirs(self.plotdir, exist_ok=True)\n\n    def titleMe(self):\n        \"\"\"set my title and labels\"\"\"\n        plt.title(self.title, fontsize=self.fontsize)\n        if self.xlabel is not None:\n            plt.xlabel(self.xlabel)\n        if self.ylabel is not None:\n            plt.ylabel(self.ylabel)\n\n    def showMe(self, mode=\"show\", close=True):\n        \"\"\"show me in the given mode\"\"\"\n        if mode == \"show\":\n            plt.show()\n        else:\n            plt.savefig(self.plotdir + self.title + self.gformat)\n        if close:\n            plt.close()\n\n    def barchart(self, mode=\"show\"):\n        \"\"\"barchart based histogram for the given counter\"\"\"\n        labels, values = zip(*self.counter.items())\n        indexes = np.arange(len(labels))\n        width = 1\n        self.titleMe()\n        plt.bar(indexes, values, width)\n        plt.xticks(indexes + width * 0.5, labels)\n        plt.yticks(np.arange(1, max(values) + 1, step=1))\n        self.showMe(mode)\n\n    def showDebug(self):\n        print(\"   value  list: \", self.valueList)\n        print(\"counter  items: \", self.counter.items())\n        print(\"counter values: \", self.counter.values())\n        print(\"counter   keys: \", self.counter.keys())\n\n    def hist(self, mode=\"show\"):\n        \"\"\"create histogram for the given counter\"\"\"\n        if self.debug:\n            self.showDebug()\n        self.titleMe()\n        # see https://stackoverflow.com/a/2162045/1497139\n        plt.hist(self.valueList, bins=len(self.counter.keys()))\n        self.showMe(mode)\n        pass\n</code></pre>"},{"location":"#lodstorage.plot.Plot.__init__","title":"<code>__init__(valueList, title, xlabel=None, ylabel=None, gformat='.png', fontsize=12, plotdir=None, debug=False)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def __init__(\n    self,\n    valueList,\n    title,\n    xlabel=None,\n    ylabel=None,\n    gformat=\".png\",\n    fontsize=12,\n    plotdir=None,\n    debug=False,\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.counter = Counter(valueList)\n    self.valueList = valueList\n    self.title = title\n    self.xlabel = xlabel\n    self.ylabel = ylabel\n    self.fontsize = fontsize\n    self.gformat = gformat\n    self.debug = debug\n    path = os.path.dirname(__file__)\n    if plotdir is not None:\n        self.plotdir = plotdir\n    else:\n        self.plotdir = path + \"/../plots/\"\n        os.makedirs(self.plotdir, exist_ok=True)\n</code></pre>"},{"location":"#lodstorage.plot.Plot.barchart","title":"<code>barchart(mode='show')</code>","text":"<p>barchart based histogram for the given counter</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def barchart(self, mode=\"show\"):\n    \"\"\"barchart based histogram for the given counter\"\"\"\n    labels, values = zip(*self.counter.items())\n    indexes = np.arange(len(labels))\n    width = 1\n    self.titleMe()\n    plt.bar(indexes, values, width)\n    plt.xticks(indexes + width * 0.5, labels)\n    plt.yticks(np.arange(1, max(values) + 1, step=1))\n    self.showMe(mode)\n</code></pre>"},{"location":"#lodstorage.plot.Plot.hist","title":"<code>hist(mode='show')</code>","text":"<p>create histogram for the given counter</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def hist(self, mode=\"show\"):\n    \"\"\"create histogram for the given counter\"\"\"\n    if self.debug:\n        self.showDebug()\n    self.titleMe()\n    # see https://stackoverflow.com/a/2162045/1497139\n    plt.hist(self.valueList, bins=len(self.counter.keys()))\n    self.showMe(mode)\n    pass\n</code></pre>"},{"location":"#lodstorage.plot.Plot.showMe","title":"<code>showMe(mode='show', close=True)</code>","text":"<p>show me in the given mode</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def showMe(self, mode=\"show\", close=True):\n    \"\"\"show me in the given mode\"\"\"\n    if mode == \"show\":\n        plt.show()\n    else:\n        plt.savefig(self.plotdir + self.title + self.gformat)\n    if close:\n        plt.close()\n</code></pre>"},{"location":"#lodstorage.plot.Plot.titleMe","title":"<code>titleMe()</code>","text":"<p>set my title and labels</p> Source code in <code>lodstorage/plot.py</code> <pre><code>def titleMe(self):\n    \"\"\"set my title and labels\"\"\"\n    plt.title(self.title, fontsize=self.fontsize)\n    if self.xlabel is not None:\n        plt.xlabel(self.xlabel)\n    if self.ylabel is not None:\n        plt.ylabel(self.ylabel)\n</code></pre>"},{"location":"#lodstorage.prefixes","title":"<code>prefixes</code>","text":"<p>Created on 2024-03-02</p> <p>@author: wf</p>"},{"location":"#lodstorage.prefixes.Prefixes","title":"<code>Prefixes</code>","text":"<p>Handles the generation of standard SPARQL prefix declarations for queries. This utility class simplifies the inclusion of common prefixes used in SPARQL queries by providing a method to generate the necessary PREFIX lines based on a list of prefix keys.</p> <p>The class supports a wide range of prefixes relevant to Wikidata and general RDF/SPARQL usage, including RDF, RDFS, Wikibase, Schema.org, and more. It aims to reduce redundancy and improve clarity in SPARQL query construction by centralizing prefix management.</p> <p>Methods:</p> Name Description <code>getPrefixes</code> <p>Generates SPARQL PREFIX lines for a given list of prefix keys.</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>class Prefixes:\n    \"\"\"\n    Handles the generation of standard SPARQL prefix declarations for queries.\n    This utility class simplifies the inclusion of common prefixes used in SPARQL\n    queries by providing a method to generate the necessary PREFIX lines based on\n    a list of prefix keys.\n\n    The class supports a wide range of prefixes relevant to Wikidata and general RDF/SPARQL\n    usage, including RDF, RDFS, Wikibase, Schema.org, and more. It aims to reduce redundancy\n    and improve clarity in SPARQL query construction by centralizing prefix management.\n\n    Attributes:\n        None\n\n    Methods:\n        getPrefixes(prefixes): Generates SPARQL PREFIX lines for a given list of prefix keys.\n    \"\"\"\n\n    @classmethod\n    def getPrefixes(\n        cls, prefixes=[\"rdf\", \"rdfs\", \"schema\", \"wd\", \"wdt\", \"wikibase\", \"xsd\"]\n    ) -&gt; str:\n        \"\"\"Generates SPARQL PREFIX lines for a given list of prefix keys.\n\n        This method looks up URIs for the specified prefixes from a predefined map and constructs\n        PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n        and flexible specification of the prefixes needed for a particular query.\n\n        Args:\n            prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n                Defaults to a common set of prefixes used in Wikidata queries.\n\n        Returns:\n            str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n                with a newline character. If a prefix key is not recognized, it is ignored.\n\n        Example:\n            &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n            'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\\n'\n        \"\"\"\n        prefixMap = {\n            \"bd\": \"&lt;http://www.bigdata.com/rdf#&gt;\",\n            \"cc\": \"&lt;http://creativecommons.org/ns#&gt;\",\n            \"dct\": \"&lt;http://purl.org/dc/terms/&gt;\",\n            \"geo\": \"&lt;http://www.opengis.net/ont/geosparql#&gt;\",\n            \"ontolex\": \"&lt;http://www.w3.org/ns/lemon/ontolex#&gt;\",\n            \"owl\": \"&lt;http://www.w3.org/2002/07/owl#&gt;\",\n            \"p\": \"&lt;http://www.wikidata.org/prop/&gt;\",\n            \"pq\": \"&lt;http://www.wikidata.org/prop/qualifier/&gt;\",\n            \"pqn\": \"&lt;http://www.wikidata.org/prop/qualifier/value-normalized/&gt;\",\n            \"pqv\": \"&lt;http://www.wikidata.org/prop/qualifier/value/&gt;\",\n            \"pr\": \"&lt;http://www.wikidata.org/prop/reference/&gt;\",\n            \"prn\": \"&lt;http://www.wikidata.org/prop/reference/value-normalized/&gt;\",\n            \"prov\": \"&lt;http://www.w3.org/ns/prov#&gt;\",\n            \"prv\": \"&lt;http://www.wikidata.org/prop/reference/value/&gt;\",\n            \"ps\": \"&lt;http://www.wikidata.org/prop/statement/&gt;\",\n            \"psn\": \"&lt;http://www.wikidata.org/prop/statement/value-normalized/&gt;\",\n            \"psv\": \"&lt;http://www.wikidata.org/prop/statement/value/&gt;\",\n            \"rdf\": \"&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\",\n            \"rdfs\": \"&lt;http://www.w3.org/2000/01/rdf-schema#&gt;\",\n            \"schema\": \"&lt;http://schema.org/&gt;\",\n            \"skos\": \"&lt;http://www.w3.org/2004/02/skos/core#&gt;\",\n            \"wd\": \"&lt;http://www.wikidata.org/entity/&gt;\",\n            \"wdata\": \"&lt;http://www.wikidata.org/wiki/Special:EntityData/&gt;\",\n            \"wdno\": \"&lt;http://www.wikidata.org/prop/novalue/&gt;\",\n            \"wdref\": \"&lt;http://www.wikidata.org/reference/&gt;\",\n            \"wds\": \"&lt;http://www.wikidata.org/entity/statement/&gt;\",\n            \"wdt\": \"&lt;http://www.wikidata.org/prop/direct/&gt;\",\n            \"wdtn\": \"&lt;http://www.wikidata.org/prop/direct-normalized/&gt;\",\n            \"wdv\": \"&lt;http://www.wikidata.org/value/&gt;\",\n            \"wikibase\": \"&lt;http://wikiba.se/ontology#&gt;\",\n            \"xsd\": \"&lt;http://www.w3.org/2001/XMLSchema#&gt;\",\n        }\n        # see also https://www.wikidata.org/wiki/EntitySchema:E49\n        sparql = \"\"\n        for prefix in prefixes:\n            if prefix in prefixMap:\n                sparql += f\"PREFIX {prefix}: {prefixMap[prefix]}\\n\"\n        return sparql\n</code></pre>"},{"location":"#lodstorage.prefixes.Prefixes.getPrefixes","title":"<code>getPrefixes(prefixes=['rdf', 'rdfs', 'schema', 'wd', 'wdt', 'wikibase', 'xsd'])</code>  <code>classmethod</code>","text":"<p>Generates SPARQL PREFIX lines for a given list of prefix keys.</p> <pre><code>    This method looks up URIs for the specified prefixes from a predefined map and constructs\n    PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n    and flexible specification of the prefixes needed for a particular query.\n\n    Args:\n        prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n            Defaults to a common set of prefixes used in Wikidata queries.\n\n    Returns:\n        str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n            with a newline character. If a prefix key is not recognized, it is ignored.\n\n    Example:\n        &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n        'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\n</code></pre> <p>PREFIX wdt: http://www.wikidata.org/prop/direct/ '</p> Source code in <code>lodstorage/prefixes.py</code> <pre><code>@classmethod\ndef getPrefixes(\n    cls, prefixes=[\"rdf\", \"rdfs\", \"schema\", \"wd\", \"wdt\", \"wikibase\", \"xsd\"]\n) -&gt; str:\n    \"\"\"Generates SPARQL PREFIX lines for a given list of prefix keys.\n\n    This method looks up URIs for the specified prefixes from a predefined map and constructs\n    PREFIX lines suitable for inclusion at the beginning of a SPARQL query. It allows for easy\n    and flexible specification of the prefixes needed for a particular query.\n\n    Args:\n        prefixes (list of str): A list of prefix keys for which PREFIX lines should be generated.\n            Defaults to a common set of prefixes used in Wikidata queries.\n\n    Returns:\n        str: A string containing the SPARQL PREFIX lines for the specified prefixes, each ending\n            with a newline character. If a prefix key is not recognized, it is ignored.\n\n    Example:\n        &gt;&gt;&gt; Prefixes.getPrefixes([\"wd\", \"wdt\"])\n        'PREFIX wd: &lt;http://www.wikidata.org/entity/&gt;\\nPREFIX wdt: &lt;http://www.wikidata.org/prop/direct/&gt;\\n'\n    \"\"\"\n    prefixMap = {\n        \"bd\": \"&lt;http://www.bigdata.com/rdf#&gt;\",\n        \"cc\": \"&lt;http://creativecommons.org/ns#&gt;\",\n        \"dct\": \"&lt;http://purl.org/dc/terms/&gt;\",\n        \"geo\": \"&lt;http://www.opengis.net/ont/geosparql#&gt;\",\n        \"ontolex\": \"&lt;http://www.w3.org/ns/lemon/ontolex#&gt;\",\n        \"owl\": \"&lt;http://www.w3.org/2002/07/owl#&gt;\",\n        \"p\": \"&lt;http://www.wikidata.org/prop/&gt;\",\n        \"pq\": \"&lt;http://www.wikidata.org/prop/qualifier/&gt;\",\n        \"pqn\": \"&lt;http://www.wikidata.org/prop/qualifier/value-normalized/&gt;\",\n        \"pqv\": \"&lt;http://www.wikidata.org/prop/qualifier/value/&gt;\",\n        \"pr\": \"&lt;http://www.wikidata.org/prop/reference/&gt;\",\n        \"prn\": \"&lt;http://www.wikidata.org/prop/reference/value-normalized/&gt;\",\n        \"prov\": \"&lt;http://www.w3.org/ns/prov#&gt;\",\n        \"prv\": \"&lt;http://www.wikidata.org/prop/reference/value/&gt;\",\n        \"ps\": \"&lt;http://www.wikidata.org/prop/statement/&gt;\",\n        \"psn\": \"&lt;http://www.wikidata.org/prop/statement/value-normalized/&gt;\",\n        \"psv\": \"&lt;http://www.wikidata.org/prop/statement/value/&gt;\",\n        \"rdf\": \"&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\",\n        \"rdfs\": \"&lt;http://www.w3.org/2000/01/rdf-schema#&gt;\",\n        \"schema\": \"&lt;http://schema.org/&gt;\",\n        \"skos\": \"&lt;http://www.w3.org/2004/02/skos/core#&gt;\",\n        \"wd\": \"&lt;http://www.wikidata.org/entity/&gt;\",\n        \"wdata\": \"&lt;http://www.wikidata.org/wiki/Special:EntityData/&gt;\",\n        \"wdno\": \"&lt;http://www.wikidata.org/prop/novalue/&gt;\",\n        \"wdref\": \"&lt;http://www.wikidata.org/reference/&gt;\",\n        \"wds\": \"&lt;http://www.wikidata.org/entity/statement/&gt;\",\n        \"wdt\": \"&lt;http://www.wikidata.org/prop/direct/&gt;\",\n        \"wdtn\": \"&lt;http://www.wikidata.org/prop/direct-normalized/&gt;\",\n        \"wdv\": \"&lt;http://www.wikidata.org/value/&gt;\",\n        \"wikibase\": \"&lt;http://wikiba.se/ontology#&gt;\",\n        \"xsd\": \"&lt;http://www.w3.org/2001/XMLSchema#&gt;\",\n    }\n    # see also https://www.wikidata.org/wiki/EntitySchema:E49\n    sparql = \"\"\n    for prefix in prefixes:\n        if prefix in prefixMap:\n            sparql += f\"PREFIX {prefix}: {prefixMap[prefix]}\\n\"\n    return sparql\n</code></pre>"},{"location":"#lodstorage.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#lodstorage.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True, with_start: bool = True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        if with_start:\n            self.start()\n\n    def start(self):\n        \"\"\"\n        start profiling\n        \"\"\"\n        self.starttime = time.time()\n        if self.profile:\n            print(f\"Starting {self.msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True, with_start=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>lodstorage/profiler.py</code> <pre><code>def __init__(self, msg, profile=True, with_start: bool = True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    if with_start:\n        self.start()\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.start","title":"<code>start()</code>","text":"<p>start profiling</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>def start(self):\n    \"\"\"\n    start profiling\n    \"\"\"\n    self.starttime = time.time()\n    if self.profile:\n        print(f\"Starting {self.msg} ...\")\n</code></pre>"},{"location":"#lodstorage.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>lodstorage/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#lodstorage.query","title":"<code>query</code>","text":"<p>Created on 2020-08-22</p> <p>@author: wf</p>"},{"location":"#lodstorage.query.Endpoint","title":"<code>Endpoint</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>a query endpoint</p> Source code in <code>lodstorage/query.py</code> <pre><code>class Endpoint(JSONAble):\n    \"\"\"\n    a query endpoint\n    \"\"\"\n\n    @staticmethod\n    def getSamples():\n        samples = [\n            {\n                \"name\": \"wikidata\",\n                \"lang\": \"sparql\",\n                \"endpoint\": \"https://query.wikidata.org/sparql\",\n                \"website\": \"https://query.wikidata.org/\",\n                \"database\": \"blazegraph\",\n                \"method\": \"POST\",\n                \"prefixes\": \"PREFIX bd: &lt;http://www.bigdata.com/rdf#&gt;\\nPREFIX cc: &lt;http://creativecommons.org/ns#&gt;\",\n            },\n            {\n                \"name\": \"dbis-jena\",\n                \"lang\": \"sparql\",\n                \"endpoint\": \"https://confident.dbis.rwth-aachen.de/jena/\",\n                \"website\": \"https://confident.dbis.rwth-aachen.de\",\n                \"auth\": \"BASIC\",\n                \"user\": \"secret\",\n                \"password\": \"#not public - example not usable for access#\",\n            },\n        ]\n        return samples\n\n    @classmethod\n    def getDefault(cls):\n        endpointConf = Endpoint()\n        endpointConf.fromDict(Endpoint.getSamples()[0])\n        return endpointConf\n\n    def __init__(self):\n        \"\"\"\n        constructor for setting defaults\n        \"\"\"\n        self.method = \"POST\"\n        self.lang = \"SPARQL\"\n\n    def __str__(self):\n        \"\"\"\n        Returns:\n            str: a string representation of this Endpoint\n        \"\"\"\n        text = f\"{self.name}:{self.website}:{self.endpoint}({self.method})\"\n        return text\n</code></pre>"},{"location":"#lodstorage.query.Endpoint.__init__","title":"<code>__init__()</code>","text":"<p>constructor for setting defaults</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor for setting defaults\n    \"\"\"\n    self.method = \"POST\"\n    self.lang = \"SPARQL\"\n</code></pre>"},{"location":"#lodstorage.query.Endpoint.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>a string representation of this Endpoint</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns:\n        str: a string representation of this Endpoint\n    \"\"\"\n    text = f\"{self.name}:{self.website}:{self.endpoint}({self.method})\"\n    return text\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager","title":"<code>EndpointManager</code>","text":"<p>               Bases: <code>object</code></p> <p>manages a set of SPARQL endpoints</p> Source code in <code>lodstorage/query.py</code> <pre><code>class EndpointManager(object):\n    \"\"\"\n    manages a set of SPARQL endpoints\n    \"\"\"\n\n    @staticmethod\n    def getEndpoints(\n        endpointPath: str = None, lang: str = None, with_default: bool = True\n    ):\n        \"\"\"\n        get the endpoints for the given endpointPath\n\n        Args:\n            endpointPath(str): the path to the yaml file with the endpoint configurations\n            lang(str): if lang is given filter by the given language\n            with_default(bool): if True include the default endpoints\n        \"\"\"\n        endpointPaths = YamlPath.getPaths(\n            \"endpoints.yaml\", endpointPath, with_default=with_default\n        )\n        endpoints = {}\n        for lEndpointPath in endpointPaths:\n            with open(lEndpointPath, \"r\") as stream:\n                endpointRecords = yaml.safe_load(stream)\n                for name, record in endpointRecords.items():\n                    select = True\n                    if lang is not None:\n                        select = record[\"lang\"] == lang\n                    if select:\n                        endpoint = Endpoint()\n                        endpoint.fromDict({\"name\": name, **record})\n                        endpoints[name] = endpoint\n        return endpoints\n\n    @staticmethod\n    def getEndpointNames(endpointPath=None, lang: str = None) -&gt; list:\n        \"\"\"\n        Returns a list of all available endpoint names\n        Args:\n            endpointPath(str): the path to the yaml file with the endpoint configurations\n            lang(str): if lang is given filter by the given language\n\n        \"\"\"\n        endpoints = EndpointManager.getEndpoints(endpointPath, lang=lang)\n        return list(endpoints.keys())\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager.getEndpointNames","title":"<code>getEndpointNames(endpointPath=None, lang=None)</code>  <code>staticmethod</code>","text":"<p>Returns a list of all available endpoint names Args:     endpointPath(str): the path to the yaml file with the endpoint configurations     lang(str): if lang is given filter by the given language</p> Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef getEndpointNames(endpointPath=None, lang: str = None) -&gt; list:\n    \"\"\"\n    Returns a list of all available endpoint names\n    Args:\n        endpointPath(str): the path to the yaml file with the endpoint configurations\n        lang(str): if lang is given filter by the given language\n\n    \"\"\"\n    endpoints = EndpointManager.getEndpoints(endpointPath, lang=lang)\n    return list(endpoints.keys())\n</code></pre>"},{"location":"#lodstorage.query.EndpointManager.getEndpoints","title":"<code>getEndpoints(endpointPath=None, lang=None, with_default=True)</code>  <code>staticmethod</code>","text":"<p>get the endpoints for the given endpointPath</p> <p>Parameters:</p> Name Type Description Default <code>endpointPath(str)</code> <p>the path to the yaml file with the endpoint configurations</p> required <code>lang(str)</code> <p>if lang is given filter by the given language</p> required <code>with_default(bool)</code> <p>if True include the default endpoints</p> required Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef getEndpoints(\n    endpointPath: str = None, lang: str = None, with_default: bool = True\n):\n    \"\"\"\n    get the endpoints for the given endpointPath\n\n    Args:\n        endpointPath(str): the path to the yaml file with the endpoint configurations\n        lang(str): if lang is given filter by the given language\n        with_default(bool): if True include the default endpoints\n    \"\"\"\n    endpointPaths = YamlPath.getPaths(\n        \"endpoints.yaml\", endpointPath, with_default=with_default\n    )\n    endpoints = {}\n    for lEndpointPath in endpointPaths:\n        with open(lEndpointPath, \"r\") as stream:\n            endpointRecords = yaml.safe_load(stream)\n            for name, record in endpointRecords.items():\n                select = True\n                if lang is not None:\n                    select = record[\"lang\"] == lang\n                if select:\n                    endpoint = Endpoint()\n                    endpoint.fromDict({\"name\": name, **record})\n                    endpoints[name] = endpoint\n    return endpoints\n</code></pre>"},{"location":"#lodstorage.query.Format","title":"<code>Format</code>","text":"<p>               Bases: <code>Enum</code></p> <p>the supported formats for the results to be delivered</p> Source code in <code>lodstorage/query.py</code> <pre><code>class Format(Enum):\n    \"\"\"\n    the supported formats for the results to be delivered\n    \"\"\"\n\n    csv = \"csv\"\n    json = \"json\"\n    html = \"html\"\n    xml = \"xml\"\n    tsv = \"tsv\"\n    latex = \"latex\"\n    mediawiki = \"mediawiki\"\n    raw = \"raw\"\n    github = \"github\"\n\n    def __str__(self):\n        return self.value\n</code></pre>"},{"location":"#lodstorage.query.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>object</code></p> <p>a Query e.g. for SPAQRL</p> Source code in <code>lodstorage/query.py</code> <pre><code>class Query(object):\n    \"\"\"a Query e.g. for SPAQRL\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        query: str,\n        lang=\"sparql\",\n        endpoint: str = None,\n        database: str = \"blazegraph\",\n        title: str = None,\n        description: str = None,\n        limit: int = None,\n        prefixes=None,\n        tryItUrl: str = None,\n        formats: list = None,\n        debug=False,\n    ):\n        \"\"\"\n        constructor\n        Args:\n            name(string): the name/label of the query\n            query(string): the native Query text e.g. in SPARQL\n            lang(string): the language of the query e.g. SPARQL\n            endpoint(string): the endpoint url to use\n            database(string): the type of database e.g. \"blazegraph\"\n            title(string): the header/title of the query\n            description(string): the description of the query\n            limit(int): the limit of the query default: None\n            prefixes(list): list of prefixes to be resolved\n            tryItUrl(str): the url of a \"tryit\" webpage\n            formats(list): key,value pairs of ValueFormatters to be applied\n            debug(boolean): true if debug mode should be switched on\n        \"\"\"\n        self.name = name\n        self.query = query\n        self.lang = lang\n        self.endpoint = endpoint\n        self.database = database\n        self.tryItUrl = tryItUrl\n\n        self.title = title = name if title is None else title\n        self.description = \"\" if description is None else description\n        self.limit = limit\n        self.prefixes = prefixes\n        self.debug = debug\n        self.formats = formats\n        self.formatCallBacks = []\n\n    def __str__(self):\n        queryStr = \"\\n\".join(\n            [\n                f\"{key}:{value}\"\n                for key, value in self.__dict__.items()\n                if value is not None\n            ]\n        )\n        return f\"{queryStr}\"\n\n    def addFormatCallBack(self, callback):\n        self.formatCallBacks.append(callback)\n\n    def preFormatWithCallBacks(self, lod, tablefmt: str):\n        \"\"\"\n        run the configured call backs to pre-format the given list of dicts for the given tableformat\n\n        Args:\n            lod(list): the list of dicts to handle\n            tablefmt(str): the table format (according to tabulate) to apply\n\n        \"\"\"\n        for record in lod:\n            for key in record.keys():\n                value = record[key]\n                if value is not None:\n                    for formatCallBack in self.formatCallBacks:\n                        formatCallBack(record, key, value, tablefmt)\n\n    def formatWithValueFormatters(self, lod, tablefmt: str):\n        \"\"\"\n        format the given list of Dicts with the ValueFormatters\n        \"\"\"\n        # is there anything to do?\n        if self.formats is None:\n            # no\n            return\n        # get the value Formatters that might apply here\n        valueFormatters = ValueFormatter.getFormats()\n        formatsToApply = {}\n        for valueFormatSpec in self.formats:\n            parts = valueFormatSpec.split(\":\")\n            # e.g. president:wikidata\n            keytoformat = parts[0]\n            formatName = parts[1]\n            if formatName in valueFormatters:\n                formatsToApply[keytoformat] = valueFormatters[formatName]\n        for record in lod:\n            for keytoformat in formatsToApply:\n                valueFormatter = formatsToApply[keytoformat]\n                # format all key values\n                if keytoformat == \"*\":\n                    for key in record:\n                        valueFormatter.applyFormat(record, key, tablefmt)\n                # or just a selected one\n                elif keytoformat in record:\n                    valueFormatter.applyFormat(record, keytoformat, tablefmt)\n            pass\n\n    def getTryItUrl(self, baseurl: str, database: str = \"blazegraph\"):\n        \"\"\"\n        return the \"try it!\" url for the given baseurl\n\n        Args:\n            baseurl(str): the baseurl to used\n\n        Returns:\n            str: the \"try it!\" url for the given query\n        \"\"\"\n        # https://stackoverflow.com/a/9345102/1497139\n        quoted = urllib.parse.quote(str(self.query))\n        if database == \"blazegraph\":\n            delim = \"/#\"\n        else:\n            delim = \"?query=\"\n        url = f\"{baseurl}{delim}{quoted}\"\n        return url\n\n    def getLink(self, url, title, tablefmt):\n        \"\"\"\n        convert the given url and title to a link for the given tablefmt\n\n        Args:\n            url(str): the url to convert\n            title(str): the title to show\n            tablefmt(str): the table format to use\n        \"\"\"\n        # create a safe url\n        if url is None:\n            return \"\"\n        markup = f\"{title}:{url}\"\n        if tablefmt == \"mediawiki\":\n            markup = f\"[{url} {title}]\"\n        elif tablefmt == \"github\":\n            markup = f\"[{title}]({url})\"\n        elif tablefmt == \"latex\":\n            markup = r\"\\href{%s}{%s}\" % (url, title)\n        return markup\n\n    def prefixToLink(self, lod: list, prefix: str, tablefmt: str):\n        \"\"\"\n        convert url prefixes to link according to the given table format\n        TODO - refactor as preFormat callback\n\n        Args:\n            lod(list): the list of dicts to convert\n            prefix(str): the prefix to strip\n            tablefmt(str): the tabulate tableformat to use\n\n        \"\"\"\n        for record in lod:\n            for key in record.keys():\n                value = record[key]\n                if (\n                    value is not None\n                    and isinstance(value, str)\n                    and value.startswith(prefix)\n                ):\n                    item = value.replace(prefix, \"\")\n                    uqitem = urllib.parse.unquote(item)\n                    if tablefmt == \"latex\":\n                        link = uqitem\n                    else:\n                        link = self.getLink(value, uqitem, tablefmt)\n                    record[key] = link\n\n    def asYaml(self):\n        yamlMarkup = yaml.dump(self)\n        return yamlMarkup\n\n    def asWikiSourceMarkup(self):\n        \"\"\"\n        convert me to Mediawiki markup for syntax highlighting using the \"source\" tag\n\n\n        Returns:\n            string: the Markup\n        \"\"\"\n        markup = \"&lt;source lang='%s'&gt;\\n%s\\n&lt;/source&gt;\\n\" % (self.lang, self.query)\n        return markup\n\n    def asWikiMarkup(self, listOfDicts):\n        \"\"\"\n        convert the given listOfDicts result to MediaWiki markup\n\n        Args:\n            listOfDicts(list): the list of Dicts to convert to MediaWiki markup\n\n        Returns:\n            string: the markup\n        \"\"\"\n        if self.debug:\n            print(listOfDicts)\n        mwTable = MediaWikiTable()\n        mwTable.fromListOfDicts(listOfDicts)\n        markup = mwTable.asWikiMarkup()\n        return markup\n\n    def documentQueryResult(\n        self,\n        qlod: list,\n        limit=None,\n        tablefmt: str = \"mediawiki\",\n        tryItUrl: str = None,\n        withSourceCode=True,\n        **kwArgs,\n    ):\n        \"\"\"\n        document the given query results - note that a copy of the whole list is going to be created for being able to format\n\n        Args:\n            qlod: the list of dicts result\n            limit(int): the maximum number of records to display in result tabulate\n            tablefmt(str): the table format to use\n            tryItUrl: the \"try it!\" url to show\n            withSourceCode(bool): if True document the source code\n\n        Return:\n            str: the documentation tabular text for the given parameters\n        \"\"\"\n        sourceCode = self.query\n        tryItMarkup = \"\"\n        sourceCodeHeader = \"\"\n        resultHeader = \"\"\n        title = self.title\n        if limit is not None:\n            lod = copy.deepcopy(qlod[:limit])\n        else:\n            lod = copy.deepcopy(qlod)\n        self.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n        self.formatWithValueFormatters(lod, tablefmt=tablefmt)\n        result = tabulate(lod, headers=\"keys\", tablefmt=tablefmt, **kwArgs)\n        if tryItUrl is None and hasattr(self, \"tryItUrl\"):\n            tryItUrl = self.tryItUrl\n        if tablefmt == \"github\":\n            title = f\"## {self.title}\"\n            resultHeader = \"## result\"\n        elif tablefmt == \"mediawiki\":\n            title = f\"== {self.title} ==\"\n            resultHeader = \"=== result ===\"\n        elif tablefmt == \"latex\":\n            resultHeader = \"\"\n            result = r\"\"\"\\begin{table}\n            \\caption{%s}\n            \\label{tab:%s}\n            %s\n            \\end{table}\n            \"\"\" % (\n                self.title,\n                self.name,\n                result,\n            )\n        else:\n            title = f\"{self.title}\"\n            resultHeader = \"result:\"\n        if withSourceCode:\n            tryItUrlEncoded = self.getTryItUrl(tryItUrl, self.database)\n            tryItMarkup = self.getLink(tryItUrlEncoded, \"try it!\", tablefmt)\n            if tablefmt == \"github\":\n                sourceCodeHeader = \"### query\"\n                sourceCode = f\"\"\"```{self.lang}\n{self.query}\n```\"\"\"\n            elif tablefmt == \"mediawiki\":\n                sourceCodeHeader = \"=== query ===\"\n                sourceCode = f\"\"\"&lt;source lang='{self.lang}'&gt;\n{self.query}\n&lt;/source&gt;\n\"\"\"\n            elif tablefmt == \"latex\":\n                sourceCodeHeader = (\n                    r\"see query listing \\ref{listing:%s} and result table \\ref{tab:%s}\"\n                    % (self.name, self.name)\n                )\n                sourceCode = r\"\"\"\\begin{listing}[ht]\n\\caption{%s}\n\\label{listing:%s}\n\\begin{minted}{%s}\n%s\n\\end{minted}\n%s\n\\end{listing}\n\"\"\" % (\n                    self.title,\n                    self.name,\n                    self.lang.lower(),\n                    self.query,\n                    tryItMarkup,\n                )\n            else:\n                sourceCodeHeader = \"query:\"\n                sourceCode = f\"{self.query}\"\n        if self.lang != \"sparql\":\n            tryItMarkup = \"\"\n        queryResultDocumentation = QueryResultDocumentation(\n            query=self,\n            title=title,\n            tablefmt=tablefmt,\n            tryItMarkup=tryItMarkup,\n            sourceCodeHeader=sourceCodeHeader,\n            sourceCode=sourceCode,\n            resultHeader=resultHeader,\n            result=result,\n        )\n        return queryResultDocumentation\n</code></pre>"},{"location":"#lodstorage.query.Query.__init__","title":"<code>__init__(name, query, lang='sparql', endpoint=None, database='blazegraph', title=None, description=None, limit=None, prefixes=None, tryItUrl=None, formats=None, debug=False)</code>","text":"<p>constructor Args:     name(string): the name/label of the query     query(string): the native Query text e.g. in SPARQL     lang(string): the language of the query e.g. SPARQL     endpoint(string): the endpoint url to use     database(string): the type of database e.g. \"blazegraph\"     title(string): the header/title of the query     description(string): the description of the query     limit(int): the limit of the query default: None     prefixes(list): list of prefixes to be resolved     tryItUrl(str): the url of a \"tryit\" webpage     formats(list): key,value pairs of ValueFormatters to be applied     debug(boolean): true if debug mode should be switched on</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    query: str,\n    lang=\"sparql\",\n    endpoint: str = None,\n    database: str = \"blazegraph\",\n    title: str = None,\n    description: str = None,\n    limit: int = None,\n    prefixes=None,\n    tryItUrl: str = None,\n    formats: list = None,\n    debug=False,\n):\n    \"\"\"\n    constructor\n    Args:\n        name(string): the name/label of the query\n        query(string): the native Query text e.g. in SPARQL\n        lang(string): the language of the query e.g. SPARQL\n        endpoint(string): the endpoint url to use\n        database(string): the type of database e.g. \"blazegraph\"\n        title(string): the header/title of the query\n        description(string): the description of the query\n        limit(int): the limit of the query default: None\n        prefixes(list): list of prefixes to be resolved\n        tryItUrl(str): the url of a \"tryit\" webpage\n        formats(list): key,value pairs of ValueFormatters to be applied\n        debug(boolean): true if debug mode should be switched on\n    \"\"\"\n    self.name = name\n    self.query = query\n    self.lang = lang\n    self.endpoint = endpoint\n    self.database = database\n    self.tryItUrl = tryItUrl\n\n    self.title = title = name if title is None else title\n    self.description = \"\" if description is None else description\n    self.limit = limit\n    self.prefixes = prefixes\n    self.debug = debug\n    self.formats = formats\n    self.formatCallBacks = []\n</code></pre>"},{"location":"#lodstorage.query.Query.asWikiMarkup","title":"<code>asWikiMarkup(listOfDicts)</code>","text":"<p>convert the given listOfDicts result to MediaWiki markup</p> <p>Parameters:</p> Name Type Description Default <code>listOfDicts(list)</code> <p>the list of Dicts to convert to MediaWiki markup</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the markup</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asWikiMarkup(self, listOfDicts):\n    \"\"\"\n    convert the given listOfDicts result to MediaWiki markup\n\n    Args:\n        listOfDicts(list): the list of Dicts to convert to MediaWiki markup\n\n    Returns:\n        string: the markup\n    \"\"\"\n    if self.debug:\n        print(listOfDicts)\n    mwTable = MediaWikiTable()\n    mwTable.fromListOfDicts(listOfDicts)\n    markup = mwTable.asWikiMarkup()\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.asWikiSourceMarkup","title":"<code>asWikiSourceMarkup()</code>","text":"<p>convert me to Mediawiki markup for syntax highlighting using the \"source\" tag</p> <p>Returns:</p> Name Type Description <code>string</code> <p>the Markup</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asWikiSourceMarkup(self):\n    \"\"\"\n    convert me to Mediawiki markup for syntax highlighting using the \"source\" tag\n\n\n    Returns:\n        string: the Markup\n    \"\"\"\n    markup = \"&lt;source lang='%s'&gt;\\n%s\\n&lt;/source&gt;\\n\" % (self.lang, self.query)\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.documentQueryResult","title":"<code>documentQueryResult(qlod, limit=None, tablefmt='mediawiki', tryItUrl=None, withSourceCode=True, **kwArgs)</code>","text":"<p>document the given query results - note that a copy of the whole list is going to be created for being able to format</p> <p>Parameters:</p> Name Type Description Default <code>qlod</code> <code>list</code> <p>the list of dicts result</p> required <code>limit(int)</code> <p>the maximum number of records to display in result tabulate</p> required <code>tablefmt(str)</code> <p>the table format to use</p> required <code>tryItUrl</code> <code>str</code> <p>the \"try it!\" url to show</p> <code>None</code> <code>withSourceCode(bool)</code> <p>if True document the source code</p> required Return <p>str: the documentation tabular text for the given parameters</p> Source code in <code>lodstorage/query.py</code> <pre><code>    def documentQueryResult(\n        self,\n        qlod: list,\n        limit=None,\n        tablefmt: str = \"mediawiki\",\n        tryItUrl: str = None,\n        withSourceCode=True,\n        **kwArgs,\n    ):\n        \"\"\"\n        document the given query results - note that a copy of the whole list is going to be created for being able to format\n\n        Args:\n            qlod: the list of dicts result\n            limit(int): the maximum number of records to display in result tabulate\n            tablefmt(str): the table format to use\n            tryItUrl: the \"try it!\" url to show\n            withSourceCode(bool): if True document the source code\n\n        Return:\n            str: the documentation tabular text for the given parameters\n        \"\"\"\n        sourceCode = self.query\n        tryItMarkup = \"\"\n        sourceCodeHeader = \"\"\n        resultHeader = \"\"\n        title = self.title\n        if limit is not None:\n            lod = copy.deepcopy(qlod[:limit])\n        else:\n            lod = copy.deepcopy(qlod)\n        self.preFormatWithCallBacks(lod, tablefmt=tablefmt)\n        self.formatWithValueFormatters(lod, tablefmt=tablefmt)\n        result = tabulate(lod, headers=\"keys\", tablefmt=tablefmt, **kwArgs)\n        if tryItUrl is None and hasattr(self, \"tryItUrl\"):\n            tryItUrl = self.tryItUrl\n        if tablefmt == \"github\":\n            title = f\"## {self.title}\"\n            resultHeader = \"## result\"\n        elif tablefmt == \"mediawiki\":\n            title = f\"== {self.title} ==\"\n            resultHeader = \"=== result ===\"\n        elif tablefmt == \"latex\":\n            resultHeader = \"\"\n            result = r\"\"\"\\begin{table}\n            \\caption{%s}\n            \\label{tab:%s}\n            %s\n            \\end{table}\n            \"\"\" % (\n                self.title,\n                self.name,\n                result,\n            )\n        else:\n            title = f\"{self.title}\"\n            resultHeader = \"result:\"\n        if withSourceCode:\n            tryItUrlEncoded = self.getTryItUrl(tryItUrl, self.database)\n            tryItMarkup = self.getLink(tryItUrlEncoded, \"try it!\", tablefmt)\n            if tablefmt == \"github\":\n                sourceCodeHeader = \"### query\"\n                sourceCode = f\"\"\"```{self.lang}\n{self.query}\n```\"\"\"\n            elif tablefmt == \"mediawiki\":\n                sourceCodeHeader = \"=== query ===\"\n                sourceCode = f\"\"\"&lt;source lang='{self.lang}'&gt;\n{self.query}\n&lt;/source&gt;\n\"\"\"\n            elif tablefmt == \"latex\":\n                sourceCodeHeader = (\n                    r\"see query listing \\ref{listing:%s} and result table \\ref{tab:%s}\"\n                    % (self.name, self.name)\n                )\n                sourceCode = r\"\"\"\\begin{listing}[ht]\n\\caption{%s}\n\\label{listing:%s}\n\\begin{minted}{%s}\n%s\n\\end{minted}\n%s\n\\end{listing}\n\"\"\" % (\n                    self.title,\n                    self.name,\n                    self.lang.lower(),\n                    self.query,\n                    tryItMarkup,\n                )\n            else:\n                sourceCodeHeader = \"query:\"\n                sourceCode = f\"{self.query}\"\n        if self.lang != \"sparql\":\n            tryItMarkup = \"\"\n        queryResultDocumentation = QueryResultDocumentation(\n            query=self,\n            title=title,\n            tablefmt=tablefmt,\n            tryItMarkup=tryItMarkup,\n            sourceCodeHeader=sourceCodeHeader,\n            sourceCode=sourceCode,\n            resultHeader=resultHeader,\n            result=result,\n        )\n        return queryResultDocumentation\n</code></pre>"},{"location":"#lodstorage.query.Query.formatWithValueFormatters","title":"<code>formatWithValueFormatters(lod, tablefmt)</code>","text":"<p>format the given list of Dicts with the ValueFormatters</p> Source code in <code>lodstorage/query.py</code> <pre><code>def formatWithValueFormatters(self, lod, tablefmt: str):\n    \"\"\"\n    format the given list of Dicts with the ValueFormatters\n    \"\"\"\n    # is there anything to do?\n    if self.formats is None:\n        # no\n        return\n    # get the value Formatters that might apply here\n    valueFormatters = ValueFormatter.getFormats()\n    formatsToApply = {}\n    for valueFormatSpec in self.formats:\n        parts = valueFormatSpec.split(\":\")\n        # e.g. president:wikidata\n        keytoformat = parts[0]\n        formatName = parts[1]\n        if formatName in valueFormatters:\n            formatsToApply[keytoformat] = valueFormatters[formatName]\n    for record in lod:\n        for keytoformat in formatsToApply:\n            valueFormatter = formatsToApply[keytoformat]\n            # format all key values\n            if keytoformat == \"*\":\n                for key in record:\n                    valueFormatter.applyFormat(record, key, tablefmt)\n            # or just a selected one\n            elif keytoformat in record:\n                valueFormatter.applyFormat(record, keytoformat, tablefmt)\n        pass\n</code></pre>"},{"location":"#lodstorage.query.Query.getLink","title":"<code>getLink(url, title, tablefmt)</code>","text":"<p>convert the given url and title to a link for the given tablefmt</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to convert</p> required <code>title(str)</code> <p>the title to show</p> required <code>tablefmt(str)</code> <p>the table format to use</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def getLink(self, url, title, tablefmt):\n    \"\"\"\n    convert the given url and title to a link for the given tablefmt\n\n    Args:\n        url(str): the url to convert\n        title(str): the title to show\n        tablefmt(str): the table format to use\n    \"\"\"\n    # create a safe url\n    if url is None:\n        return \"\"\n    markup = f\"{title}:{url}\"\n    if tablefmt == \"mediawiki\":\n        markup = f\"[{url} {title}]\"\n    elif tablefmt == \"github\":\n        markup = f\"[{title}]({url})\"\n    elif tablefmt == \"latex\":\n        markup = r\"\\href{%s}{%s}\" % (url, title)\n    return markup\n</code></pre>"},{"location":"#lodstorage.query.Query.getTryItUrl","title":"<code>getTryItUrl(baseurl, database='blazegraph')</code>","text":"<p>return the \"try it!\" url for the given baseurl</p> <p>Parameters:</p> Name Type Description Default <code>baseurl(str)</code> <p>the baseurl to used</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the \"try it!\" url for the given query</p> Source code in <code>lodstorage/query.py</code> <pre><code>def getTryItUrl(self, baseurl: str, database: str = \"blazegraph\"):\n    \"\"\"\n    return the \"try it!\" url for the given baseurl\n\n    Args:\n        baseurl(str): the baseurl to used\n\n    Returns:\n        str: the \"try it!\" url for the given query\n    \"\"\"\n    # https://stackoverflow.com/a/9345102/1497139\n    quoted = urllib.parse.quote(str(self.query))\n    if database == \"blazegraph\":\n        delim = \"/#\"\n    else:\n        delim = \"?query=\"\n    url = f\"{baseurl}{delim}{quoted}\"\n    return url\n</code></pre>"},{"location":"#lodstorage.query.Query.preFormatWithCallBacks","title":"<code>preFormatWithCallBacks(lod, tablefmt)</code>","text":"<p>run the configured call backs to pre-format the given list of dicts for the given tableformat</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to handle</p> required <code>tablefmt(str)</code> <p>the table format (according to tabulate) to apply</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def preFormatWithCallBacks(self, lod, tablefmt: str):\n    \"\"\"\n    run the configured call backs to pre-format the given list of dicts for the given tableformat\n\n    Args:\n        lod(list): the list of dicts to handle\n        tablefmt(str): the table format (according to tabulate) to apply\n\n    \"\"\"\n    for record in lod:\n        for key in record.keys():\n            value = record[key]\n            if value is not None:\n                for formatCallBack in self.formatCallBacks:\n                    formatCallBack(record, key, value, tablefmt)\n</code></pre>"},{"location":"#lodstorage.query.Query.prefixToLink","title":"<code>prefixToLink(lod, prefix, tablefmt)</code>","text":"<p>convert url prefixes to link according to the given table format TODO - refactor as preFormat callback</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to convert</p> required <code>prefix(str)</code> <p>the prefix to strip</p> required <code>tablefmt(str)</code> <p>the tabulate tableformat to use</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def prefixToLink(self, lod: list, prefix: str, tablefmt: str):\n    \"\"\"\n    convert url prefixes to link according to the given table format\n    TODO - refactor as preFormat callback\n\n    Args:\n        lod(list): the list of dicts to convert\n        prefix(str): the prefix to strip\n        tablefmt(str): the tabulate tableformat to use\n\n    \"\"\"\n    for record in lod:\n        for key in record.keys():\n            value = record[key]\n            if (\n                value is not None\n                and isinstance(value, str)\n                and value.startswith(prefix)\n            ):\n                item = value.replace(prefix, \"\")\n                uqitem = urllib.parse.unquote(item)\n                if tablefmt == \"latex\":\n                    link = uqitem\n                else:\n                    link = self.getLink(value, uqitem, tablefmt)\n                record[key] = link\n</code></pre>"},{"location":"#lodstorage.query.QueryManager","title":"<code>QueryManager</code>","text":"<p>               Bases: <code>object</code></p> <p>manages pre packaged Queries</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QueryManager(object):\n    \"\"\"\n    manages pre packaged Queries\n    \"\"\"\n\n    def __init__(\n        self, lang: str = None, debug=False, queriesPath=None, with_default: bool = True\n    ):\n        \"\"\"\n        Constructor\n        Args:\n            lang(str): the language to use for the queries sql or sparql\n            queriesPath(str): the path of the yaml file to load queries from\n            debug(bool): True if debug information should be shown\n            with_default(bool): if True also load the default yaml file\n        \"\"\"\n        if lang is None:\n            lang = \"sql\"\n        self.queriesByName = {}\n        self.lang = lang\n        self.debug = debug\n        queries = QueryManager.getQueries(\n            queriesPath=queriesPath, with_default=with_default\n        )\n        for name, queryDict in queries.items():\n            if self.lang in queryDict:\n                queryText = queryDict.pop(self.lang)\n                for qformat in [\"sparql\", \"sql\"]:  # drop not needed query variants\n                    if qformat in queryDict:\n                        queryDict.pop(qformat)\n                query = Query(\n                    name=name,\n                    query=queryText,\n                    lang=self.lang,\n                    **queryDict,\n                    debug=self.debug,\n                )\n                self.queriesByName[name] = query\n\n    @staticmethod\n    def getQueries(queriesPath=None, with_default: bool = True):\n        \"\"\"\n        get the queries for the given queries Path\n\n        Args:\n            queriesPath(str): the path of the yaml file to load queries from\n            with_default(bool): if True also load the default yaml file\n\n        \"\"\"\n        queriesPaths = YamlPath.getPaths(\n            \"queries.yaml\", queriesPath, with_default=with_default\n        )\n        queries = {}\n        for queriesPath in queriesPaths:\n            if os.path.isfile(queriesPath):\n                with open(queriesPath, \"r\") as stream:\n                    lqueries = yaml.safe_load(stream)\n                    for key in lqueries:\n                        queries[key] = lqueries[key]\n        return queries\n</code></pre>"},{"location":"#lodstorage.query.QueryManager.__init__","title":"<code>__init__(lang=None, debug=False, queriesPath=None, with_default=True)</code>","text":"<p>Constructor Args:     lang(str): the language to use for the queries sql or sparql     queriesPath(str): the path of the yaml file to load queries from     debug(bool): True if debug information should be shown     with_default(bool): if True also load the default yaml file</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self, lang: str = None, debug=False, queriesPath=None, with_default: bool = True\n):\n    \"\"\"\n    Constructor\n    Args:\n        lang(str): the language to use for the queries sql or sparql\n        queriesPath(str): the path of the yaml file to load queries from\n        debug(bool): True if debug information should be shown\n        with_default(bool): if True also load the default yaml file\n    \"\"\"\n    if lang is None:\n        lang = \"sql\"\n    self.queriesByName = {}\n    self.lang = lang\n    self.debug = debug\n    queries = QueryManager.getQueries(\n        queriesPath=queriesPath, with_default=with_default\n    )\n    for name, queryDict in queries.items():\n        if self.lang in queryDict:\n            queryText = queryDict.pop(self.lang)\n            for qformat in [\"sparql\", \"sql\"]:  # drop not needed query variants\n                if qformat in queryDict:\n                    queryDict.pop(qformat)\n            query = Query(\n                name=name,\n                query=queryText,\n                lang=self.lang,\n                **queryDict,\n                debug=self.debug,\n            )\n            self.queriesByName[name] = query\n</code></pre>"},{"location":"#lodstorage.query.QueryManager.getQueries","title":"<code>getQueries(queriesPath=None, with_default=True)</code>  <code>staticmethod</code>","text":"<p>get the queries for the given queries Path</p> <p>Parameters:</p> Name Type Description Default <code>queriesPath(str)</code> <p>the path of the yaml file to load queries from</p> required <code>with_default(bool)</code> <p>if True also load the default yaml file</p> required Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef getQueries(queriesPath=None, with_default: bool = True):\n    \"\"\"\n    get the queries for the given queries Path\n\n    Args:\n        queriesPath(str): the path of the yaml file to load queries from\n        with_default(bool): if True also load the default yaml file\n\n    \"\"\"\n    queriesPaths = YamlPath.getPaths(\n        \"queries.yaml\", queriesPath, with_default=with_default\n    )\n    queries = {}\n    for queriesPath in queriesPaths:\n        if os.path.isfile(queriesPath):\n            with open(queriesPath, \"r\") as stream:\n                lqueries = yaml.safe_load(stream)\n                for key in lqueries:\n                    queries[key] = lqueries[key]\n    return queries\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation","title":"<code>QueryResultDocumentation</code>","text":"<p>documentation of a query result</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QueryResultDocumentation:\n    \"\"\"\n    documentation of a query result\n    \"\"\"\n\n    def __init__(\n        self,\n        query,\n        title: str,\n        tablefmt: str,\n        tryItMarkup: str,\n        sourceCodeHeader: str,\n        sourceCode: str,\n        resultHeader: str,\n        result: str,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            query(Query): the query to be documented\n            title(str): the title markup\n            tablefmt(str): the tableformat that has been used\n            tryItMarkup: the \"try it!\" markup to show\n            sourceCodeHeader(str): the header title to use for the sourceCode\n            sourceCode(str): the sourceCode\n            resultCodeHeader(str): the header title to use for the result\n            result(str): the result header\n\n        \"\"\"\n        self.query = query\n        self.title = title\n        self.tablefmt = tablefmt\n        self.tryItMarkup = f\"\\n{tryItMarkup}\"\n        self.sourceCodeHeader = sourceCodeHeader\n        self.sourceCode = sourceCode\n        self.resultHeader = resultHeader\n        self.result = result\n\n    @staticmethod\n    def uniCode2Latex(text: str, withConvert: bool = False) -&gt; str:\n        \"\"\"\n        converts unicode text to latex and\n        fixes UTF-8 chars for latex in a certain range:\n            \u2080:$_0$ ... \u2089:$_9$\n\n        see https://github.com/phfaist/pylatexenc/issues/72\n\n        Args:\n            text(str): the string to fix\n            withConvert(bool): if unicode to latex libary conversion should be used\n\n        Return:\n            str: latex presentation of UTF-8 char\n        \"\"\"\n        for code in range(8320, 8330):\n            text = text.replace(chr(code), f\"$_{code-8320}$\")\n        if withConvert:\n            latex = unicode_to_latex(text)\n            # workaround {\\textbackslash} being returned\n            # latex=latex.replace(\"{\\\\textbackslash}\",'\\\\')\n            text = latex\n        return text\n\n    def __str__(self):\n        \"\"\"\n        simple string representation\n        \"\"\"\n        return self.asText()\n\n    def asText(self):\n        \"\"\"\n        return my text representation\n\n        Returns:\n            str: description, sourceCodeHeader, sourceCode, tryIt link and result table\n        \"\"\"\n        text = f\"{self.title}\\n{self.query.description}\\n{self.sourceCodeHeader}\\n{self.sourceCode}{self.tryItMarkup}\\n{self.resultHeader}\\n{self.result}\"\n        fixedStr = (\n            self.uniCode2Latex(text) if self.tablefmt.lower() == \"latex\" else text\n        )\n        return fixedStr\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.__init__","title":"<code>__init__(query, title, tablefmt, tryItMarkup, sourceCodeHeader, sourceCode, resultHeader, result)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>query(Query)</code> <p>the query to be documented</p> required <code>title(str)</code> <p>the title markup</p> required <code>tablefmt(str)</code> <p>the tableformat that has been used</p> required <code>tryItMarkup</code> <code>str</code> <p>the \"try it!\" markup to show</p> required <code>sourceCodeHeader(str)</code> <p>the header title to use for the sourceCode</p> required <code>sourceCode(str)</code> <p>the sourceCode</p> required <code>resultCodeHeader(str)</code> <p>the header title to use for the result</p> required <code>result(str)</code> <p>the result header</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self,\n    query,\n    title: str,\n    tablefmt: str,\n    tryItMarkup: str,\n    sourceCodeHeader: str,\n    sourceCode: str,\n    resultHeader: str,\n    result: str,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        query(Query): the query to be documented\n        title(str): the title markup\n        tablefmt(str): the tableformat that has been used\n        tryItMarkup: the \"try it!\" markup to show\n        sourceCodeHeader(str): the header title to use for the sourceCode\n        sourceCode(str): the sourceCode\n        resultCodeHeader(str): the header title to use for the result\n        result(str): the result header\n\n    \"\"\"\n    self.query = query\n    self.title = title\n    self.tablefmt = tablefmt\n    self.tryItMarkup = f\"\\n{tryItMarkup}\"\n    self.sourceCodeHeader = sourceCodeHeader\n    self.sourceCode = sourceCode\n    self.resultHeader = resultHeader\n    self.result = result\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.__str__","title":"<code>__str__()</code>","text":"<p>simple string representation</p> Source code in <code>lodstorage/query.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    simple string representation\n    \"\"\"\n    return self.asText()\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.asText","title":"<code>asText()</code>","text":"<p>return my text representation</p> <p>Returns:</p> Name Type Description <code>str</code> <p>description, sourceCodeHeader, sourceCode, tryIt link and result table</p> Source code in <code>lodstorage/query.py</code> <pre><code>def asText(self):\n    \"\"\"\n    return my text representation\n\n    Returns:\n        str: description, sourceCodeHeader, sourceCode, tryIt link and result table\n    \"\"\"\n    text = f\"{self.title}\\n{self.query.description}\\n{self.sourceCodeHeader}\\n{self.sourceCode}{self.tryItMarkup}\\n{self.resultHeader}\\n{self.result}\"\n    fixedStr = (\n        self.uniCode2Latex(text) if self.tablefmt.lower() == \"latex\" else text\n    )\n    return fixedStr\n</code></pre>"},{"location":"#lodstorage.query.QueryResultDocumentation.uniCode2Latex","title":"<code>uniCode2Latex(text, withConvert=False)</code>  <code>staticmethod</code>","text":"<p>converts unicode text to latex and fixes UTF-8 chars for latex in a certain range:     \u2080:$_0$ ... \u2089:$_9$</p> <p>see https://github.com/phfaist/pylatexenc/issues/72</p> <p>Parameters:</p> Name Type Description Default <code>text(str)</code> <p>the string to fix</p> required <code>withConvert(bool)</code> <p>if unicode to latex libary conversion should be used</p> required Return <p>str: latex presentation of UTF-8 char</p> Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef uniCode2Latex(text: str, withConvert: bool = False) -&gt; str:\n    \"\"\"\n    converts unicode text to latex and\n    fixes UTF-8 chars for latex in a certain range:\n        \u2080:$_0$ ... \u2089:$_9$\n\n    see https://github.com/phfaist/pylatexenc/issues/72\n\n    Args:\n        text(str): the string to fix\n        withConvert(bool): if unicode to latex libary conversion should be used\n\n    Return:\n        str: latex presentation of UTF-8 char\n    \"\"\"\n    for code in range(8320, 8330):\n        text = text.replace(chr(code), f\"$_{code-8320}$\")\n    if withConvert:\n        latex = unicode_to_latex(text)\n        # workaround {\\textbackslash} being returned\n        # latex=latex.replace(\"{\\\\textbackslash}\",'\\\\')\n        text = latex\n    return text\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight","title":"<code>QuerySyntaxHighlight</code>","text":"<p>Syntax highlighting for queries with pygments</p> Source code in <code>lodstorage/query.py</code> <pre><code>class QuerySyntaxHighlight:\n    \"\"\"\n    Syntax highlighting for queries with pygments\n    \"\"\"\n\n    def __init__(self, query, highlightFormat: str = \"html\"):\n        \"\"\"\n        construct me for the given query and highlightFormat\n\n        Args:\n            query(Query): the query to do the syntax highlighting for\n            highlightFormat(str): the highlight format to be used\n        \"\"\"\n        self.query = query\n        self.highlightFormat = highlightFormat\n        self.lexer = get_lexer_by_name(self.query.lang)\n        if self.highlightFormat == \"html\":\n            self.formatter = HtmlFormatter()\n        elif self.highlightFormat == \"latex\":\n            self.formatter = LatexFormatter()\n\n    def highlight(self):\n        \"\"\"\n        Returns:\n            str: the result of the syntax highlighting with pygments\n        \"\"\"\n        syntaxResult = highlight(self.query.query, self.lexer, self.formatter)\n        return syntaxResult\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight.__init__","title":"<code>__init__(query, highlightFormat='html')</code>","text":"<p>construct me for the given query and highlightFormat</p> <p>Parameters:</p> Name Type Description Default <code>query(Query)</code> <p>the query to do the syntax highlighting for</p> required <code>highlightFormat(str)</code> <p>the highlight format to be used</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(self, query, highlightFormat: str = \"html\"):\n    \"\"\"\n    construct me for the given query and highlightFormat\n\n    Args:\n        query(Query): the query to do the syntax highlighting for\n        highlightFormat(str): the highlight format to be used\n    \"\"\"\n    self.query = query\n    self.highlightFormat = highlightFormat\n    self.lexer = get_lexer_by_name(self.query.lang)\n    if self.highlightFormat == \"html\":\n        self.formatter = HtmlFormatter()\n    elif self.highlightFormat == \"latex\":\n        self.formatter = LatexFormatter()\n</code></pre>"},{"location":"#lodstorage.query.QuerySyntaxHighlight.highlight","title":"<code>highlight()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <p>the result of the syntax highlighting with pygments</p> Source code in <code>lodstorage/query.py</code> <pre><code>def highlight(self):\n    \"\"\"\n    Returns:\n        str: the result of the syntax highlighting with pygments\n    \"\"\"\n    syntaxResult = highlight(self.query.query, self.lexer, self.formatter)\n    return syntaxResult\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter","title":"<code>ValueFormatter</code>","text":"<p>a value Formatter</p> Source code in <code>lodstorage/query.py</code> <pre><code>class ValueFormatter:\n    \"\"\"\n    a value Formatter\n    \"\"\"\n\n    home = str(Path.home())\n    # additional endpoints from users endpoint configuration\n    formatsPath = f\"{os.path.dirname(__file__)}/../sampledata/formats.yaml\"\n    valueFormats = None\n\n    def __init__(\n        self,\n        name: str,\n        formatString: str,\n        regexps: list = None,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            fstring(str): the format String to use\n            regexps(list): the regular expressions to apply\n        \"\"\"\n        self.name = name\n        self.regexps = regexps\n        self.formatString = formatString\n\n    @classmethod\n    def fromDict(cls, name: str, record: dict):\n        \"\"\"\n        create a ValueFormatter from the given dict\n        \"\"\"\n        if \"regexps\" in record:\n            regexps = record[\"regexps\"]\n        else:\n            regexps = []\n        vf = ValueFormatter(name=name, formatString=record[\"format\"], regexps=regexps)\n        return vf\n\n    @classmethod\n    def getFormats(cls, formatsPath: str = None) -&gt; dict:\n        \"\"\"\n        get the available ValueFormatters\n\n        Args:\n            formatsPath(str): the path to the yaml file to read the format specs from\n        Returns:\n            dict: a map for ValueFormatters by formatter Name\n        \"\"\"\n        if cls.valueFormats is None:\n            valueFormats = {}\n            formatPaths = YamlPath.getPaths(\"formats.yaml\", formatsPath)\n            for formatPath in formatPaths:\n                with open(formatPath, \"r\", encoding=\"utf-8\") as stream:\n                    valueFormatRecords = yaml.safe_load(stream)\n                    for valueFormatKey, valueFormatRecord in valueFormatRecords.items():\n                        valueFormats[valueFormatKey] = ValueFormatter.fromDict(\n                            name=valueFormatKey, record=valueFormatRecord\n                        )\n            cls.valueFormats = valueFormats\n        return cls.valueFormats\n\n    def applyFormat(self, record, key, resultFormat: Format):\n        \"\"\"\n        apply the given format to the given record\n\n        Args:\n            record(dict): the record to handle\n            key(str): the property key\n            resultFormat(str): the resultFormat Style to apply\n        \"\"\"\n        if key in record:\n            value = record[key]\n            if value is not None and isinstance(value, str):\n                # if there are no regular expressions specified always format\n                doformat = len(self.regexps) == 0\n                for regexp in self.regexps:\n                    try:\n                        vmatch = re.match(regexp, value)\n                        if vmatch:\n                            # we found a match and will format it if the value is not none\n                            doformat = True\n                            value = vmatch.group(\"value\")\n                    except Exception as ex:\n                        print(\n                            f\"ValueFormatter: {self.name}\\nInvalid regular expression:{regexp}\\n{str(ex)}\",\n                            file=sys.stderr,\n                        )\n                if value is not None and doformat:\n                    link = self.formatString.format(value=value)\n                    newValue = None\n                    if resultFormat == \"github\":\n                        newValue = f\"[{value}]({link})\"\n                    elif resultFormat == \"mediawiki\":\n                        newValue = f\"[{link} {value}]\"\n                    elif resultFormat == \"latex\":\n                        newValue = f\"\\href{{{link}}}{{{value}}}\"\n                    if newValue is not None:\n                        record[key] = newValue\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.__init__","title":"<code>__init__(name, formatString, regexps=None)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>fstring(str)</code> <p>the format String to use</p> required <code>regexps(list)</code> <p>the regular expressions to apply</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    formatString: str,\n    regexps: list = None,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        fstring(str): the format String to use\n        regexps(list): the regular expressions to apply\n    \"\"\"\n    self.name = name\n    self.regexps = regexps\n    self.formatString = formatString\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.applyFormat","title":"<code>applyFormat(record, key, resultFormat)</code>","text":"<p>apply the given format to the given record</p> <p>Parameters:</p> Name Type Description Default <code>record(dict)</code> <p>the record to handle</p> required <code>key(str)</code> <p>the property key</p> required <code>resultFormat(str)</code> <p>the resultFormat Style to apply</p> required Source code in <code>lodstorage/query.py</code> <pre><code>def applyFormat(self, record, key, resultFormat: Format):\n    \"\"\"\n    apply the given format to the given record\n\n    Args:\n        record(dict): the record to handle\n        key(str): the property key\n        resultFormat(str): the resultFormat Style to apply\n    \"\"\"\n    if key in record:\n        value = record[key]\n        if value is not None and isinstance(value, str):\n            # if there are no regular expressions specified always format\n            doformat = len(self.regexps) == 0\n            for regexp in self.regexps:\n                try:\n                    vmatch = re.match(regexp, value)\n                    if vmatch:\n                        # we found a match and will format it if the value is not none\n                        doformat = True\n                        value = vmatch.group(\"value\")\n                except Exception as ex:\n                    print(\n                        f\"ValueFormatter: {self.name}\\nInvalid regular expression:{regexp}\\n{str(ex)}\",\n                        file=sys.stderr,\n                    )\n            if value is not None and doformat:\n                link = self.formatString.format(value=value)\n                newValue = None\n                if resultFormat == \"github\":\n                    newValue = f\"[{value}]({link})\"\n                elif resultFormat == \"mediawiki\":\n                    newValue = f\"[{link} {value}]\"\n                elif resultFormat == \"latex\":\n                    newValue = f\"\\href{{{link}}}{{{value}}}\"\n                if newValue is not None:\n                    record[key] = newValue\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.fromDict","title":"<code>fromDict(name, record)</code>  <code>classmethod</code>","text":"<p>create a ValueFormatter from the given dict</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef fromDict(cls, name: str, record: dict):\n    \"\"\"\n    create a ValueFormatter from the given dict\n    \"\"\"\n    if \"regexps\" in record:\n        regexps = record[\"regexps\"]\n    else:\n        regexps = []\n    vf = ValueFormatter(name=name, formatString=record[\"format\"], regexps=regexps)\n    return vf\n</code></pre>"},{"location":"#lodstorage.query.ValueFormatter.getFormats","title":"<code>getFormats(formatsPath=None)</code>  <code>classmethod</code>","text":"<p>get the available ValueFormatters</p> <p>Parameters:</p> Name Type Description Default <code>formatsPath(str)</code> <p>the path to the yaml file to read the format specs from</p> required <p>Returns:     dict: a map for ValueFormatters by formatter Name</p> Source code in <code>lodstorage/query.py</code> <pre><code>@classmethod\ndef getFormats(cls, formatsPath: str = None) -&gt; dict:\n    \"\"\"\n    get the available ValueFormatters\n\n    Args:\n        formatsPath(str): the path to the yaml file to read the format specs from\n    Returns:\n        dict: a map for ValueFormatters by formatter Name\n    \"\"\"\n    if cls.valueFormats is None:\n        valueFormats = {}\n        formatPaths = YamlPath.getPaths(\"formats.yaml\", formatsPath)\n        for formatPath in formatPaths:\n            with open(formatPath, \"r\", encoding=\"utf-8\") as stream:\n                valueFormatRecords = yaml.safe_load(stream)\n                for valueFormatKey, valueFormatRecord in valueFormatRecords.items():\n                    valueFormats[valueFormatKey] = ValueFormatter.fromDict(\n                        name=valueFormatKey, record=valueFormatRecord\n                    )\n        cls.valueFormats = valueFormats\n    return cls.valueFormats\n</code></pre>"},{"location":"#lodstorage.query.YamlPath","title":"<code>YamlPath</code>","text":"Source code in <code>lodstorage/query.py</code> <pre><code>class YamlPath:\n    @staticmethod\n    def getPaths(yamlFileName: str, yamlPath: str = None, with_default: bool = True):\n        \"\"\"\n        Args:\n            yamlFileName (str): The name of the YAML file to read from if (any) - legacy way to specify name\n            yamlPath (str, optional): The full path to read from. Defaults to None.\n            with_default (bool, optional): Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.\n\n        \"\"\"\n        if yamlPath is None:\n            yamlPath = f\"{os.path.dirname(__file__)}/../sampledata/{yamlFileName}\"\n        yamlPaths = [yamlPath]\n        if with_default:\n            home = str(Path.home())\n            # additional yamls from users yaml configuration\n            homepath = f\"{home}/.pylodstorage/{yamlFileName}\"\n            if os.path.isfile(homepath):\n                yamlPaths.append(homepath)\n        return yamlPaths\n</code></pre>"},{"location":"#lodstorage.query.YamlPath.getPaths","title":"<code>getPaths(yamlFileName, yamlPath=None, with_default=True)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>yamlFileName</code> <code>str</code> <p>The name of the YAML file to read from if (any) - legacy way to specify name</p> required <code>yamlPath</code> <code>str</code> <p>The full path to read from. Defaults to None.</p> <code>None</code> <code>with_default</code> <code>bool</code> <p>Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.</p> <code>True</code> Source code in <code>lodstorage/query.py</code> <pre><code>@staticmethod\ndef getPaths(yamlFileName: str, yamlPath: str = None, with_default: bool = True):\n    \"\"\"\n    Args:\n        yamlFileName (str): The name of the YAML file to read from if (any) - legacy way to specify name\n        yamlPath (str, optional): The full path to read from. Defaults to None.\n        with_default (bool, optional): Whether to include paths from the default location .pylodstorage in the Home directory. Defaults to True.\n\n    \"\"\"\n    if yamlPath is None:\n        yamlPath = f\"{os.path.dirname(__file__)}/../sampledata/{yamlFileName}\"\n    yamlPaths = [yamlPath]\n    if with_default:\n        home = str(Path.home())\n        # additional yamls from users yaml configuration\n        homepath = f\"{home}/.pylodstorage/{yamlFileName}\"\n        if os.path.isfile(homepath):\n            yamlPaths.append(homepath)\n    return yamlPaths\n</code></pre>"},{"location":"#lodstorage.querymain","title":"<code>querymain</code>","text":"<p>Created on 2022-02-13</p> <p>@author: wf</p>"},{"location":"#lodstorage.querymain.QueryMain","title":"<code>QueryMain</code>","text":"<p>Commandline handler</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>class QueryMain:\n    \"\"\"\n    Commandline handler\n    \"\"\"\n\n    @classmethod\n    def main(cls, args):\n        \"\"\"\n        command line activation with parsed args\n\n        Args:\n            args(list): the command line arguments\n        \"\"\"\n        debug = args.debug\n        endpoints = EndpointManager.getEndpoints(args.endpointPath)\n        qm = QueryManager(lang=args.language, debug=debug, queriesPath=args.queriesPath)\n        query = None\n        queryCode = args.query\n        formats = None\n        # preload ValueFormatter\n        ValueFormatter.getFormats(args.formatsPath)\n        if args.list:\n            for name, query in qm.queriesByName.items():\n                print(f\"{name}:{query.title}\")\n        elif args.listEndpoints:\n            # list endpoints\n            for endpoint in endpoints.values():\n                if hasattr(endpoint, \"lang\") and endpoint.lang == args.language:\n                    print(endpoint)\n\n        elif args.queryName is not None:\n            if debug or args.showQuery:\n                print(f\"named query {args.queryName}:\")\n            if args.queryName not in qm.queriesByName:\n                raise Exception(f\"named query {args.queryName} not available\")\n            query = qm.queriesByName[args.queryName]\n            if query.limit is None and args.limit is not None:\n                query.limit = args.limit\n            formats = query.formats\n            queryCode = query.query\n            if debug or args.showQuery:\n                if hasattr(query, \"description\") and query.description is not None:\n                    print(query.description)\n        if query is None:\n            name = \"?\"\n            if queryCode is None and args.queryFile is not None:\n                queryFilePath = Path(args.queryFile)\n                queryCode = queryFilePath.read_text()\n                name = queryFilePath.stem\n            query = Query(name=\"?\", query=queryCode, lang=args.language)\n\n        if queryCode:\n            params = Params(query.query)\n            if params.has_params:\n                if not args.params:\n                    raise Exception(f\"{query.name} needs parameters\")\n                else:\n                    params.set(args.params)\n                    query.query = params.apply_parameters()\n                    queryCode = query.query\n            if debug or args.showQuery:\n                print(f\"{args.language}:\\n{query.query}\")\n            endpointConf = Endpoint()\n            endpointConf.method = \"POST\"\n            if args.endpointName:\n                endpointConf = endpoints.get(args.endpointName)\n                query.tryItUrl = endpointConf.website\n                query.database = endpointConf.database\n            else:\n                endpointConf.endpoint = query.endpoint\n            if args.method:\n                endpointConf.method = args.method\n            if query.limit:\n                if \"limit\" in queryCode or \"LIMIT\" in queryCode:\n                    queryCode = re.sub(\n                        r\"(limit|LIMIT)\\s+(\\d+)\", f\"LIMIT {query.limit}\", queryCode\n                    )\n                else:\n                    queryCode += f\"\\nLIMIT {query.limit}\"\n            if args.language == \"sparql\":\n                sparql = SPARQL.fromEndpointConf(endpointConf)\n                if args.prefixes and endpointConf is not None:\n                    queryCode = f\"{endpointConf.prefixes}\\n{queryCode}\"\n                if args.raw:\n                    qres = cls.rawQuery(\n                        endpointConf,\n                        query=query.query,\n                        resultFormat=args.format,\n                        mimeType=args.mimeType,\n                    )\n                    print(qres)\n                    return\n                if \"wikidata\" in args.endpointName and formats is None:\n                    formats = [\"*:wikidata\"]\n                qlod = sparql.queryAsListOfDicts(queryCode)\n            elif args.language == \"sql\":\n                sqlDB = SQLDB(endpointConf.endpoint)\n                qlod = sqlDB.query(queryCode)\n            else:\n                raise Exception(f\"language {args.language} not known/supported\")\n            if args.format is Format.csv:\n                csv = CSV.toCSV(qlod)\n                print(csv)\n            elif args.format in [Format.latex, Format.github, Format.mediawiki]:\n                doc = query.documentQueryResult(\n                    qlod, tablefmt=str(args.format), floatfmt=\".0f\"\n                )\n                docstr = doc.asText()\n                print(docstr)\n            elif args.format in [Format.json] or args.format is None:  # set as default\n                # https://stackoverflow.com/a/36142844/1497139\n                print(json.dumps(qlod, indent=2, sort_keys=True, default=str))\n            elif args.format in [Format.xml]:\n                lod2xml = Lod2Xml(qlod)\n                xml = lod2xml.asXml()\n                print(xml)\n\n            else:\n                raise Exception(f\"format {args.format} not supported yet\")\n\n    @staticmethod\n    def rawQuery(endpointConf, query, resultFormat, mimeType, timeout: float = 10.0):\n        \"\"\"\n        returns raw result of the endpoint\n\n        Args:\n            endpointConf: EndPoint\n            query(str): query\n            resultFormat(str): format of the result\n            mimeType(str): mimeType\n            timoeout(float): timeout in seconds\n\n        Returns:\n            raw result of the query\n        \"\"\"\n        params = {\"query\": query, \"format\": resultFormat}\n        payload = {}\n        if mimeType:\n            headers = {\"Accept\": mimeType}\n        else:\n            headers = {}\n        endpoint = endpointConf.endpoint\n        method = endpointConf.method\n        response = requests.request(\n            method,\n            endpoint,\n            headers=headers,\n            data=payload,\n            params=params,\n            timeout=timeout,\n        )\n        return response.text\n</code></pre>"},{"location":"#lodstorage.querymain.QueryMain.main","title":"<code>main(args)</code>  <code>classmethod</code>","text":"<p>command line activation with parsed args</p> <p>Parameters:</p> Name Type Description Default <code>args(list)</code> <p>the command line arguments</p> required Source code in <code>lodstorage/querymain.py</code> <pre><code>@classmethod\ndef main(cls, args):\n    \"\"\"\n    command line activation with parsed args\n\n    Args:\n        args(list): the command line arguments\n    \"\"\"\n    debug = args.debug\n    endpoints = EndpointManager.getEndpoints(args.endpointPath)\n    qm = QueryManager(lang=args.language, debug=debug, queriesPath=args.queriesPath)\n    query = None\n    queryCode = args.query\n    formats = None\n    # preload ValueFormatter\n    ValueFormatter.getFormats(args.formatsPath)\n    if args.list:\n        for name, query in qm.queriesByName.items():\n            print(f\"{name}:{query.title}\")\n    elif args.listEndpoints:\n        # list endpoints\n        for endpoint in endpoints.values():\n            if hasattr(endpoint, \"lang\") and endpoint.lang == args.language:\n                print(endpoint)\n\n    elif args.queryName is not None:\n        if debug or args.showQuery:\n            print(f\"named query {args.queryName}:\")\n        if args.queryName not in qm.queriesByName:\n            raise Exception(f\"named query {args.queryName} not available\")\n        query = qm.queriesByName[args.queryName]\n        if query.limit is None and args.limit is not None:\n            query.limit = args.limit\n        formats = query.formats\n        queryCode = query.query\n        if debug or args.showQuery:\n            if hasattr(query, \"description\") and query.description is not None:\n                print(query.description)\n    if query is None:\n        name = \"?\"\n        if queryCode is None and args.queryFile is not None:\n            queryFilePath = Path(args.queryFile)\n            queryCode = queryFilePath.read_text()\n            name = queryFilePath.stem\n        query = Query(name=\"?\", query=queryCode, lang=args.language)\n\n    if queryCode:\n        params = Params(query.query)\n        if params.has_params:\n            if not args.params:\n                raise Exception(f\"{query.name} needs parameters\")\n            else:\n                params.set(args.params)\n                query.query = params.apply_parameters()\n                queryCode = query.query\n        if debug or args.showQuery:\n            print(f\"{args.language}:\\n{query.query}\")\n        endpointConf = Endpoint()\n        endpointConf.method = \"POST\"\n        if args.endpointName:\n            endpointConf = endpoints.get(args.endpointName)\n            query.tryItUrl = endpointConf.website\n            query.database = endpointConf.database\n        else:\n            endpointConf.endpoint = query.endpoint\n        if args.method:\n            endpointConf.method = args.method\n        if query.limit:\n            if \"limit\" in queryCode or \"LIMIT\" in queryCode:\n                queryCode = re.sub(\n                    r\"(limit|LIMIT)\\s+(\\d+)\", f\"LIMIT {query.limit}\", queryCode\n                )\n            else:\n                queryCode += f\"\\nLIMIT {query.limit}\"\n        if args.language == \"sparql\":\n            sparql = SPARQL.fromEndpointConf(endpointConf)\n            if args.prefixes and endpointConf is not None:\n                queryCode = f\"{endpointConf.prefixes}\\n{queryCode}\"\n            if args.raw:\n                qres = cls.rawQuery(\n                    endpointConf,\n                    query=query.query,\n                    resultFormat=args.format,\n                    mimeType=args.mimeType,\n                )\n                print(qres)\n                return\n            if \"wikidata\" in args.endpointName and formats is None:\n                formats = [\"*:wikidata\"]\n            qlod = sparql.queryAsListOfDicts(queryCode)\n        elif args.language == \"sql\":\n            sqlDB = SQLDB(endpointConf.endpoint)\n            qlod = sqlDB.query(queryCode)\n        else:\n            raise Exception(f\"language {args.language} not known/supported\")\n        if args.format is Format.csv:\n            csv = CSV.toCSV(qlod)\n            print(csv)\n        elif args.format in [Format.latex, Format.github, Format.mediawiki]:\n            doc = query.documentQueryResult(\n                qlod, tablefmt=str(args.format), floatfmt=\".0f\"\n            )\n            docstr = doc.asText()\n            print(docstr)\n        elif args.format in [Format.json] or args.format is None:  # set as default\n            # https://stackoverflow.com/a/36142844/1497139\n            print(json.dumps(qlod, indent=2, sort_keys=True, default=str))\n        elif args.format in [Format.xml]:\n            lod2xml = Lod2Xml(qlod)\n            xml = lod2xml.asXml()\n            print(xml)\n\n        else:\n            raise Exception(f\"format {args.format} not supported yet\")\n</code></pre>"},{"location":"#lodstorage.querymain.QueryMain.rawQuery","title":"<code>rawQuery(endpointConf, query, resultFormat, mimeType, timeout=10.0)</code>  <code>staticmethod</code>","text":"<p>returns raw result of the endpoint</p> <p>Parameters:</p> Name Type Description Default <code>endpointConf</code> <p>EndPoint</p> required <code>query(str)</code> <p>query</p> required <code>resultFormat(str)</code> <p>format of the result</p> required <code>mimeType(str)</code> <p>mimeType</p> required <code>timoeout(float)</code> <p>timeout in seconds</p> required <p>Returns:</p> Type Description <p>raw result of the query</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>@staticmethod\ndef rawQuery(endpointConf, query, resultFormat, mimeType, timeout: float = 10.0):\n    \"\"\"\n    returns raw result of the endpoint\n\n    Args:\n        endpointConf: EndPoint\n        query(str): query\n        resultFormat(str): format of the result\n        mimeType(str): mimeType\n        timoeout(float): timeout in seconds\n\n    Returns:\n        raw result of the query\n    \"\"\"\n    params = {\"query\": query, \"format\": resultFormat}\n    payload = {}\n    if mimeType:\n        headers = {\"Accept\": mimeType}\n    else:\n        headers = {}\n    endpoint = endpointConf.endpoint\n    method = endpointConf.method\n    response = requests.request(\n        method,\n        endpoint,\n        headers=headers,\n        data=payload,\n        params=params,\n        timeout=timeout,\n    )\n    return response.text\n</code></pre>"},{"location":"#lodstorage.querymain.main","title":"<code>main(argv=None, lang=None)</code>","text":"<p>main program.</p> <p>commandline access to List of Dicts / Linked Open Data Queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def main(argv=None, lang=None):  # IGNORE:C0111\n    \"\"\"\n    main program.\n\n    commandline access to List of Dicts / Linked Open Data Queries\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = os.path.basename(__file__)\n    program_version = \"v%s\" % __version__\n    program_build_date = str(__updated__)\n    program_version_message = \"%%(prog)s %s (%s)\" % (\n        program_version,\n        program_build_date,\n    )\n    program_shortdesc = (\n        \"commandline query of endpoints in diverse languages such as SPARQL/SQL\"\n    )\n    user_name = \"Wolfgang Fahl\"\n    program_license = \"\"\"%s\n\n  Created by %s on %s.\n  Copyright 2020-2024 Wolfgang Fahl. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\n\nUSAGE\n\"\"\" % (\n        program_shortdesc,\n        user_name,\n        str(__date__),\n    )\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(\n            description=program_license, formatter_class=RawDescriptionHelpFormatter\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            dest=\"debug\",\n            action=\"store_true\",\n            help=\"set debug [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-ep\",\n            \"--endpointPath\",\n            default=None,\n            help=\"path to yaml file to configure endpoints to use for queries\",\n        )\n        parser.add_argument(\n            \"-fp\",\n            \"--formatsPath\",\n            default=ValueFormatter.formatsPath,\n            help=\"path to yaml file to configure formats to use for query result documentation\",\n        )\n        parser.add_argument(\n            \"-en\",\n            \"--endpointName\",\n            default=\"wikidata\",\n            help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames()}\",\n        )\n        parser.add_argument(\"--method\", help=\"method to be used for SPARQL queries\")\n        parser.add_argument(\"-f\", \"--format\", type=Format, choices=list(Format))\n        parser.add_argument(\n            \"-li\",\n            \"--list\",\n            action=\"store_true\",\n            help=\"show the list of available queries\",\n        )\n        parser.add_argument(\n            \"--limit\", type=int, default=None, help=\"set limit parameter of query\"\n        )\n        parser.add_argument(\n            \"--params\",\n            action=StoreDictKeyPair,\n            help=\"query parameters as Key-value pairs in the format key1=value1,key2=value2\",\n        )\n        parser.add_argument(\n            \"-le\",\n            \"--listEndpoints\",\n            action=\"store_true\",\n            help=\"show the list of available endpoints\",\n        )\n        parser.add_argument(\n            \"-m\", \"--mimeType\", help=\"MIME-type to use for the raw query\"\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--prefixes\",\n            action=\"store_true\",\n            help=\"add predefined prefixes for endpoint\",\n        )\n        parser.add_argument(\n            \"-sq\", \"--showQuery\", action=\"store_true\", help=\"show the query\"\n        )\n        parser.add_argument(\n            \"-qp\", \"--queriesPath\", help=\"path to YAML file with query definitions\"\n        )\n        parser.add_argument(\"-q\", \"--query\", help=\"the query to run\")\n        parser.add_argument(\"-qf\", \"--queryFile\", help=\"the query file to run\")\n        parser.add_argument(\"-qn\", \"--queryName\", help=\"run a named query\")\n        parser.add_argument(\n            \"-raw\",\n            action=\"store_true\",\n            help=\"return the raw query result from the endpoint. (MIME type defined over -f or -m)\",\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=program_version_message\n        )\n        if lang is None:\n            parser.add_argument(\n                \"-l\", \"--language\", help=\"the query language to use\", required=True\n            )\n        args = parser.parse_args(argv)\n        if lang is not None:\n            args.language = lang\n        QueryMain.main(args)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#lodstorage.querymain.mainSPARQL","title":"<code>mainSPARQL(argv=None)</code>","text":"<p>commandline for SPARQL queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def mainSPARQL(argv=None):\n    \"\"\"\n    commandline for SPARQL queries\n    \"\"\"\n    main(argv, lang=\"sparql\")\n</code></pre>"},{"location":"#lodstorage.querymain.mainSQL","title":"<code>mainSQL(argv=None)</code>","text":"<p>commandline for SQL queries</p> Source code in <code>lodstorage/querymain.py</code> <pre><code>def mainSQL(argv=None):\n    \"\"\"\n    commandline for SQL queries\n    \"\"\"\n    main(argv, lang=\"sql\")\n</code></pre>"},{"location":"#lodstorage.rdf","title":"<code>rdf</code>","text":"<p>Created on 2024-01-27</p> <p>@author: wf, using ChatGPT-4 prompting</p>"},{"location":"#lodstorage.rdf.RDFDumper","title":"<code>RDFDumper</code>","text":"<p>A class to convert instances of data models (based on a LinkML schema) into an RDF graph.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>class RDFDumper:\n    \"\"\"\n    A class to convert instances of data models (based on a LinkML schema) into an RDF graph.\n    \"\"\"\n\n    def __init__(self, schema: Schema, instance: object):\n        \"\"\"\n        Initialize the RDFDumper.\n\n        Args:\n            schema (Schema): The LinkML schema defining the structure of the data models.\n            instance (object): The instance of the data model to be converted into RDF.\n        \"\"\"\n        self.schema = schema\n        self.instance = instance\n        self.graph = Graph()\n        self.namespaces = {\n            prefix: Namespace(uri) for prefix, uri in schema.prefixes.items()\n        }\n\n    def convert_to_rdf(self):\n        \"\"\"\n        Converts the provided instance into RDF triples based on the LinkML schema.\n        \"\"\"\n        # Process the instance data according to its class in the schema\n        instance_class = self.instance.__class__.__name__\n        if instance_class in self.schema.classes:\n            self.process_class(instance_class, self.instance)\n\n    def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n        \"\"\"\n        Serializes the RDF graph into a string representation in the specified format.\n\n        Args:\n            format (str): The serialization format (e.g., 'turtle', 'xml', 'json-ld').\n\n        Returns:\n            str: The serialized RDF graph.\n        \"\"\"\n        return self.graph.serialize(format=rdf_format)\n\n    def value_iterator(self, value: Any):\n        \"\"\"\n        Iterates over values in a mapping or iterable.\n\n        Args:\n            value: The value to iterate over. It can be a mapping, iterable, or a single value.\n\n        Yields:\n            Tuples of (key, value) from the input value. For single values, key is None.\n        \"\"\"\n        if isinstance(value, Mapping):\n            yield from value.items()\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            yield from ((None, v) for v in value)\n        else:\n            yield (None, value)\n\n    def process_class(self, class_name: str, instance_data: object):\n        # Get the base namespace URI\n        self.base_uri = self.namespaces[self.schema.default_prefix]\n        # get the class object\n        # class_obj = self.schema.classes[class_name]\n        # Construct class_uri using the namespace and class_name with a separator\n        class_uri = URIRef(f\"{self.base_uri}:{class_name}\")\n\n        # Create a unique URI or a Blank Node for the instance\n        instance_uri = self.get_instance_uri(instance_data)\n\n        # Type the instance with its class\n        self.graph.add((instance_uri, RDF.type, class_uri))\n\n        # loop over all fieds of the instance data\n        for field_info in fields(instance_data):\n            slot_name = field_info.name\n            # assure we only work on fields defined\n            # in our schema\n            slot_obj = self.schema.slots.get(slot_name)\n            if not slot_obj:\n                continue\n\n            # Combine the namespace with the slot name to form the field URI\n            field_uri = URIRef(f\"{self.base_uri}:{slot_name}\")\n            field_value = getattr(instance_data, slot_name, None)\n\n            # Use value_iterator to handle different types of values\n            for key, item in self.value_iterator(field_value):\n                if key is not None:\n                    # Handle as a mapping\n                    key_uri = URIRef(self.namespaces[self.schema.default_prefix][key])\n                    self.graph.add((instance_uri, field_uri, key_uri))\n                    self.graph.add(\n                        (key_uri, RDF.value, self.convert_to_literal(item, slot_obj))\n                    )\n                else:\n                    # Handle as a single value or an item from an iterable\n                    # Check if item has an 'identifier' property\n                    if hasattr(item, \"identifier\") and getattr(item, \"identifier\"):\n                        item_uri = self.get_instance_uri(item)\n                        self.graph.add((instance_uri, field_uri, item_uri))\n                        self.process_class(item.__class__.__name__, item)\n                    else:\n                        self.graph.add(\n                            (\n                                instance_uri,\n                                field_uri,\n                                self.convert_to_literal(item, slot_obj),\n                            )\n                        )\n\n    def get_instance_uri(self, instance_data):\n        \"\"\"\n        Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI.\n        Otherwise, it generates or retrieves a unique URI.\n        \"\"\"\n        if hasattr(instance_data, \"identifier\") and getattr(\n            instance_data, \"identifier\"\n        ):\n            identifier = getattr(instance_data, \"identifier\")\n            return URIRef(f\"{self.base_uri}:{identifier}\")\n        else:\n            # Fallback to a blank node if no identifier is found\n            return BNode()\n\n    def convert_to_literal(self, value, slot_obj):\n        \"\"\"\n        Converts a value to an RDFLib Literal with appropriate datatype.\n\n        Args:\n            value: The value to be converted.\n            slot_obj: The slot object containing information about the field.\n\n        Returns:\n            An RDFLib Literal with the value and appropriate datatype.\n        \"\"\"\n        # Determine the datatype based on the Python type of the value\n        datatype = PythonTypes.get_rdf_datatype(type(value))\n\n        # Create and return the literal\n        return Literal(value, datatype=datatype)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.__init__","title":"<code>__init__(schema, instance)</code>","text":"<p>Initialize the RDFDumper.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The LinkML schema defining the structure of the data models.</p> required <code>instance</code> <code>object</code> <p>The instance of the data model to be converted into RDF.</p> required Source code in <code>lodstorage/rdf.py</code> <pre><code>def __init__(self, schema: Schema, instance: object):\n    \"\"\"\n    Initialize the RDFDumper.\n\n    Args:\n        schema (Schema): The LinkML schema defining the structure of the data models.\n        instance (object): The instance of the data model to be converted into RDF.\n    \"\"\"\n    self.schema = schema\n    self.instance = instance\n    self.graph = Graph()\n    self.namespaces = {\n        prefix: Namespace(uri) for prefix, uri in schema.prefixes.items()\n    }\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.convert_to_literal","title":"<code>convert_to_literal(value, slot_obj)</code>","text":"<p>Converts a value to an RDFLib Literal with appropriate datatype.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The value to be converted.</p> required <code>slot_obj</code> <p>The slot object containing information about the field.</p> required <p>Returns:</p> Type Description <p>An RDFLib Literal with the value and appropriate datatype.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def convert_to_literal(self, value, slot_obj):\n    \"\"\"\n    Converts a value to an RDFLib Literal with appropriate datatype.\n\n    Args:\n        value: The value to be converted.\n        slot_obj: The slot object containing information about the field.\n\n    Returns:\n        An RDFLib Literal with the value and appropriate datatype.\n    \"\"\"\n    # Determine the datatype based on the Python type of the value\n    datatype = PythonTypes.get_rdf_datatype(type(value))\n\n    # Create and return the literal\n    return Literal(value, datatype=datatype)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.convert_to_rdf","title":"<code>convert_to_rdf()</code>","text":"<p>Converts the provided instance into RDF triples based on the LinkML schema.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def convert_to_rdf(self):\n    \"\"\"\n    Converts the provided instance into RDF triples based on the LinkML schema.\n    \"\"\"\n    # Process the instance data according to its class in the schema\n    instance_class = self.instance.__class__.__name__\n    if instance_class in self.schema.classes:\n        self.process_class(instance_class, self.instance)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.get_instance_uri","title":"<code>get_instance_uri(instance_data)</code>","text":"<p>Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI. Otherwise, it generates or retrieves a unique URI.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def get_instance_uri(self, instance_data):\n    \"\"\"\n    Generates a URI for an instance. If the instance has an 'identifier' property, it uses that as part of the URI.\n    Otherwise, it generates or retrieves a unique URI.\n    \"\"\"\n    if hasattr(instance_data, \"identifier\") and getattr(\n        instance_data, \"identifier\"\n    ):\n        identifier = getattr(instance_data, \"identifier\")\n        return URIRef(f\"{self.base_uri}:{identifier}\")\n    else:\n        # Fallback to a blank node if no identifier is found\n        return BNode()\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.serialize","title":"<code>serialize(rdf_format='turtle')</code>","text":"<p>Serializes the RDF graph into a string representation in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>The serialization format (e.g., 'turtle', 'xml', 'json-ld').</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serialized RDF graph.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def serialize(self, rdf_format: str = \"turtle\") -&gt; str:\n    \"\"\"\n    Serializes the RDF graph into a string representation in the specified format.\n\n    Args:\n        format (str): The serialization format (e.g., 'turtle', 'xml', 'json-ld').\n\n    Returns:\n        str: The serialized RDF graph.\n    \"\"\"\n    return self.graph.serialize(format=rdf_format)\n</code></pre>"},{"location":"#lodstorage.rdf.RDFDumper.value_iterator","title":"<code>value_iterator(value)</code>","text":"<p>Iterates over values in a mapping or iterable.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to iterate over. It can be a mapping, iterable, or a single value.</p> required <p>Yields:</p> Type Description <p>Tuples of (key, value) from the input value. For single values, key is None.</p> Source code in <code>lodstorage/rdf.py</code> <pre><code>def value_iterator(self, value: Any):\n    \"\"\"\n    Iterates over values in a mapping or iterable.\n\n    Args:\n        value: The value to iterate over. It can be a mapping, iterable, or a single value.\n\n    Yields:\n        Tuples of (key, value) from the input value. For single values, key is None.\n    \"\"\"\n    if isinstance(value, Mapping):\n        yield from value.items()\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        yield from ((None, v) for v in value)\n    else:\n        yield (None, value)\n</code></pre>"},{"location":"#lodstorage.sample","title":"<code>sample</code>","text":"<p>Created on 2020-08-24</p> <p>@author: wf</p>"},{"location":"#lodstorage.sample.Royal","title":"<code>Royal</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>i am a single Royal</p> Source code in <code>lodstorage/sample.py</code> <pre><code>class Royal(JSONAble):\n    \"\"\"\n    i am a single Royal\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        listOfDicts = [\n            {\n                \"name\": \"Elizabeth Alexandra Mary Windsor\",\n                \"born\": Sample.dob(\"1926-04-21\"),\n                \"numberInLine\": 0,\n                \"wikidataurl\": \"https://www.wikidata.org/wiki/Q9682\",\n            },\n            {\n                \"name\": \"Charles, Prince of Wales\",\n                \"born\": Sample.dob(\"1948-11-14\"),\n                \"numberInLine\": 1,\n                \"wikidataurl\": \"https://www.wikidata.org/wiki/Q43274\",\n            },\n            {\n                \"name\": \"George of Cambridge\",\n                \"born\": Sample.dob(\"2013-07-22\"),\n                \"numberInLine\": 3,\n                \"wikidataurl\": \"https://www.wikidata.org/wiki/Q1359041\",\n            },\n            {\n                \"name\": \"Harry Duke of Sussex\",\n                \"born\": Sample.dob(\"1984-09-15\"),\n                \"numberInLine\": 6,\n                \"wikidataurl\": \"https://www.wikidata.org/wiki/Q152316\",\n            },\n        ]\n        today = date.today()\n        for person in listOfDicts:\n            born = person[\"born\"]\n            age = (today - born).days / 365.2425\n            person[\"age\"] = age\n            person[\"ofAge\"] = age &gt;= 18\n            person[\"lastmodified\"] = datetime.now()\n        return listOfDicts\n\n    def __repr__(self):\n        text = self.__class__.__name__\n        attrs = [\"name\", \"born\"]\n        delim = \":\"\n        for attr in attrs:\n            if hasattr(self, attr):\n                value = getattr(self, attr)\n                text += f\"{delim}{value}\"\n                delim = \":\"\n        return text\n</code></pre>"},{"location":"#lodstorage.sample.Royals","title":"<code>Royals</code>","text":"<p>               Bases: <code>JSONAbleList</code></p> <p>a non ORM Royals list</p> Source code in <code>lodstorage/sample.py</code> <pre><code>class Royals(JSONAbleList):\n    \"\"\"\n    a non ORM Royals list\n    \"\"\"\n\n    def __init__(self, load=False):\n        super(Royals, self).__init__(\"royals\", clazz=None)\n        if load:\n            self.royals = Royal.getSamples()\n        else:\n            self.royals = None\n</code></pre>"},{"location":"#lodstorage.sample.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>object</code></p> <p>Sample dataset generator</p> Source code in <code>lodstorage/sample.py</code> <pre><code>class Sample(object):\n    \"\"\"\n    Sample dataset generator\n    \"\"\"\n\n    cityList = None\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n\n    @staticmethod\n    def getSample(size):\n        listOfDicts = []\n        for index in range(size):\n            listOfDicts.append({\"pkey\": \"index%d\" % index, \"cindex\": index})\n        return listOfDicts\n\n    @staticmethod\n    def getCountries():\n        countryJsonUrl = \"https://gist.githubusercontent.com/erdem/8c7d26765831d0f9a8c62f02782ae00d/raw/248037cd701af0a4957cce340dabb0fd04e38f4c/countries.json\"\n        with urllib.request.urlopen(countryJsonUrl) as url:\n            countryList = json.loads(url.read().decode())\n        return countryList\n\n    @staticmethod\n    def getCities():\n        \"\"\"\n        get a list of cities\n        \"\"\"\n        if Sample.cityList is None:\n            cityJsonUrl = \"https://raw.githubusercontent.com/lutangar/cities.json/master/cities.json\"\n            with urllib.request.urlopen(cityJsonUrl) as url:\n                Sample.cityList = json.loads(url.read().decode())\n            for city in Sample.cityList:\n                city[\"cityId\"] = \"%s-%s\" % (city[\"country\"], city[\"name\"])\n        return Sample.cityList\n\n    @staticmethod\n    def dob(isoDateString):\n        \"\"\"get the date of birth from the given iso date state\"\"\"\n        # if sys.version_info &gt;= (3, 7):\n        #    dt=datetime.fromisoformat(isoDateString)\n        # else:\n        dt = datetime.strptime(isoDateString, \"%Y-%m-%d\")\n        return dt.date()\n\n    @staticmethod\n    def getRoyals():\n        return Royal.getSamples()\n\n    @staticmethod\n    def getRoyalsInstances():\n        lod = Royal.getSamples()\n        royals = []\n        for record in lod:\n            royal = Royal()\n            royal.fromDict(record)\n            royals.append(royal)\n        return royals\n</code></pre>"},{"location":"#lodstorage.sample.Sample.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/sample.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n</code></pre>"},{"location":"#lodstorage.sample.Sample.dob","title":"<code>dob(isoDateString)</code>  <code>staticmethod</code>","text":"<p>get the date of birth from the given iso date state</p> Source code in <code>lodstorage/sample.py</code> <pre><code>@staticmethod\ndef dob(isoDateString):\n    \"\"\"get the date of birth from the given iso date state\"\"\"\n    # if sys.version_info &gt;= (3, 7):\n    #    dt=datetime.fromisoformat(isoDateString)\n    # else:\n    dt = datetime.strptime(isoDateString, \"%Y-%m-%d\")\n    return dt.date()\n</code></pre>"},{"location":"#lodstorage.sample.Sample.getCities","title":"<code>getCities()</code>  <code>staticmethod</code>","text":"<p>get a list of cities</p> Source code in <code>lodstorage/sample.py</code> <pre><code>@staticmethod\ndef getCities():\n    \"\"\"\n    get a list of cities\n    \"\"\"\n    if Sample.cityList is None:\n        cityJsonUrl = \"https://raw.githubusercontent.com/lutangar/cities.json/master/cities.json\"\n        with urllib.request.urlopen(cityJsonUrl) as url:\n            Sample.cityList = json.loads(url.read().decode())\n        for city in Sample.cityList:\n            city[\"cityId\"] = \"%s-%s\" % (city[\"country\"], city[\"name\"])\n    return Sample.cityList\n</code></pre>"},{"location":"#lodstorage.sample2","title":"<code>sample2</code>","text":"<p>Created on 2024-01-21</p> <p>@author: wf</p>"},{"location":"#lodstorage.sample2.Countries","title":"<code>Countries</code>","text":"<p>Represents a collection of country instances.</p> <p>Attributes:</p> Name Type Description <code>countries</code> <code>List[Country]</code> <p>A list of Country instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Countries:\n    \"\"\"\n    Represents a collection of country instances.\n\n    Attributes:\n        countries (List[Country]): A list of Country instances.\n    \"\"\"\n\n    countries: List[Country]\n\n    @classmethod\n    def get_countries_erdem(cls) -&gt; \"Countries\":\n        \"\"\"\n        get Erdem Ozkol's country list\n        \"\"\"\n        countries_json_url = \"https://gist.githubusercontent.com/erdem/8c7d26765831d0f9a8c62f02782ae00d/raw/248037cd701af0a4957cce340dabb0fd04e38f4c/countries.json\"\n        json_str = cls.read_from_url(countries_json_url)\n        countries_list = json.loads(json_str)\n        countries_dict = {\"countries\": countries_list}\n        instance = cls.from_dict(countries_dict)\n        return instance\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"Countries\"]:\n        \"\"\"\n        Returns a dictionary of named samples\n        for 'specification by example' style\n        requirements management.\n\n        Returns:\n            dict: A dictionary with keys as sample names\n            and values as `Countries` instances.\n        \"\"\"\n        samples = {\"country list provided by Erdem Ozkol\": cls.get_countries_erdem()}\n        return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Countries.get_countries_erdem","title":"<code>get_countries_erdem()</code>  <code>classmethod</code>","text":"<p>get Erdem Ozkol's country list</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_countries_erdem(cls) -&gt; \"Countries\":\n    \"\"\"\n    get Erdem Ozkol's country list\n    \"\"\"\n    countries_json_url = \"https://gist.githubusercontent.com/erdem/8c7d26765831d0f9a8c62f02782ae00d/raw/248037cd701af0a4957cce340dabb0fd04e38f4c/countries.json\"\n    json_str = cls.read_from_url(countries_json_url)\n    countries_list = json.loads(json_str)\n    countries_dict = {\"countries\": countries_list}\n    instance = cls.from_dict(countries_dict)\n    return instance\n</code></pre>"},{"location":"#lodstorage.sample2.Countries.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>Returns a dictionary of named samples for 'specification by example' style requirements management.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Countries]</code> <p>A dictionary with keys as sample names</p> <code>dict[str, Countries]</code> <p>and values as <code>Countries</code> instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"Countries\"]:\n    \"\"\"\n    Returns a dictionary of named samples\n    for 'specification by example' style\n    requirements management.\n\n    Returns:\n        dict: A dictionary with keys as sample names\n        and values as `Countries` instances.\n    \"\"\"\n    samples = {\"country list provided by Erdem Ozkol\": cls.get_countries_erdem()}\n    return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Country","title":"<code>Country</code>","text":"<p>Represents a country with its details.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the country.</p> <code>country_code</code> <code>str</code> <p>The country code.</p> <code>capital</code> <code>Optional[str]</code> <p>The capital city of the country.</p> <code>timezones</code> <code>List[str]</code> <p>List of timezones in the country.</p> <code>latlng</code> <code>List[float]</code> <p>Latitude and longitude of the country.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Country:\n    \"\"\"\n    Represents a country with its details.\n\n    Attributes:\n        name (str): The name of the country.\n        country_code (str): The country code.\n        capital (Optional[str]): The capital city of the country.\n        timezones (List[str]): List of timezones in the country.\n        latlng (List[float]): Latitude and longitude of the country.\n    \"\"\"\n\n    name: str\n    country_code: str\n    capital: Optional[str] = None\n    timezones: List[str] = field(default_factory=list)\n    latlng: List[float] = field(default_factory=list)\n</code></pre>"},{"location":"#lodstorage.sample2.Royal","title":"<code>Royal</code>","text":"<p>Represents a member of the royal family, with various personal details.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The full name of the royal member.</p> <code>wikidata_id</code> <code>str</code> <p>The Wikidata identifier associated with the royal member.</p> <code>number_in_line</code> <code>Optional[int]</code> <p>The number in line to succession, if applicable.</p> <code>born_iso_date</code> <code>Optional[str]</code> <p>The ISO date of birth.</p> <code>died_iso_date</code> <code>Optional[str]</code> <p>The ISO date of death, if deceased.</p> <code>last_modified_iso</code> <code>str</code> <p>ISO timestamp of the last modification.</p> <code>age</code> <code>Optional[int]</code> <p>The age of the royal member.</p> <code>of_age</code> <code>Optional[bool]</code> <p>Indicates whether the member is of legal age.</p> <code>wikidata_url</code> <code>Optional[str]</code> <p>URL to the Wikidata page of the member.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Royal:\n    \"\"\"\n    Represents a member of the royal family, with various personal details.\n\n    Attributes:\n        name (str): The full name of the royal member.\n        wikidata_id (str): The Wikidata identifier associated with the royal member.\n        number_in_line (Optional[int]): The number in line to succession, if applicable.\n        born_iso_date (Optional[str]): The ISO date of birth.\n        died_iso_date (Optional[str]): The ISO date of death, if deceased.\n        last_modified_iso (str): ISO timestamp of the last modification.\n        age (Optional[int]): The age of the royal member.\n        of_age (Optional[bool]): Indicates whether the member is of legal age.\n        wikidata_url (Optional[str]): URL to the Wikidata page of the member.\n    \"\"\"\n\n    name: str\n    wikidata_id: str\n    number_in_line: Optional[int] = None\n    born_iso_date: Optional[str] = None\n    died_iso_date: Optional[str] = None\n    last_modified_iso: str = field(init=False)\n    age: Optional[int] = field(init=None)\n    of_age: Optional[bool] = field(init=None)\n    wikidata_url: Optional[str] = field(init=None)\n\n    def __post_init__(self):\n        \"\"\"\n        init calculated fields\n        \"\"\"\n        self.lastmodified = datetime.utcnow()\n        self.last_modified_iso = self.lastmodified.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        end_date = self.died if self.died else date.today()\n        self.age = int((end_date - self.born).days / 365.2425)\n        self.of_age = self.age &gt;= 18\n        if self.wikidata_id:\n            self.wikidata_url = f\"https://www.wikidata.org/wiki/{self.wikidata_id}\"\n\n    @property\n    def identifier(self) -&gt; str:\n        \"\"\"\n        Generates a unique identifier for the Royal instance.\n        The identifier is a combination of a slugified name and the Wikidata ID (if available).\n        \"\"\"\n        slugified_name = slugify(self.name, lowercase=False, regex_pattern=r\"[^\\w\\-]\")\n        if self.wikidata_id:\n            return f\"{slugified_name}-{self.wikidata_id}\"\n        return slugified_name\n\n    @property\n    def born(self) -&gt; date:\n        \"\"\"Return the date of birth from the ISO date string.\"\"\"\n        born_date = DateConvert.iso_date_to_datetime(self.born_iso_date)\n        return born_date\n\n    @property\n    def died(self) -&gt; Optional[date]:\n        \"\"\"Return the date of death from the ISO date string, if available.\"\"\"\n        died_date = DateConvert.iso_date_to_datetime(self.died_iso_date)\n        return died_date\n</code></pre>"},{"location":"#lodstorage.sample2.Royal.born","title":"<code>born: date</code>  <code>property</code>","text":"<p>Return the date of birth from the ISO date string.</p>"},{"location":"#lodstorage.sample2.Royal.died","title":"<code>died: Optional[date]</code>  <code>property</code>","text":"<p>Return the date of death from the ISO date string, if available.</p>"},{"location":"#lodstorage.sample2.Royal.identifier","title":"<code>identifier: str</code>  <code>property</code>","text":"<p>Generates a unique identifier for the Royal instance. The identifier is a combination of a slugified name and the Wikidata ID (if available).</p>"},{"location":"#lodstorage.sample2.Royal.__post_init__","title":"<code>__post_init__()</code>","text":"<p>init calculated fields</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    init calculated fields\n    \"\"\"\n    self.lastmodified = datetime.utcnow()\n    self.last_modified_iso = self.lastmodified.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    end_date = self.died if self.died else date.today()\n    self.age = int((end_date - self.born).days / 365.2425)\n    self.of_age = self.age &gt;= 18\n    if self.wikidata_id:\n        self.wikidata_url = f\"https://www.wikidata.org/wiki/{self.wikidata_id}\"\n</code></pre>"},{"location":"#lodstorage.sample2.Royals","title":"<code>Royals</code>","text":"<p>Represents a collection of Royal family members.</p> <p>Attributes:</p> Name Type Description <code>members</code> <code>List[Royal]</code> <p>A list of Royal family members.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@lod_storable\nclass Royals:\n    \"\"\"\n    Represents a collection of Royal family members.\n\n    Attributes:\n        members (List[Royal]): A list of Royal family members.\n    \"\"\"\n\n    members: List[Royal] = field(default_factory=list)\n\n    @classmethod\n    def get_samples(cls) -&gt; dict[str, \"Royals\"]:\n        \"\"\"\n        Returns a dictionary of named samples\n        for 'specification by example' style\n        requirements management.\n\n        Returns:\n            dict: A dictionary with keys as sample names and values as `Royals` instances.\n        \"\"\"\n        samples = {\n            \"QE2 heirs up to number in line 5\": Royals(\n                members=[\n                    Royal(\n                        name=\"Elizabeth Alexandra Mary Windsor\",\n                        born_iso_date=\"1926-04-21\",\n                        died_iso_date=\"2022-09-08\",\n                        wikidata_id=\"Q9682\",\n                    ),\n                    Royal(\n                        name=\"Charles III of the United Kingdom\",\n                        born_iso_date=\"1948-11-14\",\n                        number_in_line=0,\n                        wikidata_id=\"Q43274\",\n                    ),\n                    Royal(\n                        name=\"William, Duke of Cambridge\",\n                        born_iso_date=\"1982-06-21\",\n                        number_in_line=1,\n                        wikidata_id=\"Q36812\",\n                    ),\n                    Royal(\n                        name=\"Prince George of Wales\",\n                        born_iso_date=\"2013-07-22\",\n                        number_in_line=2,\n                        wikidata_id=\"Q13590412\",\n                    ),\n                    Royal(\n                        name=\"Princess Charlotte of Wales\",\n                        born_iso_date=\"2015-05-02\",\n                        number_in_line=3,\n                        wikidata_id=\"Q18002970\",\n                    ),\n                    Royal(\n                        name=\"Prince Louis of Wales\",\n                        born_iso_date=\"2018-04-23\",\n                        number_in_line=4,\n                        wikidata_id=\"Q38668629\",\n                    ),\n                    Royal(\n                        name=\"Harry Duke of Sussex\",\n                        born_iso_date=\"1984-09-15\",\n                        number_in_line=5,\n                        wikidata_id=\"Q152316\",\n                    ),\n                ]\n            )\n        }\n        return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Royals.get_samples","title":"<code>get_samples()</code>  <code>classmethod</code>","text":"<p>Returns a dictionary of named samples for 'specification by example' style requirements management.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Royals]</code> <p>A dictionary with keys as sample names and values as <code>Royals</code> instances.</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@classmethod\ndef get_samples(cls) -&gt; dict[str, \"Royals\"]:\n    \"\"\"\n    Returns a dictionary of named samples\n    for 'specification by example' style\n    requirements management.\n\n    Returns:\n        dict: A dictionary with keys as sample names and values as `Royals` instances.\n    \"\"\"\n    samples = {\n        \"QE2 heirs up to number in line 5\": Royals(\n            members=[\n                Royal(\n                    name=\"Elizabeth Alexandra Mary Windsor\",\n                    born_iso_date=\"1926-04-21\",\n                    died_iso_date=\"2022-09-08\",\n                    wikidata_id=\"Q9682\",\n                ),\n                Royal(\n                    name=\"Charles III of the United Kingdom\",\n                    born_iso_date=\"1948-11-14\",\n                    number_in_line=0,\n                    wikidata_id=\"Q43274\",\n                ),\n                Royal(\n                    name=\"William, Duke of Cambridge\",\n                    born_iso_date=\"1982-06-21\",\n                    number_in_line=1,\n                    wikidata_id=\"Q36812\",\n                ),\n                Royal(\n                    name=\"Prince George of Wales\",\n                    born_iso_date=\"2013-07-22\",\n                    number_in_line=2,\n                    wikidata_id=\"Q13590412\",\n                ),\n                Royal(\n                    name=\"Princess Charlotte of Wales\",\n                    born_iso_date=\"2015-05-02\",\n                    number_in_line=3,\n                    wikidata_id=\"Q18002970\",\n                ),\n                Royal(\n                    name=\"Prince Louis of Wales\",\n                    born_iso_date=\"2018-04-23\",\n                    number_in_line=4,\n                    wikidata_id=\"Q38668629\",\n                ),\n                Royal(\n                    name=\"Harry Duke of Sussex\",\n                    born_iso_date=\"1984-09-15\",\n                    number_in_line=5,\n                    wikidata_id=\"Q152316\",\n                ),\n            ]\n        )\n    }\n    return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Sample","title":"<code>Sample</code>","text":"<p>Sample dataset provider</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>class Sample:\n    \"\"\"\n    Sample dataset provider\n    \"\"\"\n\n    @staticmethod\n    def get(dataset_name: str):\n        \"\"\"\n        Get the given sample dataset name\n        \"\"\"\n        samples = None\n        if dataset_name == \"royals\":\n            samples = Royals.get_samples()\n        elif dataset_name == \"countries\":\n            samples = Countries.get_samples()\n        else:\n            raise ValueError(\"Unknown dataset name\")\n        return samples\n</code></pre>"},{"location":"#lodstorage.sample2.Sample.get","title":"<code>get(dataset_name)</code>  <code>staticmethod</code>","text":"<p>Get the given sample dataset name</p> Source code in <code>lodstorage/sample2.py</code> <pre><code>@staticmethod\ndef get(dataset_name: str):\n    \"\"\"\n    Get the given sample dataset name\n    \"\"\"\n    samples = None\n    if dataset_name == \"royals\":\n        samples = Royals.get_samples()\n    elif dataset_name == \"countries\":\n        samples = Countries.get_samples()\n    else:\n        raise ValueError(\"Unknown dataset name\")\n    return samples\n</code></pre>"},{"location":"#lodstorage.schema","title":"<code>schema</code>","text":"<p>Created on 2021-01-26</p> <p>@author: wf</p>"},{"location":"#lodstorage.schema.Schema","title":"<code>Schema</code>","text":"<p>               Bases: <code>object</code></p> <p>a relational Schema</p> Source code in <code>lodstorage/schema.py</code> <pre><code>class Schema(object):\n    \"\"\"\n    a relational Schema\n    \"\"\"\n\n    def __init__(self, name: str, title: str):\n        \"\"\"\n        Constructor\n\n        Args:\n            name(str): the name of the schema\n            title(str): the title of the schema\n        \"\"\"\n        self.name = name\n        self.title = title\n        self.propsByName = {}\n\n    @staticmethod\n    def generalizeColumn(tableList, colName: str):\n        \"\"\"\n        remove the column with the given name from all tables in the tablelist and\n        return it\n\n        Args:\n            tableList(list): a list of Tables\n            colName(string): the name of the column to generalize\n\n        Returns:\n            string: the column having been generalized and removed\n        \"\"\"\n        gCol = None\n        for table in tableList:\n            for col in table[\"columns\"]:\n                if col[\"name\"] == colName:\n                    gCol = col.copy()\n                    # no linking yet @FIXME - will need this later\n                    if \"link\" in gCol:\n                        gCol.pop(\"link\")\n                    # is generalization protected for this column?\n                    if not \"special\" in col or not col[\"special\"]:\n                        table[\"columns\"].remove(col)\n        return gCol\n\n    @staticmethod\n    def getGeneral(tableList, name: str, debug: bool = False):\n        \"\"\"\n        derive a general table from the given table list\n        Args:\n            tableList(list): a list of tables\n            name(str): name of the general table\n            debug(bool): True if column names should be shown\n\n        Returns:\n            at table dict for the generalized table\n        \"\"\"\n        general = {\"name\": name, \"columns\": []}\n        colCount = Counter()\n        for table in tableList:\n            for col in table[\"columns\"]:\n                columnId = \"%s.%s\" % (col[\"name\"], col[\"type\"])\n                if debug:\n                    print(columnId)\n                colCount[columnId] += 1\n        for columnId, count in colCount.items():\n            if count == len(tableList):\n                colName = columnId.split(\".\")[0]\n                generalCol = Schema.generalizeColumn(tableList, colName)\n                general[\"columns\"].append(generalCol)\n        return general\n\n    @staticmethod\n    def getGeneralViewDDL(tableList, name: str, debug=False) -&gt; str:\n        \"\"\"\n        get the DDL statement to create a general view\n\n        Args:\n            tableList: the list of tables\n            name(str): the name of the view\n            debug(bool): True if debug should be set\n        \"\"\"\n        general = Schema.getGeneral(tableList, name, debug)\n        cols = \"\"\n        delim = \"\"\n        for col in general[\"columns\"]:\n            cols += \"%s%s\" % (delim, col[\"name\"])\n            delim = \",\"\n        ddl = \"CREATE VIEW %s AS \\n\" % name\n        delim = \"\"\n        for table in tableList:\n            ddl += \"%s  SELECT %s FROM %s\" % (delim, cols, table[\"name\"])\n            delim = \"\\nUNION\\n\"\n        return ddl\n</code></pre>"},{"location":"#lodstorage.schema.Schema.__init__","title":"<code>__init__(name, title)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the schema</p> required <code>title(str)</code> <p>the title of the schema</p> required Source code in <code>lodstorage/schema.py</code> <pre><code>def __init__(self, name: str, title: str):\n    \"\"\"\n    Constructor\n\n    Args:\n        name(str): the name of the schema\n        title(str): the title of the schema\n    \"\"\"\n    self.name = name\n    self.title = title\n    self.propsByName = {}\n</code></pre>"},{"location":"#lodstorage.schema.Schema.generalizeColumn","title":"<code>generalizeColumn(tableList, colName)</code>  <code>staticmethod</code>","text":"<p>remove the column with the given name from all tables in the tablelist and return it</p> <p>Parameters:</p> Name Type Description Default <code>tableList(list)</code> <p>a list of Tables</p> required <code>colName(string)</code> <p>the name of the column to generalize</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the column having been generalized and removed</p> Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef generalizeColumn(tableList, colName: str):\n    \"\"\"\n    remove the column with the given name from all tables in the tablelist and\n    return it\n\n    Args:\n        tableList(list): a list of Tables\n        colName(string): the name of the column to generalize\n\n    Returns:\n        string: the column having been generalized and removed\n    \"\"\"\n    gCol = None\n    for table in tableList:\n        for col in table[\"columns\"]:\n            if col[\"name\"] == colName:\n                gCol = col.copy()\n                # no linking yet @FIXME - will need this later\n                if \"link\" in gCol:\n                    gCol.pop(\"link\")\n                # is generalization protected for this column?\n                if not \"special\" in col or not col[\"special\"]:\n                    table[\"columns\"].remove(col)\n    return gCol\n</code></pre>"},{"location":"#lodstorage.schema.Schema.getGeneral","title":"<code>getGeneral(tableList, name, debug=False)</code>  <code>staticmethod</code>","text":"<p>derive a general table from the given table list Args:     tableList(list): a list of tables     name(str): name of the general table     debug(bool): True if column names should be shown</p> <p>Returns:</p> Type Description <p>at table dict for the generalized table</p> Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef getGeneral(tableList, name: str, debug: bool = False):\n    \"\"\"\n    derive a general table from the given table list\n    Args:\n        tableList(list): a list of tables\n        name(str): name of the general table\n        debug(bool): True if column names should be shown\n\n    Returns:\n        at table dict for the generalized table\n    \"\"\"\n    general = {\"name\": name, \"columns\": []}\n    colCount = Counter()\n    for table in tableList:\n        for col in table[\"columns\"]:\n            columnId = \"%s.%s\" % (col[\"name\"], col[\"type\"])\n            if debug:\n                print(columnId)\n            colCount[columnId] += 1\n    for columnId, count in colCount.items():\n        if count == len(tableList):\n            colName = columnId.split(\".\")[0]\n            generalCol = Schema.generalizeColumn(tableList, colName)\n            general[\"columns\"].append(generalCol)\n    return general\n</code></pre>"},{"location":"#lodstorage.schema.Schema.getGeneralViewDDL","title":"<code>getGeneralViewDDL(tableList, name, debug=False)</code>  <code>staticmethod</code>","text":"<p>get the DDL statement to create a general view</p> <p>Parameters:</p> Name Type Description Default <code>tableList</code> <p>the list of tables</p> required <code>name(str)</code> <p>the name of the view</p> required <code>debug(bool)</code> <p>True if debug should be set</p> required Source code in <code>lodstorage/schema.py</code> <pre><code>@staticmethod\ndef getGeneralViewDDL(tableList, name: str, debug=False) -&gt; str:\n    \"\"\"\n    get the DDL statement to create a general view\n\n    Args:\n        tableList: the list of tables\n        name(str): the name of the view\n        debug(bool): True if debug should be set\n    \"\"\"\n    general = Schema.getGeneral(tableList, name, debug)\n    cols = \"\"\n    delim = \"\"\n    for col in general[\"columns\"]:\n        cols += \"%s%s\" % (delim, col[\"name\"])\n        delim = \",\"\n    ddl = \"CREATE VIEW %s AS \\n\" % name\n    delim = \"\"\n    for table in tableList:\n        ddl += \"%s  SELECT %s FROM %s\" % (delim, cols, table[\"name\"])\n        delim = \"\\nUNION\\n\"\n    return ddl\n</code></pre>"},{"location":"#lodstorage.schema.SchemaManager","title":"<code>SchemaManager</code>","text":"<p>               Bases: <code>object</code></p> <p>a manager for schemas</p> Source code in <code>lodstorage/schema.py</code> <pre><code>class SchemaManager(\n    object,\n):\n    \"\"\"\n    a manager for schemas\n    \"\"\"\n\n    def __init__(self, schemaDefs=None, baseUrl: str = None):\n        \"\"\"\n        constructor\n            Args:\n                schemaDefs(dict): a dictionary of schema names\n                baseUrl(str): the base url to use for links\n        \"\"\"\n        self.baseUrl = baseUrl\n        self.schemasByName = {}\n        if schemaDefs is None:\n            schemaDefs = {}\n        for key, name in schemaDefs.items():\n            self.schemasByName[key] = Schema(key, name)\n        pass\n</code></pre>"},{"location":"#lodstorage.schema.SchemaManager.__init__","title":"<code>__init__(schemaDefs=None, baseUrl=None)</code>","text":"<p>constructor     Args:         schemaDefs(dict): a dictionary of schema names         baseUrl(str): the base url to use for links</p> Source code in <code>lodstorage/schema.py</code> <pre><code>def __init__(self, schemaDefs=None, baseUrl: str = None):\n    \"\"\"\n    constructor\n        Args:\n            schemaDefs(dict): a dictionary of schema names\n            baseUrl(str): the base url to use for links\n    \"\"\"\n    self.baseUrl = baseUrl\n    self.schemasByName = {}\n    if schemaDefs is None:\n        schemaDefs = {}\n    for key, name in schemaDefs.items():\n        self.schemasByName[key] = Schema(key, name)\n    pass\n</code></pre>"},{"location":"#lodstorage.sparql","title":"<code>sparql</code>","text":"<p>Created on 2020-08-14</p> <p>@author: wf</p>"},{"location":"#lodstorage.sparql.SPARQL","title":"<code>SPARQL</code>","text":"<p>               Bases: <code>object</code></p> <p>wrapper for SPARQL e.g. Apache Jena, Virtuoso, Blazegraph</p> <p>:ivar url: full endpoint url (including mode) :ivar mode: 'query' or 'update' :ivar debug: True if debugging is active :ivar typedLiterals: True if INSERT should be done with typedLiterals :ivar profile(boolean): True if profiling / timing information should be displayed :ivar sparql: the SPARQLWrapper2 instance to be used :ivar method(str): the HTTP method to be used 'POST' or 'GET'</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>class SPARQL(object):\n    \"\"\"\n    wrapper for SPARQL e.g. Apache Jena, Virtuoso, Blazegraph\n\n    :ivar url: full endpoint url (including mode)\n    :ivar mode: 'query' or 'update'\n    :ivar debug: True if debugging is active\n    :ivar typedLiterals: True if INSERT should be done with typedLiterals\n    :ivar profile(boolean): True if profiling / timing information should be displayed\n    :ivar sparql: the SPARQLWrapper2 instance to be used\n    :ivar method(str): the HTTP method to be used 'POST' or 'GET'\n    \"\"\"\n\n    def __init__(\n        self,\n        url,\n        mode=\"query\",\n        debug=False,\n        isFuseki=False,\n        typedLiterals=False,\n        profile=False,\n        agent=\"PyLodStorage\",\n        method=\"POST\",\n    ):\n        \"\"\"\n        Constructor a SPARQL wrapper\n\n        Args:\n            url(string): the base URL of the endpoint - the mode query/update is going to be appended\n            mode(string): 'query' or 'update'\n            debug(bool): True if debugging is to be activated\n            typedLiterals(bool): True if INSERT should be done with typedLiterals\n            profile(boolean): True if profiling / timing information should be displayed\n            agent(string): the User agent to use\n            method(string): the HTTP method to be used 'POST' or 'GET'\n        \"\"\"\n        if isFuseki:\n            self.url = f\"{url}/{mode}\"\n        else:\n            self.url = url\n        self.mode = mode\n        self.debug = debug\n        self.typedLiterals = typedLiterals\n        self.profile = profile\n        self.sparql = SPARQLWrapper2(url)\n        self.method = method\n        self.sparql.agent = agent\n\n    @classmethod\n    def fromEndpointConf(cls, endpointConf) -&gt; \"SPARQL\":\n        \"\"\"\n        create a SPARQL endpoint from the given EndpointConfiguration\n\n        Args:\n            endpointConf(Endpoint): the endpoint configuration to be used\n        \"\"\"\n        sparql = SPARQL(url=endpointConf.endpoint, method=endpointConf.method)\n        if hasattr(endpointConf, \"auth\"):\n            authMethod = None\n            if endpointConf.auth == \"BASIC\":\n                authMethod = BASIC\n            elif endpointConf.auth == \"DIGEST\":\n                authMethod = DIGEST\n            sparql.addAuthentication(\n                endpointConf.user, endpointConf.passwd, method=authMethod\n            )\n        return sparql\n\n    def addAuthentication(\n        self, username: str, password: str, method: Union[BASIC, DIGEST] = BASIC\n    ):\n        \"\"\"\n        Add Http Authentication credentials to the sparql wrapper\n        Args:\n            username: name of the user\n            password: password of the user\n            method: HTTP Authentication method\n        \"\"\"\n        self.sparql.setHTTPAuth(method)\n        self.sparql.setCredentials(username, password)\n\n    def rawQuery(self, queryString, method=POST):\n        \"\"\"\n        query with the given query string\n\n        Args:\n            queryString(string): the SPARQL query to be performed\n            method(string): POST or GET - POST is mandatory for update queries\n        Returns:\n            list: the raw query result as bindings\n        \"\"\"\n        queryString = self.fix_comments(queryString)\n        self.sparql.setQuery(queryString)\n        self.sparql.method = method\n        queryResult = self.sparql.query()\n        return queryResult\n\n    def fix_comments(self, query_string: str) -&gt; str:\n        \"\"\"\n        make sure broken SPARQLWrapper will find comments\n        \"\"\"\n        if query_string is None:\n            return None\n        return \"#\\n\" + query_string\n\n    def getValue(self, sparqlQuery: str, attr: str):\n        \"\"\"\n        get the value for the given SPARQL query using the given attr\n\n        Args:\n            sparql(SPARQL): the SPARQL endpoint to ge the value for\n            sparqlQuery(str): the SPARQL query to run\n            attr(str): the attribute to get\n        \"\"\"\n        if self.debug:\n            print(sparqlQuery)\n        qLod = self.queryAsListOfDicts(sparqlQuery)\n        return self.getFirst(qLod, attr)\n\n    def getValues(self, sparqlQuery: str, attrList: list):\n        \"\"\"\n        get Values for the given sparlQuery and attribute list\n\n        Args:\n            sparqlQuery(str): the query which did not return any values\n            attrList(list): the list of attributes\n        \"\"\"\n        if self.debug:\n            print(sparqlQuery)\n        qLod = self.queryAsListOfDicts(sparqlQuery)\n        if not (len(qLod) == 1):\n            msg = f\"getValues for {attrList} failed for {qLod}\"\n            raise Exception(msg)\n        record = qLod[0]\n        values = ()\n        for attr in attrList:\n            if not attr in record:\n                msg = f\"getValues failed for attribute {attr} which is missing in result record {record}\"\n                raise Exception(msg)\n            recordTuple = (record[attr],)\n            values += recordTuple\n        return values\n\n    def getFirst(self, qLod: list, attr: str):\n        \"\"\"\n        get the column attr of the first row of the given qLod list\n\n        Args:\n            qLod(list): the list of dicts (returned by a query)\n            attr(str): the attribute to retrieve\n\n        Returns:\n            object: the value\n        \"\"\"\n        if len(qLod) == 1 and attr in qLod[0]:\n            value = qLod[0][attr]\n            return value\n        raise Exception(f\"getFirst for attribute {attr} failed for {qLod}\")\n\n    def getResults(self, jsonResult):\n        \"\"\"\n        get the result from the given jsonResult\n\n        Args:\n            jsonResult: the JSON encoded result\n\n        Returns:\n            list: the list of bindings\n        \"\"\"\n        return jsonResult.bindings\n\n    def insert(self, insertCommand):\n        \"\"\"\n        run an insert\n\n        Args:\n            insertCommand(string): the SPARQL INSERT command\n\n        Returns:\n            a response\n        \"\"\"\n        self.sparql.setRequestMethod(POSTDIRECTLY)\n        response = None\n        exception = None\n        try:\n            response = self.rawQuery(insertCommand, method=POST)\n            # see https://github.com/RDFLib/sparqlwrapper/issues/159#issuecomment-674523696\n            # dummy read the body\n            response.response.read()\n        except Exception as ex:\n            exception = ex\n            if self.debug:\n                print(ex)\n        return response, exception\n\n    def getLocalName(self, name):\n        \"\"\"\n        retrieve valid localname from a string based primary key\n        https://www.w3.org/TR/sparql11-query/#prefNames\n\n        Args:\n            name(string): the name to convert\n\n        Returns:\n            string: a valid local name\n        \"\"\"\n        localName = \"\".join(ch for ch in name if ch.isalnum())\n        return localName\n\n    def insertListOfDicts(\n        self,\n        listOfDicts,\n        entityType,\n        primaryKey,\n        prefixes,\n        limit=None,\n        batchSize=None,\n        profile=False,\n    ):\n        \"\"\"\n        insert the given list of dicts mapping datatypes\n\n        Args:\n            entityType(string): the entityType to use as a\n            primaryKey(string): the name of the primary key attribute to use\n            prefix(string): any PREFIX statements to be used\n            limit(int): maximum number of records to insert\n            batchSize(int): number of records to send per request\n\n        Return:\n            a list of errors which should be empty on full success\n\n        datatype maping according to\n        https://www.w3.org/TR/xmlschema-2/#built-in-datatypes\n\n        mapped from\n        https://docs.python.org/3/library/stdtypes.html\n\n        compare to\n        https://www.w3.org/2001/sw/rdb2rdf/directGraph/\n        http://www.bobdc.com/blog/json2rdf/\n        https://www.w3.org/TR/json-ld11-api/#data-round-tripping\n        https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python\n        \"\"\"\n        if limit is not None:\n            listOfDicts = listOfDicts[:limit]\n        else:\n            limit = len(listOfDicts)\n        total = len(listOfDicts)\n        if batchSize is None:\n            return self.insertListOfDictsBatch(\n                listOfDicts, entityType, primaryKey, prefixes, total=total\n            )\n        else:\n            startTime = time.time()\n            errors = []\n            # store the list in batches\n            for i in range(0, total, batchSize):\n                recordBatch = listOfDicts[i : i + batchSize]\n                batchErrors = self.insertListOfDictsBatch(\n                    recordBatch,\n                    entityType,\n                    primaryKey,\n                    prefixes,\n                    batchIndex=i,\n                    total=total,\n                    startTime=startTime,\n                )\n                errors.extend(batchErrors)\n            if self.profile:\n                print(\n                    \"insertListOfDicts for %9d records in %6.1f secs\"\n                    % (len(listOfDicts), time.time() - startTime),\n                    flush=True,\n                )\n            return errors\n\n    def insertListOfDictsBatch(\n        self,\n        listOfDicts,\n        entityType,\n        primaryKey,\n        prefixes,\n        title=\"batch\",\n        batchIndex=None,\n        total=None,\n        startTime=None,\n    ):\n        \"\"\"\n        insert a Batch part of listOfDicts\n\n        Args:\n            entityType(string): the entityType to use as a\n            primaryKey(string): the name of the primary key attribute to use\n            prefix(string): any PREFIX statements to be used\n            title(string): the title to display for the profiling (if any)\n            batchIndex(int): the start index of the current batch\n            total(int): the total number of records for all batches\n            starttime(datetime): the start of the batch processing\n\n        Return:\n            a list of errors which should be empty on full success\n        \"\"\"\n        errors = []\n        size = len(listOfDicts)\n        if batchIndex is None:\n            batchIndex = 0\n        batchStartTime = time.time()\n        if startTime is None:\n            startTime = batchStartTime\n        rdfprefix = \"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\\n\"\n        insertCommand = f\"{rdfprefix}{prefixes}\\nINSERT DATA {{\\n\"\n        for index, record in enumerate(listOfDicts):\n            if not primaryKey in record:\n                errors.append(f\"missing primary key {primaryKey} in record {index}\")\n            else:\n                primaryValue = record[primaryKey]\n                if primaryValue is None:\n                    errors.append(\n                        f\"primary key {primaryKey} value is None in record {index}\"\n                    )\n                else:\n                    encodedPrimaryValue = self.getLocalName(primaryValue)\n                    tSubject = f\"{entityType}__{encodedPrimaryValue}\"\n                    insertCommand += f'  {tSubject} rdf:type \"{entityType}\".\\n'\n                    for keyValue in record.items():\n                        key, value = keyValue\n                        # convert key if necessary\n                        key = self.getLocalName(key)\n                        valueType = type(value)\n                        if self.debug:\n                            print(\"%s(%s)=%s\" % (key, valueType, value))\n                        tPredicate = f\"{entityType}_{key}\"\n                        tObject = value\n                        if valueType == str:\n                            escapedString = self.controlEscape(value)\n                            tObject = '\"%s\"' % escapedString\n                        elif valueType == int:\n                            if self.typedLiterals:\n                                tObject = (\n                                    '\"%d\"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'\n                                    % value\n                                )\n                            pass\n                        elif valueType == float:\n                            if self.typedLiterals:\n                                tObject = (\n                                    '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;'\n                                    % value\n                                )\n                            pass\n                        elif valueType == bool:\n                            pass\n                        elif valueType == datetime.date:\n                            # if self.typedLiterals:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;' % value\n                            )\n                            pass\n                        elif valueType == datetime.datetime:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;'\n                                % value\n                            )\n                            pass\n                        else:\n                            errors.append(\n                                \"can't handle type %s in record %d\" % (valueType, index)\n                            )\n                            tObject = None\n                        if tObject is not None:\n                            insertRecord = \"  %s %s %s.\\n\" % (\n                                tSubject,\n                                tPredicate,\n                                tObject,\n                            )\n                            insertCommand += insertRecord\n        insertCommand += \"\\n}\"\n        if self.debug:\n            print(insertCommand, flush=True)\n        response, ex = self.insert(insertCommand)\n        if response is None and ex is not None:\n            errors.append(\"%s for record %d\" % (str(ex), index))\n        if self.profile:\n            print(\n                \"%7s for %9d - %9d of %9d %s in %6.1f s -&gt; %6.1f s\"\n                % (\n                    title,\n                    batchIndex + 1,\n                    batchIndex + size,\n                    total,\n                    entityType,\n                    time.time() - batchStartTime,\n                    time.time() - startTime,\n                ),\n                flush=True,\n            )\n        return errors\n\n    controlChars = [chr(c) for c in range(0x20)]\n\n    @staticmethod\n    def controlEscape(s):\n        \"\"\"\n        escape control characters\n\n        see https://stackoverflow.com/a/9778992/1497139\n        \"\"\"\n        escaped = \"\".join(\n            [\n                c.encode(\"unicode_escape\").decode(\"ascii\")\n                if c in SPARQL.controlChars\n                else c\n                for c in s\n            ]\n        )\n        escaped = escaped.replace('\"', '\\\\\"')\n        return escaped\n\n    def query(self, queryString, method=POST):\n        \"\"\"\n        get a list of results for the given query\n\n        Args:\n            queryString(string): the SPARQL query to execute\n            method(string): the method eg. POST to use\n\n        Returns:\n            list: list of bindings\n        \"\"\"\n        queryResult = self.rawQuery(queryString, method=method)\n        if self.debug:\n            print(queryString)\n        if hasattr(queryResult, \"info\"):\n            if \"content-type\" in queryResult.info():\n                ct = queryResult.info()[\"content-type\"]\n                if \"text/html\" in ct:\n                    response = queryResult.response.read().decode()\n                    if not \"Success\" in response:\n                        raise (\"%s failed: %s\", response)\n                return None\n        jsonResult = queryResult.convert()\n        return self.getResults(jsonResult)\n\n    def queryAsListOfDicts(\n        self, queryString, fixNone: bool = False, sampleCount: int = None\n    ):\n        \"\"\"\n        get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)\n\n        Args:\n            queryString(string): the SPARQL query to execute\n            fixNone(bool): if True add None values for empty columns in Dict\n            sampleCount(int): the number of samples to check\n\n        Returns:\n            list: a list ofDicts\n        \"\"\"\n        records = self.query(queryString, method=self.method)\n        listOfDicts = self.asListOfDicts(\n            records, fixNone=fixNone, sampleCount=sampleCount\n        )\n        return listOfDicts\n\n    @staticmethod\n    def strToDatetime(value, debug=False):\n        \"\"\"\n        convert a string to a datetime\n        Args:\n            value(str): the value to convert\n        Returns:\n            datetime: the datetime\n        \"\"\"\n        dateFormat = \"%Y-%m-%d %H:%M:%S.%f\"\n        if \"T\" in value and \"Z\" in value:\n            dateFormat = \"%Y-%m-%dT%H:%M:%SZ\"\n        dt = None\n        try:\n            dt = datetime.datetime.strptime(value, dateFormat)\n        except ValueError as ve:\n            if debug:\n                print(str(ve))\n        return dt\n\n    def asListOfDicts(self, records, fixNone: bool = False, sampleCount: int = None):\n        \"\"\"\n        convert SPARQL result back to python native\n\n        Args:\n            record(list): the list of bindings\n            fixNone(bool): if True add None values for empty columns in Dict\n            sampleCount(int): the number of samples to check\n\n        Returns:\n            list: a list of Dicts\n        \"\"\"\n        resultList = []\n        fields = None\n        if fixNone:\n            fields = LOD.getFields(records, sampleCount)\n        for record in records:\n            resultDict = {}\n            for keyValue in record.items():\n                key, value = keyValue\n                datatype = value.datatype\n                if datatype is not None:\n                    if datatype == \"http://www.w3.org/2001/XMLSchema#integer\":\n                        resultValue = int(value.value)\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#decimal\":\n                        resultValue = float(value.value)\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#boolean\":\n                        resultValue = value.value in [\"TRUE\", \"true\"]\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#date\":\n                        dt = datetime.datetime.strptime(value.value, \"%Y-%m-%d\")\n                        resultValue = dt.date()\n                    elif datatype == \"http://www.w3.org/2001/XMLSchema#dateTime\":\n                        dt = SPARQL.strToDatetime(value.value, debug=self.debug)\n                        resultValue = dt\n                    else:\n                        # unsupported datatype\n                        resultValue = value.value\n                else:\n                    resultValue = value.value\n                resultDict[key] = resultValue\n            if fixNone:\n                for field in fields:\n                    if not field in resultDict:\n                        resultDict[field] = None\n            resultList.append(resultDict)\n        return resultList\n\n    def printErrors(self, errors):\n        \"\"\"\n        print the given list of errors\n\n        Args:\n            errors(list): a list of error strings\n\n        Returns:\n            boolean: True if the list is empty else false\n        \"\"\"\n        if len(errors) &gt; 0:\n            print(\"ERRORS:\")\n            for error in errors:\n                print(error, flush=True, file=stderr)\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.__init__","title":"<code>__init__(url, mode='query', debug=False, isFuseki=False, typedLiterals=False, profile=False, agent='PyLodStorage', method='POST')</code>","text":"<p>Constructor a SPARQL wrapper</p> <p>Parameters:</p> Name Type Description Default <code>url(string)</code> <p>the base URL of the endpoint - the mode query/update is going to be appended</p> required <code>mode(string)</code> <p>'query' or 'update'</p> required <code>debug(bool)</code> <p>True if debugging is to be activated</p> required <code>typedLiterals(bool)</code> <p>True if INSERT should be done with typedLiterals</p> required <code>profile(boolean)</code> <p>True if profiling / timing information should be displayed</p> required <code>agent(string)</code> <p>the User agent to use</p> required <code>method(string)</code> <p>the HTTP method to be used 'POST' or 'GET'</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>def __init__(\n    self,\n    url,\n    mode=\"query\",\n    debug=False,\n    isFuseki=False,\n    typedLiterals=False,\n    profile=False,\n    agent=\"PyLodStorage\",\n    method=\"POST\",\n):\n    \"\"\"\n    Constructor a SPARQL wrapper\n\n    Args:\n        url(string): the base URL of the endpoint - the mode query/update is going to be appended\n        mode(string): 'query' or 'update'\n        debug(bool): True if debugging is to be activated\n        typedLiterals(bool): True if INSERT should be done with typedLiterals\n        profile(boolean): True if profiling / timing information should be displayed\n        agent(string): the User agent to use\n        method(string): the HTTP method to be used 'POST' or 'GET'\n    \"\"\"\n    if isFuseki:\n        self.url = f\"{url}/{mode}\"\n    else:\n        self.url = url\n    self.mode = mode\n    self.debug = debug\n    self.typedLiterals = typedLiterals\n    self.profile = profile\n    self.sparql = SPARQLWrapper2(url)\n    self.method = method\n    self.sparql.agent = agent\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.addAuthentication","title":"<code>addAuthentication(username, password, method=BASIC)</code>","text":"<p>Add Http Authentication credentials to the sparql wrapper Args:     username: name of the user     password: password of the user     method: HTTP Authentication method</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def addAuthentication(\n    self, username: str, password: str, method: Union[BASIC, DIGEST] = BASIC\n):\n    \"\"\"\n    Add Http Authentication credentials to the sparql wrapper\n    Args:\n        username: name of the user\n        password: password of the user\n        method: HTTP Authentication method\n    \"\"\"\n    self.sparql.setHTTPAuth(method)\n    self.sparql.setCredentials(username, password)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.asListOfDicts","title":"<code>asListOfDicts(records, fixNone=False, sampleCount=None)</code>","text":"<p>convert SPARQL result back to python native</p> <p>Parameters:</p> Name Type Description Default <code>record(list)</code> <p>the list of bindings</p> required <code>fixNone(bool)</code> <p>if True add None values for empty columns in Dict</p> required <code>sampleCount(int)</code> <p>the number of samples to check</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list of Dicts</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def asListOfDicts(self, records, fixNone: bool = False, sampleCount: int = None):\n    \"\"\"\n    convert SPARQL result back to python native\n\n    Args:\n        record(list): the list of bindings\n        fixNone(bool): if True add None values for empty columns in Dict\n        sampleCount(int): the number of samples to check\n\n    Returns:\n        list: a list of Dicts\n    \"\"\"\n    resultList = []\n    fields = None\n    if fixNone:\n        fields = LOD.getFields(records, sampleCount)\n    for record in records:\n        resultDict = {}\n        for keyValue in record.items():\n            key, value = keyValue\n            datatype = value.datatype\n            if datatype is not None:\n                if datatype == \"http://www.w3.org/2001/XMLSchema#integer\":\n                    resultValue = int(value.value)\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#decimal\":\n                    resultValue = float(value.value)\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#boolean\":\n                    resultValue = value.value in [\"TRUE\", \"true\"]\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#date\":\n                    dt = datetime.datetime.strptime(value.value, \"%Y-%m-%d\")\n                    resultValue = dt.date()\n                elif datatype == \"http://www.w3.org/2001/XMLSchema#dateTime\":\n                    dt = SPARQL.strToDatetime(value.value, debug=self.debug)\n                    resultValue = dt\n                else:\n                    # unsupported datatype\n                    resultValue = value.value\n            else:\n                resultValue = value.value\n            resultDict[key] = resultValue\n        if fixNone:\n            for field in fields:\n                if not field in resultDict:\n                    resultDict[field] = None\n        resultList.append(resultDict)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.controlEscape","title":"<code>controlEscape(s)</code>  <code>staticmethod</code>","text":"<p>escape control characters</p> <p>see https://stackoverflow.com/a/9778992/1497139</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>@staticmethod\ndef controlEscape(s):\n    \"\"\"\n    escape control characters\n\n    see https://stackoverflow.com/a/9778992/1497139\n    \"\"\"\n    escaped = \"\".join(\n        [\n            c.encode(\"unicode_escape\").decode(\"ascii\")\n            if c in SPARQL.controlChars\n            else c\n            for c in s\n        ]\n    )\n    escaped = escaped.replace('\"', '\\\\\"')\n    return escaped\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.fix_comments","title":"<code>fix_comments(query_string)</code>","text":"<p>make sure broken SPARQLWrapper will find comments</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def fix_comments(self, query_string: str) -&gt; str:\n    \"\"\"\n    make sure broken SPARQLWrapper will find comments\n    \"\"\"\n    if query_string is None:\n        return None\n    return \"#\\n\" + query_string\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.fromEndpointConf","title":"<code>fromEndpointConf(endpointConf)</code>  <code>classmethod</code>","text":"<p>create a SPARQL endpoint from the given EndpointConfiguration</p> <p>Parameters:</p> Name Type Description Default <code>endpointConf(Endpoint)</code> <p>the endpoint configuration to be used</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>@classmethod\ndef fromEndpointConf(cls, endpointConf) -&gt; \"SPARQL\":\n    \"\"\"\n    create a SPARQL endpoint from the given EndpointConfiguration\n\n    Args:\n        endpointConf(Endpoint): the endpoint configuration to be used\n    \"\"\"\n    sparql = SPARQL(url=endpointConf.endpoint, method=endpointConf.method)\n    if hasattr(endpointConf, \"auth\"):\n        authMethod = None\n        if endpointConf.auth == \"BASIC\":\n            authMethod = BASIC\n        elif endpointConf.auth == \"DIGEST\":\n            authMethod = DIGEST\n        sparql.addAuthentication(\n            endpointConf.user, endpointConf.passwd, method=authMethod\n        )\n    return sparql\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getFirst","title":"<code>getFirst(qLod, attr)</code>","text":"<p>get the column attr of the first row of the given qLod list</p> <p>Parameters:</p> Name Type Description Default <code>qLod(list)</code> <p>the list of dicts (returned by a query)</p> required <code>attr(str)</code> <p>the attribute to retrieve</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>the value</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getFirst(self, qLod: list, attr: str):\n    \"\"\"\n    get the column attr of the first row of the given qLod list\n\n    Args:\n        qLod(list): the list of dicts (returned by a query)\n        attr(str): the attribute to retrieve\n\n    Returns:\n        object: the value\n    \"\"\"\n    if len(qLod) == 1 and attr in qLod[0]:\n        value = qLod[0][attr]\n        return value\n    raise Exception(f\"getFirst for attribute {attr} failed for {qLod}\")\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getLocalName","title":"<code>getLocalName(name)</code>","text":"<p>retrieve valid localname from a string based primary key https://www.w3.org/TR/sparql11-query/#prefNames</p> <p>Parameters:</p> Name Type Description Default <code>name(string)</code> <p>the name to convert</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>a valid local name</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getLocalName(self, name):\n    \"\"\"\n    retrieve valid localname from a string based primary key\n    https://www.w3.org/TR/sparql11-query/#prefNames\n\n    Args:\n        name(string): the name to convert\n\n    Returns:\n        string: a valid local name\n    \"\"\"\n    localName = \"\".join(ch for ch in name if ch.isalnum())\n    return localName\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getResults","title":"<code>getResults(jsonResult)</code>","text":"<p>get the result from the given jsonResult</p> <p>Parameters:</p> Name Type Description Default <code>jsonResult</code> <p>the JSON encoded result</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>the list of bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def getResults(self, jsonResult):\n    \"\"\"\n    get the result from the given jsonResult\n\n    Args:\n        jsonResult: the JSON encoded result\n\n    Returns:\n        list: the list of bindings\n    \"\"\"\n    return jsonResult.bindings\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getValue","title":"<code>getValue(sparqlQuery, attr)</code>","text":"<p>get the value for the given SPARQL query using the given attr</p> <p>Parameters:</p> Name Type Description Default <code>sparql(SPARQL)</code> <p>the SPARQL endpoint to ge the value for</p> required <code>sparqlQuery(str)</code> <p>the SPARQL query to run</p> required <code>attr(str)</code> <p>the attribute to get</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>def getValue(self, sparqlQuery: str, attr: str):\n    \"\"\"\n    get the value for the given SPARQL query using the given attr\n\n    Args:\n        sparql(SPARQL): the SPARQL endpoint to ge the value for\n        sparqlQuery(str): the SPARQL query to run\n        attr(str): the attribute to get\n    \"\"\"\n    if self.debug:\n        print(sparqlQuery)\n    qLod = self.queryAsListOfDicts(sparqlQuery)\n    return self.getFirst(qLod, attr)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.getValues","title":"<code>getValues(sparqlQuery, attrList)</code>","text":"<p>get Values for the given sparlQuery and attribute list</p> <p>Parameters:</p> Name Type Description Default <code>sparqlQuery(str)</code> <p>the query which did not return any values</p> required <code>attrList(list)</code> <p>the list of attributes</p> required Source code in <code>lodstorage/sparql.py</code> <pre><code>def getValues(self, sparqlQuery: str, attrList: list):\n    \"\"\"\n    get Values for the given sparlQuery and attribute list\n\n    Args:\n        sparqlQuery(str): the query which did not return any values\n        attrList(list): the list of attributes\n    \"\"\"\n    if self.debug:\n        print(sparqlQuery)\n    qLod = self.queryAsListOfDicts(sparqlQuery)\n    if not (len(qLod) == 1):\n        msg = f\"getValues for {attrList} failed for {qLod}\"\n        raise Exception(msg)\n    record = qLod[0]\n    values = ()\n    for attr in attrList:\n        if not attr in record:\n            msg = f\"getValues failed for attribute {attr} which is missing in result record {record}\"\n            raise Exception(msg)\n        recordTuple = (record[attr],)\n        values += recordTuple\n    return values\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insert","title":"<code>insert(insertCommand)</code>","text":"<p>run an insert</p> <p>Parameters:</p> Name Type Description Default <code>insertCommand(string)</code> <p>the SPARQL INSERT command</p> required <p>Returns:</p> Type Description <p>a response</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insert(self, insertCommand):\n    \"\"\"\n    run an insert\n\n    Args:\n        insertCommand(string): the SPARQL INSERT command\n\n    Returns:\n        a response\n    \"\"\"\n    self.sparql.setRequestMethod(POSTDIRECTLY)\n    response = None\n    exception = None\n    try:\n        response = self.rawQuery(insertCommand, method=POST)\n        # see https://github.com/RDFLib/sparqlwrapper/issues/159#issuecomment-674523696\n        # dummy read the body\n        response.response.read()\n    except Exception as ex:\n        exception = ex\n        if self.debug:\n            print(ex)\n    return response, exception\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insertListOfDicts","title":"<code>insertListOfDicts(listOfDicts, entityType, primaryKey, prefixes, limit=None, batchSize=None, profile=False)</code>","text":"<p>insert the given list of dicts mapping datatypes</p> <p>Parameters:</p> Name Type Description Default <code>entityType(string)</code> <p>the entityType to use as a</p> required <code>primaryKey(string)</code> <p>the name of the primary key attribute to use</p> required <code>prefix(string)</code> <p>any PREFIX statements to be used</p> required <code>limit(int)</code> <p>maximum number of records to insert</p> required <code>batchSize(int)</code> <p>number of records to send per request</p> required Return <p>a list of errors which should be empty on full success</p> <p>datatype maping according to https://www.w3.org/TR/xmlschema-2/#built-in-datatypes</p> <p>mapped from https://docs.python.org/3/library/stdtypes.html</p> <p>compare to https://www.w3.org/2001/sw/rdb2rdf/directGraph/ http://www.bobdc.com/blog/json2rdf/ https://www.w3.org/TR/json-ld11-api/#data-round-tripping https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insertListOfDicts(\n    self,\n    listOfDicts,\n    entityType,\n    primaryKey,\n    prefixes,\n    limit=None,\n    batchSize=None,\n    profile=False,\n):\n    \"\"\"\n    insert the given list of dicts mapping datatypes\n\n    Args:\n        entityType(string): the entityType to use as a\n        primaryKey(string): the name of the primary key attribute to use\n        prefix(string): any PREFIX statements to be used\n        limit(int): maximum number of records to insert\n        batchSize(int): number of records to send per request\n\n    Return:\n        a list of errors which should be empty on full success\n\n    datatype maping according to\n    https://www.w3.org/TR/xmlschema-2/#built-in-datatypes\n\n    mapped from\n    https://docs.python.org/3/library/stdtypes.html\n\n    compare to\n    https://www.w3.org/2001/sw/rdb2rdf/directGraph/\n    http://www.bobdc.com/blog/json2rdf/\n    https://www.w3.org/TR/json-ld11-api/#data-round-tripping\n    https://stackoverflow.com/questions/29030231/json-to-rdf-xml-file-in-python\n    \"\"\"\n    if limit is not None:\n        listOfDicts = listOfDicts[:limit]\n    else:\n        limit = len(listOfDicts)\n    total = len(listOfDicts)\n    if batchSize is None:\n        return self.insertListOfDictsBatch(\n            listOfDicts, entityType, primaryKey, prefixes, total=total\n        )\n    else:\n        startTime = time.time()\n        errors = []\n        # store the list in batches\n        for i in range(0, total, batchSize):\n            recordBatch = listOfDicts[i : i + batchSize]\n            batchErrors = self.insertListOfDictsBatch(\n                recordBatch,\n                entityType,\n                primaryKey,\n                prefixes,\n                batchIndex=i,\n                total=total,\n                startTime=startTime,\n            )\n            errors.extend(batchErrors)\n        if self.profile:\n            print(\n                \"insertListOfDicts for %9d records in %6.1f secs\"\n                % (len(listOfDicts), time.time() - startTime),\n                flush=True,\n            )\n        return errors\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.insertListOfDictsBatch","title":"<code>insertListOfDictsBatch(listOfDicts, entityType, primaryKey, prefixes, title='batch', batchIndex=None, total=None, startTime=None)</code>","text":"<p>insert a Batch part of listOfDicts</p> <p>Parameters:</p> Name Type Description Default <code>entityType(string)</code> <p>the entityType to use as a</p> required <code>primaryKey(string)</code> <p>the name of the primary key attribute to use</p> required <code>prefix(string)</code> <p>any PREFIX statements to be used</p> required <code>title(string)</code> <p>the title to display for the profiling (if any)</p> required <code>batchIndex(int)</code> <p>the start index of the current batch</p> required <code>total(int)</code> <p>the total number of records for all batches</p> required <code>starttime(datetime)</code> <p>the start of the batch processing</p> required Return <p>a list of errors which should be empty on full success</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def insertListOfDictsBatch(\n    self,\n    listOfDicts,\n    entityType,\n    primaryKey,\n    prefixes,\n    title=\"batch\",\n    batchIndex=None,\n    total=None,\n    startTime=None,\n):\n    \"\"\"\n    insert a Batch part of listOfDicts\n\n    Args:\n        entityType(string): the entityType to use as a\n        primaryKey(string): the name of the primary key attribute to use\n        prefix(string): any PREFIX statements to be used\n        title(string): the title to display for the profiling (if any)\n        batchIndex(int): the start index of the current batch\n        total(int): the total number of records for all batches\n        starttime(datetime): the start of the batch processing\n\n    Return:\n        a list of errors which should be empty on full success\n    \"\"\"\n    errors = []\n    size = len(listOfDicts)\n    if batchIndex is None:\n        batchIndex = 0\n    batchStartTime = time.time()\n    if startTime is None:\n        startTime = batchStartTime\n    rdfprefix = \"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\\n\"\n    insertCommand = f\"{rdfprefix}{prefixes}\\nINSERT DATA {{\\n\"\n    for index, record in enumerate(listOfDicts):\n        if not primaryKey in record:\n            errors.append(f\"missing primary key {primaryKey} in record {index}\")\n        else:\n            primaryValue = record[primaryKey]\n            if primaryValue is None:\n                errors.append(\n                    f\"primary key {primaryKey} value is None in record {index}\"\n                )\n            else:\n                encodedPrimaryValue = self.getLocalName(primaryValue)\n                tSubject = f\"{entityType}__{encodedPrimaryValue}\"\n                insertCommand += f'  {tSubject} rdf:type \"{entityType}\".\\n'\n                for keyValue in record.items():\n                    key, value = keyValue\n                    # convert key if necessary\n                    key = self.getLocalName(key)\n                    valueType = type(value)\n                    if self.debug:\n                        print(\"%s(%s)=%s\" % (key, valueType, value))\n                    tPredicate = f\"{entityType}_{key}\"\n                    tObject = value\n                    if valueType == str:\n                        escapedString = self.controlEscape(value)\n                        tObject = '\"%s\"' % escapedString\n                    elif valueType == int:\n                        if self.typedLiterals:\n                            tObject = (\n                                '\"%d\"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;'\n                                % value\n                            )\n                        pass\n                    elif valueType == float:\n                        if self.typedLiterals:\n                            tObject = (\n                                '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#decimal&gt;'\n                                % value\n                            )\n                        pass\n                    elif valueType == bool:\n                        pass\n                    elif valueType == datetime.date:\n                        # if self.typedLiterals:\n                        tObject = (\n                            '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#date&gt;' % value\n                        )\n                        pass\n                    elif valueType == datetime.datetime:\n                        tObject = (\n                            '\"%s\"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt;'\n                            % value\n                        )\n                        pass\n                    else:\n                        errors.append(\n                            \"can't handle type %s in record %d\" % (valueType, index)\n                        )\n                        tObject = None\n                    if tObject is not None:\n                        insertRecord = \"  %s %s %s.\\n\" % (\n                            tSubject,\n                            tPredicate,\n                            tObject,\n                        )\n                        insertCommand += insertRecord\n    insertCommand += \"\\n}\"\n    if self.debug:\n        print(insertCommand, flush=True)\n    response, ex = self.insert(insertCommand)\n    if response is None and ex is not None:\n        errors.append(\"%s for record %d\" % (str(ex), index))\n    if self.profile:\n        print(\n            \"%7s for %9d - %9d of %9d %s in %6.1f s -&gt; %6.1f s\"\n            % (\n                title,\n                batchIndex + 1,\n                batchIndex + size,\n                total,\n                entityType,\n                time.time() - batchStartTime,\n                time.time() - startTime,\n            ),\n            flush=True,\n        )\n    return errors\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.printErrors","title":"<code>printErrors(errors)</code>","text":"<p>print the given list of errors</p> <p>Parameters:</p> Name Type Description Default <code>errors(list)</code> <p>a list of error strings</p> required <p>Returns:</p> Name Type Description <code>boolean</code> <p>True if the list is empty else false</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def printErrors(self, errors):\n    \"\"\"\n    print the given list of errors\n\n    Args:\n        errors(list): a list of error strings\n\n    Returns:\n        boolean: True if the list is empty else false\n    \"\"\"\n    if len(errors) &gt; 0:\n        print(\"ERRORS:\")\n        for error in errors:\n            print(error, flush=True, file=stderr)\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.query","title":"<code>query(queryString, method=POST)</code>","text":"<p>get a list of results for the given query</p> <p>Parameters:</p> Name Type Description Default <code>queryString(string)</code> <p>the SPARQL query to execute</p> required <code>method(string)</code> <p>the method eg. POST to use</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def query(self, queryString, method=POST):\n    \"\"\"\n    get a list of results for the given query\n\n    Args:\n        queryString(string): the SPARQL query to execute\n        method(string): the method eg. POST to use\n\n    Returns:\n        list: list of bindings\n    \"\"\"\n    queryResult = self.rawQuery(queryString, method=method)\n    if self.debug:\n        print(queryString)\n    if hasattr(queryResult, \"info\"):\n        if \"content-type\" in queryResult.info():\n            ct = queryResult.info()[\"content-type\"]\n            if \"text/html\" in ct:\n                response = queryResult.response.read().decode()\n                if not \"Success\" in response:\n                    raise (\"%s failed: %s\", response)\n            return None\n    jsonResult = queryResult.convert()\n    return self.getResults(jsonResult)\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.queryAsListOfDicts","title":"<code>queryAsListOfDicts(queryString, fixNone=False, sampleCount=None)</code>","text":"<p>get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)</p> <p>Parameters:</p> Name Type Description Default <code>queryString(string)</code> <p>the SPARQL query to execute</p> required <code>fixNone(bool)</code> <p>if True add None values for empty columns in Dict</p> required <code>sampleCount(int)</code> <p>the number of samples to check</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>a list ofDicts</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def queryAsListOfDicts(\n    self, queryString, fixNone: bool = False, sampleCount: int = None\n):\n    \"\"\"\n    get a list of dicts for the given query (to allow round-trip results for insertListOfDicts)\n\n    Args:\n        queryString(string): the SPARQL query to execute\n        fixNone(bool): if True add None values for empty columns in Dict\n        sampleCount(int): the number of samples to check\n\n    Returns:\n        list: a list ofDicts\n    \"\"\"\n    records = self.query(queryString, method=self.method)\n    listOfDicts = self.asListOfDicts(\n        records, fixNone=fixNone, sampleCount=sampleCount\n    )\n    return listOfDicts\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.rawQuery","title":"<code>rawQuery(queryString, method=POST)</code>","text":"<p>query with the given query string</p> <p>Parameters:</p> Name Type Description Default <code>queryString(string)</code> <p>the SPARQL query to be performed</p> required <code>method(string)</code> <p>POST or GET - POST is mandatory for update queries</p> required <p>Returns:     list: the raw query result as bindings</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>def rawQuery(self, queryString, method=POST):\n    \"\"\"\n    query with the given query string\n\n    Args:\n        queryString(string): the SPARQL query to be performed\n        method(string): POST or GET - POST is mandatory for update queries\n    Returns:\n        list: the raw query result as bindings\n    \"\"\"\n    queryString = self.fix_comments(queryString)\n    self.sparql.setQuery(queryString)\n    self.sparql.method = method\n    queryResult = self.sparql.query()\n    return queryResult\n</code></pre>"},{"location":"#lodstorage.sparql.SPARQL.strToDatetime","title":"<code>strToDatetime(value, debug=False)</code>  <code>staticmethod</code>","text":"<p>convert a string to a datetime Args:     value(str): the value to convert Returns:     datetime: the datetime</p> Source code in <code>lodstorage/sparql.py</code> <pre><code>@staticmethod\ndef strToDatetime(value, debug=False):\n    \"\"\"\n    convert a string to a datetime\n    Args:\n        value(str): the value to convert\n    Returns:\n        datetime: the datetime\n    \"\"\"\n    dateFormat = \"%Y-%m-%d %H:%M:%S.%f\"\n    if \"T\" in value and \"Z\" in value:\n        dateFormat = \"%Y-%m-%dT%H:%M:%SZ\"\n    dt = None\n    try:\n        dt = datetime.datetime.strptime(value, dateFormat)\n    except ValueError as ve:\n        if debug:\n            print(str(ve))\n    return dt\n</code></pre>"},{"location":"#lodstorage.sql","title":"<code>sql</code>","text":"<p>Created on 2020-08-24</p> <p>@author: wf</p>"},{"location":"#lodstorage.sql.DatetimeAdapter","title":"<code>DatetimeAdapter</code>","text":"<p>Singleton class for converting date and time formats with optional lenient error handling.</p> <p>Attributes:</p> Name Type Description <code>lenient</code> <code>bool</code> <p>Whether to handle conversion errors leniently, returning None and logging a warning.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>class DatetimeAdapter:\n    \"\"\"Singleton class for converting date and time formats with optional lenient error handling.\n\n    Attributes:\n        lenient (bool): Whether to handle conversion errors leniently, returning None and logging a warning.\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, lenient: bool = False):\n        \"\"\"Ensure only one instance of the adapter exists.\n\n        Args:\n            lenient (bool): If True, the adapter will not raise exceptions on conversion failures.\n\n        Returns:\n            DatetimeAdapter: The singleton instance of the adapter.\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super(DatetimeAdapter, cls).__new__(cls)\n            cls._instance.lenient = lenient\n        return cls._instance\n\n    def _handle_input(self, val: bytes) -&gt; str:\n        \"\"\"Validate and decode the input bytes into string.\n\n        Args:\n            val (bytes): The bytes input to validate and decode.\n\n        Returns:\n            str: The decoded string from bytes.\n\n        Raises:\n            TypeError: If the input is not bytes.\n        \"\"\"\n        if not isinstance(val, bytes):\n            raise TypeError(\"Input must be a byte string.\")\n        return val.decode()\n\n    def _handle_error(self, error: Exception, val: bytes):\n        \"\"\"Handle errors based on the lenient mode.\n\n        Args:\n            error (Exception): The exception that was raised.\n            val (bytes): The input value that caused the error.\n\n        Returns:\n            None: If lenient mode is True and an error occurs.\n\n        Raises:\n            Exception: If lenient mode is False and an error occurs.\n        \"\"\"\n        if self.lenient:\n            logging.warning(f\"Failed to convert {val}: {error}\")\n            return None\n        else:\n            raise error\n\n    def convert_date(self, val: bytes) -&gt; datetime.date:\n        \"\"\"Convert ISO 8601 date byte string to a datetime.date object.\n\n        Args:\n            val (bytes): The ISO 8601 date string in bytes.\n\n        Returns:\n            datetime.date: The converted date object.\n        \"\"\"\n        try:\n            decoded_date = self._handle_input(val)\n            return datetime.date.fromisoformat(decoded_date)\n        except Exception as e:\n            return self._handle_error(e, val)\n\n    def convert_datetime(self, val: bytes) -&gt; datetime.datetime:\n        \"\"\"Convert ISO 8601 datetime byte string to a datetime.datetime object.\n\n        Args:\n            val (bytes): The ISO 8601 datetime string in bytes.\n\n        Returns:\n            datetime.datetime: The converted datetime object.\n        \"\"\"\n        try:\n            decoded_datetime = self._handle_input(val)\n            return datetime.datetime.fromisoformat(decoded_datetime)\n        except Exception as e:\n            return self._handle_error(e, val)\n\n    def convert_timestamp(self, val: bytes) -&gt; datetime.datetime:\n        \"\"\"Convert Unix epoch timestamp byte string to a datetime.datetime object.\n\n        Args:\n            val (bytes): The Unix epoch timestamp in bytes.\n\n        Returns:\n            datetime.datetime: The converted datetime object.\n        \"\"\"\n        try:\n            decoded_string = self._handle_input(val)\n            timestamp_float = float(decoded_string) / 10**6\n            return datetime.datetime.fromtimestamp(timestamp_float)\n        except ValueError as _ve:\n            try:\n                # If not, try to parse it as a datetime string\n                dt = datetime.datetime.fromisoformat(decoded_string)\n                return dt\n            except Exception as e:\n                return self._handle_error(e, val)\n        except Exception as e:\n            return self._handle_error(e, val)\n\n    def set_lenient(self, lenient: bool):\n        \"\"\"Set the lenient mode of the adapter.\n\n        Args:\n            lenient (bool): True to enable lenient mode, False to disable it.\n        \"\"\"\n        self.lenient = lenient\n</code></pre>"},{"location":"#lodstorage.sql.DatetimeAdapter.__new__","title":"<code>__new__(lenient=False)</code>","text":"<p>Ensure only one instance of the adapter exists.</p> <p>Parameters:</p> Name Type Description Default <code>lenient</code> <code>bool</code> <p>If True, the adapter will not raise exceptions on conversion failures.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>DatetimeAdapter</code> <p>The singleton instance of the adapter.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def __new__(cls, lenient: bool = False):\n    \"\"\"Ensure only one instance of the adapter exists.\n\n    Args:\n        lenient (bool): If True, the adapter will not raise exceptions on conversion failures.\n\n    Returns:\n        DatetimeAdapter: The singleton instance of the adapter.\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super(DatetimeAdapter, cls).__new__(cls)\n        cls._instance.lenient = lenient\n    return cls._instance\n</code></pre>"},{"location":"#lodstorage.sql.DatetimeAdapter.convert_date","title":"<code>convert_date(val)</code>","text":"<p>Convert ISO 8601 date byte string to a datetime.date object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>bytes</code> <p>The ISO 8601 date string in bytes.</p> required <p>Returns:</p> Type Description <code>date</code> <p>datetime.date: The converted date object.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_date(self, val: bytes) -&gt; datetime.date:\n    \"\"\"Convert ISO 8601 date byte string to a datetime.date object.\n\n    Args:\n        val (bytes): The ISO 8601 date string in bytes.\n\n    Returns:\n        datetime.date: The converted date object.\n    \"\"\"\n    try:\n        decoded_date = self._handle_input(val)\n        return datetime.date.fromisoformat(decoded_date)\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sql.DatetimeAdapter.convert_datetime","title":"<code>convert_datetime(val)</code>","text":"<p>Convert ISO 8601 datetime byte string to a datetime.datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>bytes</code> <p>The ISO 8601 datetime string in bytes.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: The converted datetime object.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_datetime(self, val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert ISO 8601 datetime byte string to a datetime.datetime object.\n\n    Args:\n        val (bytes): The ISO 8601 datetime string in bytes.\n\n    Returns:\n        datetime.datetime: The converted datetime object.\n    \"\"\"\n    try:\n        decoded_datetime = self._handle_input(val)\n        return datetime.datetime.fromisoformat(decoded_datetime)\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sql.DatetimeAdapter.convert_timestamp","title":"<code>convert_timestamp(val)</code>","text":"<p>Convert Unix epoch timestamp byte string to a datetime.datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>bytes</code> <p>The Unix epoch timestamp in bytes.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: The converted datetime object.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_timestamp(self, val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert Unix epoch timestamp byte string to a datetime.datetime object.\n\n    Args:\n        val (bytes): The Unix epoch timestamp in bytes.\n\n    Returns:\n        datetime.datetime: The converted datetime object.\n    \"\"\"\n    try:\n        decoded_string = self._handle_input(val)\n        timestamp_float = float(decoded_string) / 10**6\n        return datetime.datetime.fromtimestamp(timestamp_float)\n    except ValueError as _ve:\n        try:\n            # If not, try to parse it as a datetime string\n            dt = datetime.datetime.fromisoformat(decoded_string)\n            return dt\n        except Exception as e:\n            return self._handle_error(e, val)\n    except Exception as e:\n        return self._handle_error(e, val)\n</code></pre>"},{"location":"#lodstorage.sql.DatetimeAdapter.set_lenient","title":"<code>set_lenient(lenient)</code>","text":"<p>Set the lenient mode of the adapter.</p> <p>Parameters:</p> Name Type Description Default <code>lenient</code> <code>bool</code> <p>True to enable lenient mode, False to disable it.</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def set_lenient(self, lenient: bool):\n    \"\"\"Set the lenient mode of the adapter.\n\n    Args:\n        lenient (bool): True to enable lenient mode, False to disable it.\n    \"\"\"\n    self.lenient = lenient\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo","title":"<code>EntityInfo</code>","text":"<p>               Bases: <code>object</code></p> <p>holds entity meta Info</p> <p>:ivar name(string): entity name = table name</p> <p>:ivar primaryKey(string): the name of the primary key column</p> <p>:ivar typeMap(dict): maps column names to python types</p> <p>:ivar debug(boolean): True if debug information should be shown</p> Source code in <code>lodstorage/sql.py</code> <pre><code>class EntityInfo(object):\n    \"\"\"\n    holds entity meta Info\n\n    :ivar name(string): entity name = table name\n\n    :ivar primaryKey(string): the name of the primary key column\n\n    :ivar typeMap(dict): maps column names to python types\n\n    :ivar debug(boolean): True if debug information should be shown\n\n    \"\"\"\n\n    def __init__(self, sampleRecords, name, primaryKey=None, debug=False):\n        \"\"\"\n        construct me from the given name and primary key\n\n        Args:\n           name(string): the name of the entity\n           primaryKey(string): the name of the primary key column\n           debug(boolean): True if debug information should be shown\n        \"\"\"\n        self.sampleRecords = sampleRecords\n        self.name = name\n        self.primaryKey = primaryKey\n        self.debug = debug\n        self.typeMap = {}\n        self.sqlTypeMap = {}\n        self.createTableCmd = self.getCreateTableCmd(sampleRecords)\n        self.dropTableCmd = \"DROP TABLE IF EXISTS %s\" % self.name\n        self.insertCmd = self.getInsertCmd()\n\n    def getCreateTableCmd(self, sampleRecords):\n        \"\"\"\n        get the CREATE TABLE DDL command for the given sample records\n\n        Args:\n            sampleRecords(list): a list of Dicts of sample Records\n\n        Returns:\n            string: CREATE TABLE DDL command for this entity info\n\n        Example:\n\n        .. code-block:: sql\n\n            CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n\n        \"\"\"\n        ddlCmd = \"CREATE TABLE %s(\" % self.name\n        delim = \"\"\n        for sampleRecord in sampleRecords:\n            for key, value in sampleRecord.items():\n                sqlType = None\n                valueType = None\n                if value is None:\n                    if len(sampleRecords) == 1:\n                        print(\n                            \"Warning sampleRecord column %s is None - using TEXT as type\"\n                            % key\n                        )\n                        valueType = str\n                else:\n                    valueType = type(value)\n                if valueType == str:\n                    sqlType = \"TEXT\"\n                elif valueType == int:\n                    sqlType = \"INTEGER\"\n                elif valueType == float:\n                    sqlType = \"FLOAT\"\n                elif valueType == bool:\n                    sqlType = \"BOOLEAN\"\n                elif valueType == datetime.date:\n                    sqlType = \"DATE\"\n                elif valueType == datetime.datetime:\n                    sqlType = \"TIMESTAMP\"\n                else:\n                    if valueType is not None:\n                        msg = \"warning: unsupported type %s for column %s \" % (\n                            str(valueType),\n                            key,\n                        )\n                        print(msg)\n                if sqlType is not None and valueType is not None:\n                    self.addType(key, valueType, sqlType)\n        for key, sqlType in self.sqlTypeMap.items():\n            ddlCmd += \"%s%s %s%s\" % (\n                delim,\n                key,\n                sqlType,\n                \" PRIMARY KEY\" if key == self.primaryKey else \"\",\n            )\n            delim = \",\"\n        ddlCmd += \")\"\n        if self.debug:\n            print(ddlCmd)\n        return ddlCmd\n\n    def getInsertCmd(self, replace: bool = False) -&gt; str:\n        \"\"\"\n        get the INSERT command for this entityInfo\n\n        Args:\n             replace(bool): if True allow replace for insert\n\n        Returns:\n            str: the INSERT INTO SQL command for his entityInfo e.g.\n\n        Example:\n\n        .. code-block:: sql\n\n            INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n\n        \"\"\"\n        columns = \",\".join(self.typeMap.keys())\n        placeholders = \":\" + \",:\".join(self.typeMap.keys())\n        replaceClause = \" OR REPLACE\" if replace else \"\"\n        insertCmd = f\"INSERT{replaceClause} INTO {self.name} ({columns}) values ({placeholders})\"\n        if self.debug:\n            print(insertCmd)\n        return insertCmd\n\n    def addType(self, column, valueType, sqlType):\n        \"\"\"\n        add the python type for the given column to the typeMap\n\n        Args:\n           column(string): the name of the column\n\n           valueType(type): the python type of the column\n        \"\"\"\n        if not column in self.typeMap:\n            self.typeMap[column] = valueType\n            self.sqlTypeMap[column] = sqlType\n\n    def fixDates(self, resultList):\n        \"\"\"\n        fix date entries in the given resultList by parsing the date content e.g.\n        converting '1926-04-21' back to datetime.date(1926, 4, 21)\n\n        Args:\n            resultList(list): the list of records to be fixed\n        \"\"\"\n        for record in resultList:\n            for key, valueType in self.typeMap.items():\n                if valueType == datetime.date:\n                    dt = datetime.datetime.strptime(record[key], \"%Y-%m-%d\")\n                    dateValue = dt.date()\n                    record[key] = dateValue\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.__init__","title":"<code>__init__(sampleRecords, name, primaryKey=None, debug=False)</code>","text":"<p>construct me from the given name and primary key</p> <p>Parameters:</p> Name Type Description Default <code>name(string)</code> <p>the name of the entity</p> required <code>primaryKey(string)</code> <p>the name of the primary key column</p> required <code>debug(boolean)</code> <p>True if debug information should be shown</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def __init__(self, sampleRecords, name, primaryKey=None, debug=False):\n    \"\"\"\n    construct me from the given name and primary key\n\n    Args:\n       name(string): the name of the entity\n       primaryKey(string): the name of the primary key column\n       debug(boolean): True if debug information should be shown\n    \"\"\"\n    self.sampleRecords = sampleRecords\n    self.name = name\n    self.primaryKey = primaryKey\n    self.debug = debug\n    self.typeMap = {}\n    self.sqlTypeMap = {}\n    self.createTableCmd = self.getCreateTableCmd(sampleRecords)\n    self.dropTableCmd = \"DROP TABLE IF EXISTS %s\" % self.name\n    self.insertCmd = self.getInsertCmd()\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.addType","title":"<code>addType(column, valueType, sqlType)</code>","text":"<p>add the python type for the given column to the typeMap</p> <p>Parameters:</p> Name Type Description Default <code>column(string)</code> <p>the name of the column</p> required <code>valueType(type)</code> <p>the python type of the column</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def addType(self, column, valueType, sqlType):\n    \"\"\"\n    add the python type for the given column to the typeMap\n\n    Args:\n       column(string): the name of the column\n\n       valueType(type): the python type of the column\n    \"\"\"\n    if not column in self.typeMap:\n        self.typeMap[column] = valueType\n        self.sqlTypeMap[column] = sqlType\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.fixDates","title":"<code>fixDates(resultList)</code>","text":"<p>fix date entries in the given resultList by parsing the date content e.g. converting '1926-04-21' back to datetime.date(1926, 4, 21)</p> <p>Parameters:</p> Name Type Description Default <code>resultList(list)</code> <p>the list of records to be fixed</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def fixDates(self, resultList):\n    \"\"\"\n    fix date entries in the given resultList by parsing the date content e.g.\n    converting '1926-04-21' back to datetime.date(1926, 4, 21)\n\n    Args:\n        resultList(list): the list of records to be fixed\n    \"\"\"\n    for record in resultList:\n        for key, valueType in self.typeMap.items():\n            if valueType == datetime.date:\n                dt = datetime.datetime.strptime(record[key], \"%Y-%m-%d\")\n                dateValue = dt.date()\n                record[key] = dateValue\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.getCreateTableCmd","title":"<code>getCreateTableCmd(sampleRecords)</code>","text":"<p>get the CREATE TABLE DDL command for the given sample records</p> <p>Parameters:</p> Name Type Description Default <code>sampleRecords(list)</code> <p>a list of Dicts of sample Records</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>CREATE TABLE DDL command for this entity info</p> <p>Example:</p> <p>.. code-block:: sql</p> <pre><code>CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n</code></pre> Source code in <code>lodstorage/sql.py</code> <pre><code>def getCreateTableCmd(self, sampleRecords):\n    \"\"\"\n    get the CREATE TABLE DDL command for the given sample records\n\n    Args:\n        sampleRecords(list): a list of Dicts of sample Records\n\n    Returns:\n        string: CREATE TABLE DDL command for this entity info\n\n    Example:\n\n    .. code-block:: sql\n\n        CREATE TABLE Person(name TEXT PRIMARY KEY,born DATE,numberInLine INTEGER,wikidataurl TEXT,age FLOAT,ofAge BOOLEAN)\n\n    \"\"\"\n    ddlCmd = \"CREATE TABLE %s(\" % self.name\n    delim = \"\"\n    for sampleRecord in sampleRecords:\n        for key, value in sampleRecord.items():\n            sqlType = None\n            valueType = None\n            if value is None:\n                if len(sampleRecords) == 1:\n                    print(\n                        \"Warning sampleRecord column %s is None - using TEXT as type\"\n                        % key\n                    )\n                    valueType = str\n            else:\n                valueType = type(value)\n            if valueType == str:\n                sqlType = \"TEXT\"\n            elif valueType == int:\n                sqlType = \"INTEGER\"\n            elif valueType == float:\n                sqlType = \"FLOAT\"\n            elif valueType == bool:\n                sqlType = \"BOOLEAN\"\n            elif valueType == datetime.date:\n                sqlType = \"DATE\"\n            elif valueType == datetime.datetime:\n                sqlType = \"TIMESTAMP\"\n            else:\n                if valueType is not None:\n                    msg = \"warning: unsupported type %s for column %s \" % (\n                        str(valueType),\n                        key,\n                    )\n                    print(msg)\n            if sqlType is not None and valueType is not None:\n                self.addType(key, valueType, sqlType)\n    for key, sqlType in self.sqlTypeMap.items():\n        ddlCmd += \"%s%s %s%s\" % (\n            delim,\n            key,\n            sqlType,\n            \" PRIMARY KEY\" if key == self.primaryKey else \"\",\n        )\n        delim = \",\"\n    ddlCmd += \")\"\n    if self.debug:\n        print(ddlCmd)\n    return ddlCmd\n</code></pre>"},{"location":"#lodstorage.sql.EntityInfo.getInsertCmd","title":"<code>getInsertCmd(replace=False)</code>","text":"<p>get the INSERT command for this entityInfo</p> <p>Parameters:</p> Name Type Description Default <code>replace(bool)</code> <p>if True allow replace for insert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the INSERT INTO SQL command for his entityInfo e.g.</p> <p>Example:</p> <p>.. code-block:: sql</p> <pre><code>INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n</code></pre> Source code in <code>lodstorage/sql.py</code> <pre><code>def getInsertCmd(self, replace: bool = False) -&gt; str:\n    \"\"\"\n    get the INSERT command for this entityInfo\n\n    Args:\n         replace(bool): if True allow replace for insert\n\n    Returns:\n        str: the INSERT INTO SQL command for his entityInfo e.g.\n\n    Example:\n\n    .. code-block:: sql\n\n        INSERT INTO Person (name,born,numberInLine,wikidataurl,age,ofAge) values (?,?,?,?,?,?).\n\n    \"\"\"\n    columns = \",\".join(self.typeMap.keys())\n    placeholders = \":\" + \",:\".join(self.typeMap.keys())\n    replaceClause = \" OR REPLACE\" if replace else \"\"\n    insertCmd = f\"INSERT{replaceClause} INTO {self.name} ({columns}) values ({placeholders})\"\n    if self.debug:\n        print(insertCmd)\n    return insertCmd\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB","title":"<code>SQLDB</code>","text":"<p>               Bases: <code>object</code></p> <p>Structured Query Language Database wrapper</p> <p>:ivar dbname(string): name of the database :ivar debug(boolean): True if debug info should be provided :ivar errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> Source code in <code>lodstorage/sql.py</code> <pre><code>class SQLDB(object):\n    \"\"\"\n    Structured Query Language Database wrapper\n\n    :ivar dbname(string): name of the database\n    :ivar debug(boolean): True if debug info should be provided\n    :ivar errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n\n    RAM = \":memory:\"\n\n    def __init__(\n        self,\n        dbname: str = \":memory:\",\n        connection=None,\n        check_same_thread=True,\n        timeout=5,\n        debug=False,\n        errorDebug=False,\n    ):\n        \"\"\"\n        Construct me for the given dbname and debug\n\n        Args:\n\n           dbname(string): name of the database - default is a RAM based database\n           connection(Connection): an optional connection to be reused\n           check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139\n           timeout(float): number of seconds for connection timeout\n           debug(boolean): if True switch on debug\n           errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n        \"\"\"\n        self.dbname = dbname\n        self.debug = debug\n        self.errorDebug = errorDebug\n        if connection is None:\n            self.c = sqlite3.connect(\n                dbname,\n                detect_types=sqlite3.PARSE_DECLTYPES,\n                check_same_thread=check_same_thread,\n                timeout=timeout,\n            )\n        else:\n            self.c = connection\n\n    def logError(self, msg):\n        \"\"\"\n        log the given error message to stderr\n\n        Args:\n            msg(str): the error messsage to display\n        \"\"\"\n        print(msg, file=sys.stderr, flush=True)\n\n    def close(self):\n        \"\"\"close my connection\"\"\"\n        self.c.close()\n\n    def execute(self, ddlCmd):\n        \"\"\"\n        execute the given Data Definition Command\n\n        Args:\n            ddlCmd(string): e.g. a CREATE TABLE or CREATE View command\n        \"\"\"\n        self.c.execute(ddlCmd)\n\n    def createTable4EntityInfo(self, entityInfo, withDrop=False, withCreate=True):\n        \"\"\"\n        Create a table based on the provided EntityInfo.\n\n        Args:\n            entityInfo (EntityInfo): The EntityInfo object containing table metadata.\n            withDrop (bool): If True, drop the existing table before creation.\n            withCreate (bool): If True, execute the CREATE TABLE command.\n\n        Returns:\n            EntityInfo: The provided EntityInfo object.\n        \"\"\"\n        if withDrop:\n            self.c.execute(entityInfo.dropTableCmd)\n        if withCreate:\n            try:\n                self.c.execute(entityInfo.createTableCmd)\n            except sqlite3.OperationalError as oe:\n                raise Exception(\n                    f\"createTable failed with error {oe} for {entityInfo.createTableCmd}\"\n                )\n        return entityInfo\n\n    def createTable(\n        self,\n        listOfRecords,\n        entityName: str,\n        primaryKey: str = None,\n        withCreate: bool = True,\n        withDrop: bool = False,\n        sampleRecordCount=1,\n        failIfTooFew=True,\n    ):\n        \"\"\"\n        Derive Data Definition Language CREATE TABLE command from list of Records by examining first record\n        as defining sample record and execute DDL command.\n\n        Args:\n            listOfRecords (list): A list of Dicts.\n            entityName (str): The entity / table name to use.\n            primaryKey (str): The key/column to use as a primary key.\n            withDrop (bool): True if the existing Table should be dropped.\n            withCreate (bool): True if the create Table command should be executed.\n            sampleRecordCount (int): Number of sample records expected and to be inspected.\n            failIfTooFew (bool): Raise an Exception if too few sample records, else warn only.\n\n        Returns:\n            EntityInfo: Meta data information for the created table.\n        \"\"\"\n        l = len(listOfRecords)\n        if sampleRecordCount &lt; 0:\n            sampleRecordCount = l\n        if l &lt; sampleRecordCount:\n            msg = f\"only {l}/{sampleRecordCount} of needed sample records to createTable available\"\n            if failIfTooFew:\n                raise Exception(msg)\n            elif self.debug:\n                self.logError(msg)\n\n        sampleRecords = listOfRecords[:sampleRecordCount]\n        entityInfo = EntityInfo(sampleRecords, entityName, primaryKey, debug=self.debug)\n\n        return self.createTable4EntityInfo(entityInfo, withDrop, withCreate)\n\n    def getDebugInfo(self, record, index, executeMany):\n        \"\"\"\n        get the debug info for the given record at the given index depending on the state of executeMany\n\n        Args:\n            record(dict): the record to show\n            index(int): the index of the record\n            executeMany(boolean): if True the record may be valid else not\n        \"\"\"\n        debugInfo = \"\"\n        if not executeMany:\n            # shall we shoe the details of the record (which might be a security risk)\n            if self.errorDebug:\n                # show details of record\n                debugInfo = \"\\nrecord  #%d=%s\" % (index, repr(record))\n            else:\n                # show only index\n                debugInfo = \"\\nrecord #%d\" % index\n        return debugInfo\n\n    def store(\n        self, listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False\n    ):\n        \"\"\"\n        store the given list of records based on the given entityInfo\n\n        Args:\n\n           listOfRecords(list): the list of Dicts to be stored\n           entityInfo(EntityInfo): the meta data to be used for storing\n           executeMany(bool): if True the insert command is done with many/all records at once\n           fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values\n           replace(bool): if True allow replace for insert\n        \"\"\"\n        insertCmd = entityInfo.getInsertCmd(replace=replace)\n        record = None\n        index = 0\n        try:\n            if executeMany:\n                if fixNone:\n                    LOD.setNone4List(listOfRecords, entityInfo.typeMap.keys())\n                self.c.executemany(insertCmd, listOfRecords)\n            else:\n                for record in listOfRecords:\n                    index += 1\n                    if fixNone:\n                        LOD.setNone(record, entityInfo.typeMap.keys())\n                    self.c.execute(insertCmd, record)\n            self.c.commit()\n        except sqlite3.ProgrammingError as pe:\n            msg = pe.args[0]\n            if \"You did not supply a value for binding\" in msg:\n                if \":\" in msg:\n                    # sqlite now returns the parameter name not the number\n                    # You did not supply a value for binding parameter :type.\n                    columnName = re.findall(r\":([a-zA-Z][a-zA-Z0-9_]*)\", msg)[0]\n                    columnName = columnName.replace(\":\", \"\")\n                else:\n                    # pre python 3.10\n                    # You did not supply a value for binding 2.\n                    columnIndex = int(re.findall(r\"\\d+\", msg)[0])\n                    columnName = list(entityInfo.typeMap.keys())[columnIndex - 1]\n                debugInfo = self.getDebugInfo(record, index, executeMany)\n                raise Exception(\n                    \"%s\\nfailed: no value supplied for column '%s'%s\"\n                    % (insertCmd, columnName, debugInfo)\n                )\n            else:\n                raise pe\n        except sqlite3.InterfaceError as ie:\n            msg = ie.args[0]\n            if \"Error binding parameter\" in msg:\n                columnName = re.findall(r\":[_a-zA-Z]\\w*\", msg)[0]\n                debugInfo = self.getDebugInfo(record, index, executeMany)\n                raise Exception(\n                    \"%s\\nfailed: error binding column '%s'%s\"\n                    % (insertCmd, columnName, debugInfo)\n                )\n            else:\n                raise ie\n        except Exception as ex:\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            msg = \"%s\\nfailed:%s%s\" % (insertCmd, str(ex), debugInfo)\n            raise Exception(msg)\n\n    def queryGen(self, sqlQuery, params=None):\n        \"\"\"\n        run the given sqlQuery a a generator for dicts\n\n        Args:\n\n            sqlQuery(string): the SQL query to be executed\n            params(tuple): the query params, if any\n\n        Returns:\n            a generator of dicts\n        \"\"\"\n        if self.debug:\n            print(sqlQuery)\n            if params is not None:\n                print(params)\n        # https://stackoverflow.com/a/13735506/1497139\n        cur = self.c.cursor()\n        if params is not None:\n            query = cur.execute(sqlQuery, params)\n        else:\n            query = cur.execute(sqlQuery)\n        colname = [d[0] for d in query.description]\n        try:\n            # loop over all rows\n            for row in query:\n                record = dict(zip(colname, row))\n                yield record\n        except Exception as ex:\n            msg = str(ex)\n            self.logError(msg)\n            pass\n        cur.close()\n\n    def query(self, sqlQuery, params=None):\n        \"\"\"\n        run the given sqlQuery and return a list of Dicts\n\n        Args:\n\n            sqlQuery(string): the SQL query to be executed\n            params(tuple): the query params, if any\n\n        Returns:\n            list: a list of Dicts\n        \"\"\"\n        resultList = []\n        for record in self.queryGen(sqlQuery, params):\n            resultList.append(record)\n        return resultList\n\n    def queryAll(self, entityInfo, fixDates=True):\n        \"\"\"\n        query all records for the given entityName/tableName\n\n        Args:\n           entityName(string): name of the entity/table to qury\n           fixDates(boolean): True if date entries should be returned as such and not as strings\n        \"\"\"\n        sqlQuery = \"SELECT * FROM %s\" % entityInfo.name\n        resultList = self.query(sqlQuery)\n        if fixDates:\n            entityInfo.fixDates(resultList)\n        return resultList\n\n    def getTableList(self, tableType=\"table\"):\n        \"\"\"\n        get the schema information from this database\n\n        Args:\n            tableType(str): table or view\n\n        Return:\n            list: a list as derived from PRAGMA table_info\n        \"\"\"\n        tableQuery = f\"SELECT name FROM sqlite_master WHERE type='{tableType}'\"\n        tableList = self.query(tableQuery)\n        for table in tableList:\n            tableName = table[\"name\"]\n            columnQuery = f\"PRAGMA table_info('{tableName}')\"\n            columns = self.query(columnQuery)\n            table[\"columns\"] = columns\n        return tableList\n\n    def getTableDict(self, tableType=\"table\"):\n        \"\"\"\n        get the schema information from this database as a dict\n\n        Args:\n            tableType(str): table or view\n\n        Returns:\n            dict: Lookup map of tables with columns also being converted to dict\n        \"\"\"\n        tableDict = {}\n        for table in self.getTableList(tableType=tableType):\n            colDict = {}\n            for col in table[\"columns\"]:\n                colDict[col[\"name\"]] = col\n            table[\"columns\"] = colDict\n            tableDict[table[\"name\"]] = table\n        return tableDict\n\n    def restoreProgress(self, status, remaining, total):\n        self.progress(\"Restore\", status, remaining, total)\n\n    def backupProgress(self, status, remaining, total):\n        self.progress(\"Backup\", status, remaining, total)\n\n    def progress(self, action, status, remaining, total):\n        \"\"\"\n        show progress\n        \"\"\"\n        print(\n            \"%s %s at %5.0f%%\"\n            % (\n                action,\n                \"... \" if status == 0 else \"done\",\n                (total - remaining) / total * 100,\n            )\n        )\n\n    def backup(\n        self,\n        backupDB,\n        action=\"Backup\",\n        profile=False,\n        showProgress: int = 200,\n        doClose=True,\n    ):\n        \"\"\"\n        create backup of this SQLDB to the given backup db\n\n        see https://stackoverflow.com/a/59042442/1497139\n\n        Args:\n            backupDB(string): the path to the backupdb or SQLDB.RAM for in memory\n            action(string): the action to display\n            profile(boolean): True if timing information shall be shown\n            showProgress(int): show progress at each showProgress page (0=show no progress)\n        \"\"\"\n        if sys.version_info &lt;= (3, 6):\n            raise Exception(\n                \"backup via stdlibrary not available in python &lt;=3.6 use copyToDB instead\"\n            )\n        startTime = time.time()\n        bck = sqlite3.connect(backupDB)\n        if showProgress &gt; 0:\n            if action == \"Restore\":\n                progress = self.restoreProgress\n            else:\n                progress = self.backupProgress\n        else:\n            progress = None\n        with bck:\n            self.c.backup(bck, pages=showProgress, progress=progress)\n        elapsed = time.time() - startTime\n        if profile:\n            print(\"%s to %s took %5.1f s\" % (action, backupDB, elapsed))\n        if doClose:\n            bck.close()\n            return None\n        else:\n            return bck\n\n    def showDump(self, dump, limit=10):\n        \"\"\"\n        show the given dump up to the given limit\n\n        Args:\n            dump(string): the SQL dump to show\n            limit(int): the maximum number of lines to display\n        \"\"\"\n        s = io.StringIO(dump)\n        index = 0\n        for line in s:\n            if index &lt;= limit:\n                print(line)\n                index += 1\n            else:\n                break\n\n    def executeDump(\n        self, connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True\n    ):\n        \"\"\"\n        execute the given dump for the given connection\n\n        Args:\n            connection(Connection): the sqlite3 connection to use\n            dump(string): the SQL commands for the dump\n            title(string): the title of the dump\n            maxErrors(int): maximum number of errors to be tolerated before stopping and doing a rollback\n            profile(boolean): True if profiling information should be shown\n        Returns:\n            a list of errors\n        \"\"\"\n        if self.debug:\n            self.showDump(dump)\n        startTime = time.time()\n        if profile:\n            print(\"dump of %s has size %4.1f MB\" % (title, len(dump) / 1024 / 1024))\n        errors = []\n        index = 0\n        # fixes https://github.com/WolfgangFahl/ProceedingsTitleParser/issues/37\n        for line in dump.split(\";\\n\"):\n            try:\n                connection.execute(line)\n            except sqlite3.OperationalError as soe:\n                msg = \"SQL error %s in line %d:\\n\\t%s\" % (soe, index, line)\n                errors.append(msg)\n                if len(errors) &lt;= errorDisplayLimit:\n                    print(msg)\n                if len(errors) &gt;= maxErrors:\n                    connection.execute(\"ROLLBACK;\")\n                    break\n\n            index = index + 1\n        if profile:\n            print(\n                \"finished executing dump %s with %d lines and %d errors in %5.1f s\"\n                % (title, index, len(errors), time.time() - startTime)\n            )\n        return errors\n\n    def copyTo(self, copyDB, profile=True):\n        \"\"\"\n        copy my content to another database\n\n        Args:\n\n           copyDB(Connection): the target database\n           profile(boolean): if True show profile information\n        \"\"\"\n        startTime = time.time()\n        dump = \"\\n\".join(self.c.iterdump())\n        # cursor.executescript(dump)\n        if profile:\n            print(\n                \"finished getting dump of %s in %5.1f s\"\n                % (self.dbname, time.time() - startTime)\n            )\n        dumpErrors = self.executeDump(copyDB.c, dump, self.dbname, profile=profile)\n        return dumpErrors\n\n    @staticmethod\n    def restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False):\n        \"\"\"\n        restore the restoreDB from the given backup DB\n\n        Args:\n            backupDB(string): path to the backupDB e.g. backup.db\n            restoreDB(string): path to the restoreDB or in Memory SQLDB.RAM\n            profile(boolean): True if timing information should be shown\n            showProgress(int): show progress at each showProgress page (0=show no progress)\n        \"\"\"\n        backupSQLDB = SQLDB(backupDB)\n        connection = backupSQLDB.backup(\n            restoreDB,\n            action=\"Restore\",\n            profile=profile,\n            showProgress=showProgress,\n            doClose=False,\n        )\n        restoreSQLDB = SQLDB(restoreDB, connection=connection, debug=debug)\n        return restoreSQLDB\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.__init__","title":"<code>__init__(dbname=':memory:', connection=None, check_same_thread=True, timeout=5, debug=False, errorDebug=False)</code>","text":"<p>Construct me for the given dbname and debug</p> <p>Args:</p> <p>dbname(string): name of the database - default is a RAM based database    connection(Connection): an optional connection to be reused    check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139    timeout(float): number of seconds for connection timeout    debug(boolean): if True switch on debug    errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def __init__(\n    self,\n    dbname: str = \":memory:\",\n    connection=None,\n    check_same_thread=True,\n    timeout=5,\n    debug=False,\n    errorDebug=False,\n):\n    \"\"\"\n    Construct me for the given dbname and debug\n\n    Args:\n\n       dbname(string): name of the database - default is a RAM based database\n       connection(Connection): an optional connection to be reused\n       check_same_thread(boolean): True if object handling needs to be on the same thread see https://stackoverflow.com/a/48234567/1497139\n       timeout(float): number of seconds for connection timeout\n       debug(boolean): if True switch on debug\n       errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n    self.dbname = dbname\n    self.debug = debug\n    self.errorDebug = errorDebug\n    if connection is None:\n        self.c = sqlite3.connect(\n            dbname,\n            detect_types=sqlite3.PARSE_DECLTYPES,\n            check_same_thread=check_same_thread,\n            timeout=timeout,\n        )\n    else:\n        self.c = connection\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.backup","title":"<code>backup(backupDB, action='Backup', profile=False, showProgress=200, doClose=True)</code>","text":"<p>create backup of this SQLDB to the given backup db</p> <p>see https://stackoverflow.com/a/59042442/1497139</p> <p>Parameters:</p> Name Type Description Default <code>backupDB(string)</code> <p>the path to the backupdb or SQLDB.RAM for in memory</p> required <code>action(string)</code> <p>the action to display</p> required <code>profile(boolean)</code> <p>True if timing information shall be shown</p> required <code>showProgress(int)</code> <p>show progress at each showProgress page (0=show no progress)</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def backup(\n    self,\n    backupDB,\n    action=\"Backup\",\n    profile=False,\n    showProgress: int = 200,\n    doClose=True,\n):\n    \"\"\"\n    create backup of this SQLDB to the given backup db\n\n    see https://stackoverflow.com/a/59042442/1497139\n\n    Args:\n        backupDB(string): the path to the backupdb or SQLDB.RAM for in memory\n        action(string): the action to display\n        profile(boolean): True if timing information shall be shown\n        showProgress(int): show progress at each showProgress page (0=show no progress)\n    \"\"\"\n    if sys.version_info &lt;= (3, 6):\n        raise Exception(\n            \"backup via stdlibrary not available in python &lt;=3.6 use copyToDB instead\"\n        )\n    startTime = time.time()\n    bck = sqlite3.connect(backupDB)\n    if showProgress &gt; 0:\n        if action == \"Restore\":\n            progress = self.restoreProgress\n        else:\n            progress = self.backupProgress\n    else:\n        progress = None\n    with bck:\n        self.c.backup(bck, pages=showProgress, progress=progress)\n    elapsed = time.time() - startTime\n    if profile:\n        print(\"%s to %s took %5.1f s\" % (action, backupDB, elapsed))\n    if doClose:\n        bck.close()\n        return None\n    else:\n        return bck\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.close","title":"<code>close()</code>","text":"<p>close my connection</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def close(self):\n    \"\"\"close my connection\"\"\"\n    self.c.close()\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.copyTo","title":"<code>copyTo(copyDB, profile=True)</code>","text":"<p>copy my content to another database</p> <p>Args:</p> <p>copyDB(Connection): the target database    profile(boolean): if True show profile information</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def copyTo(self, copyDB, profile=True):\n    \"\"\"\n    copy my content to another database\n\n    Args:\n\n       copyDB(Connection): the target database\n       profile(boolean): if True show profile information\n    \"\"\"\n    startTime = time.time()\n    dump = \"\\n\".join(self.c.iterdump())\n    # cursor.executescript(dump)\n    if profile:\n        print(\n            \"finished getting dump of %s in %5.1f s\"\n            % (self.dbname, time.time() - startTime)\n        )\n    dumpErrors = self.executeDump(copyDB.c, dump, self.dbname, profile=profile)\n    return dumpErrors\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.createTable","title":"<code>createTable(listOfRecords, entityName, primaryKey=None, withCreate=True, withDrop=False, sampleRecordCount=1, failIfTooFew=True)</code>","text":"<p>Derive Data Definition Language CREATE TABLE command from list of Records by examining first record as defining sample record and execute DDL command.</p> <p>Parameters:</p> Name Type Description Default <code>listOfRecords</code> <code>list</code> <p>A list of Dicts.</p> required <code>entityName</code> <code>str</code> <p>The entity / table name to use.</p> required <code>primaryKey</code> <code>str</code> <p>The key/column to use as a primary key.</p> <code>None</code> <code>withDrop</code> <code>bool</code> <p>True if the existing Table should be dropped.</p> <code>False</code> <code>withCreate</code> <code>bool</code> <p>True if the create Table command should be executed.</p> <code>True</code> <code>sampleRecordCount</code> <code>int</code> <p>Number of sample records expected and to be inspected.</p> <code>1</code> <code>failIfTooFew</code> <code>bool</code> <p>Raise an Exception if too few sample records, else warn only.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EntityInfo</code> <p>Meta data information for the created table.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def createTable(\n    self,\n    listOfRecords,\n    entityName: str,\n    primaryKey: str = None,\n    withCreate: bool = True,\n    withDrop: bool = False,\n    sampleRecordCount=1,\n    failIfTooFew=True,\n):\n    \"\"\"\n    Derive Data Definition Language CREATE TABLE command from list of Records by examining first record\n    as defining sample record and execute DDL command.\n\n    Args:\n        listOfRecords (list): A list of Dicts.\n        entityName (str): The entity / table name to use.\n        primaryKey (str): The key/column to use as a primary key.\n        withDrop (bool): True if the existing Table should be dropped.\n        withCreate (bool): True if the create Table command should be executed.\n        sampleRecordCount (int): Number of sample records expected and to be inspected.\n        failIfTooFew (bool): Raise an Exception if too few sample records, else warn only.\n\n    Returns:\n        EntityInfo: Meta data information for the created table.\n    \"\"\"\n    l = len(listOfRecords)\n    if sampleRecordCount &lt; 0:\n        sampleRecordCount = l\n    if l &lt; sampleRecordCount:\n        msg = f\"only {l}/{sampleRecordCount} of needed sample records to createTable available\"\n        if failIfTooFew:\n            raise Exception(msg)\n        elif self.debug:\n            self.logError(msg)\n\n    sampleRecords = listOfRecords[:sampleRecordCount]\n    entityInfo = EntityInfo(sampleRecords, entityName, primaryKey, debug=self.debug)\n\n    return self.createTable4EntityInfo(entityInfo, withDrop, withCreate)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.createTable4EntityInfo","title":"<code>createTable4EntityInfo(entityInfo, withDrop=False, withCreate=True)</code>","text":"<p>Create a table based on the provided EntityInfo.</p> <p>Parameters:</p> Name Type Description Default <code>entityInfo</code> <code>EntityInfo</code> <p>The EntityInfo object containing table metadata.</p> required <code>withDrop</code> <code>bool</code> <p>If True, drop the existing table before creation.</p> <code>False</code> <code>withCreate</code> <code>bool</code> <p>If True, execute the CREATE TABLE command.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>EntityInfo</code> <p>The provided EntityInfo object.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def createTable4EntityInfo(self, entityInfo, withDrop=False, withCreate=True):\n    \"\"\"\n    Create a table based on the provided EntityInfo.\n\n    Args:\n        entityInfo (EntityInfo): The EntityInfo object containing table metadata.\n        withDrop (bool): If True, drop the existing table before creation.\n        withCreate (bool): If True, execute the CREATE TABLE command.\n\n    Returns:\n        EntityInfo: The provided EntityInfo object.\n    \"\"\"\n    if withDrop:\n        self.c.execute(entityInfo.dropTableCmd)\n    if withCreate:\n        try:\n            self.c.execute(entityInfo.createTableCmd)\n        except sqlite3.OperationalError as oe:\n            raise Exception(\n                f\"createTable failed with error {oe} for {entityInfo.createTableCmd}\"\n            )\n    return entityInfo\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.execute","title":"<code>execute(ddlCmd)</code>","text":"<p>execute the given Data Definition Command</p> <p>Parameters:</p> Name Type Description Default <code>ddlCmd(string)</code> <p>e.g. a CREATE TABLE or CREATE View command</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def execute(self, ddlCmd):\n    \"\"\"\n    execute the given Data Definition Command\n\n    Args:\n        ddlCmd(string): e.g. a CREATE TABLE or CREATE View command\n    \"\"\"\n    self.c.execute(ddlCmd)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.executeDump","title":"<code>executeDump(connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True)</code>","text":"<p>execute the given dump for the given connection</p> <p>Parameters:</p> Name Type Description Default <code>connection(Connection)</code> <p>the sqlite3 connection to use</p> required <code>dump(string)</code> <p>the SQL commands for the dump</p> required <code>title(string)</code> <p>the title of the dump</p> required <code>maxErrors(int)</code> <p>maximum number of errors to be tolerated before stopping and doing a rollback</p> required <code>profile(boolean)</code> <p>True if profiling information should be shown</p> required <p>Returns:     a list of errors</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def executeDump(\n    self, connection, dump, title, maxErrors=100, errorDisplayLimit=12, profile=True\n):\n    \"\"\"\n    execute the given dump for the given connection\n\n    Args:\n        connection(Connection): the sqlite3 connection to use\n        dump(string): the SQL commands for the dump\n        title(string): the title of the dump\n        maxErrors(int): maximum number of errors to be tolerated before stopping and doing a rollback\n        profile(boolean): True if profiling information should be shown\n    Returns:\n        a list of errors\n    \"\"\"\n    if self.debug:\n        self.showDump(dump)\n    startTime = time.time()\n    if profile:\n        print(\"dump of %s has size %4.1f MB\" % (title, len(dump) / 1024 / 1024))\n    errors = []\n    index = 0\n    # fixes https://github.com/WolfgangFahl/ProceedingsTitleParser/issues/37\n    for line in dump.split(\";\\n\"):\n        try:\n            connection.execute(line)\n        except sqlite3.OperationalError as soe:\n            msg = \"SQL error %s in line %d:\\n\\t%s\" % (soe, index, line)\n            errors.append(msg)\n            if len(errors) &lt;= errorDisplayLimit:\n                print(msg)\n            if len(errors) &gt;= maxErrors:\n                connection.execute(\"ROLLBACK;\")\n                break\n\n        index = index + 1\n    if profile:\n        print(\n            \"finished executing dump %s with %d lines and %d errors in %5.1f s\"\n            % (title, index, len(errors), time.time() - startTime)\n        )\n    return errors\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getDebugInfo","title":"<code>getDebugInfo(record, index, executeMany)</code>","text":"<p>get the debug info for the given record at the given index depending on the state of executeMany</p> <p>Parameters:</p> Name Type Description Default <code>record(dict)</code> <p>the record to show</p> required <code>index(int)</code> <p>the index of the record</p> required <code>executeMany(boolean)</code> <p>if True the record may be valid else not</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def getDebugInfo(self, record, index, executeMany):\n    \"\"\"\n    get the debug info for the given record at the given index depending on the state of executeMany\n\n    Args:\n        record(dict): the record to show\n        index(int): the index of the record\n        executeMany(boolean): if True the record may be valid else not\n    \"\"\"\n    debugInfo = \"\"\n    if not executeMany:\n        # shall we shoe the details of the record (which might be a security risk)\n        if self.errorDebug:\n            # show details of record\n            debugInfo = \"\\nrecord  #%d=%s\" % (index, repr(record))\n        else:\n            # show only index\n            debugInfo = \"\\nrecord #%d\" % index\n    return debugInfo\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getTableDict","title":"<code>getTableDict(tableType='table')</code>","text":"<p>get the schema information from this database as a dict</p> <p>Parameters:</p> Name Type Description Default <code>tableType(str)</code> <p>table or view</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Lookup map of tables with columns also being converted to dict</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def getTableDict(self, tableType=\"table\"):\n    \"\"\"\n    get the schema information from this database as a dict\n\n    Args:\n        tableType(str): table or view\n\n    Returns:\n        dict: Lookup map of tables with columns also being converted to dict\n    \"\"\"\n    tableDict = {}\n    for table in self.getTableList(tableType=tableType):\n        colDict = {}\n        for col in table[\"columns\"]:\n            colDict[col[\"name\"]] = col\n        table[\"columns\"] = colDict\n        tableDict[table[\"name\"]] = table\n    return tableDict\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.getTableList","title":"<code>getTableList(tableType='table')</code>","text":"<p>get the schema information from this database</p> <p>Parameters:</p> Name Type Description Default <code>tableType(str)</code> <p>table or view</p> required Return <p>list: a list as derived from PRAGMA table_info</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def getTableList(self, tableType=\"table\"):\n    \"\"\"\n    get the schema information from this database\n\n    Args:\n        tableType(str): table or view\n\n    Return:\n        list: a list as derived from PRAGMA table_info\n    \"\"\"\n    tableQuery = f\"SELECT name FROM sqlite_master WHERE type='{tableType}'\"\n    tableList = self.query(tableQuery)\n    for table in tableList:\n        tableName = table[\"name\"]\n        columnQuery = f\"PRAGMA table_info('{tableName}')\"\n        columns = self.query(columnQuery)\n        table[\"columns\"] = columns\n    return tableList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.logError","title":"<code>logError(msg)</code>","text":"<p>log the given error message to stderr</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the error messsage to display</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def logError(self, msg):\n    \"\"\"\n    log the given error message to stderr\n\n    Args:\n        msg(str): the error messsage to display\n    \"\"\"\n    print(msg, file=sys.stderr, flush=True)\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.progress","title":"<code>progress(action, status, remaining, total)</code>","text":"<p>show progress</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def progress(self, action, status, remaining, total):\n    \"\"\"\n    show progress\n    \"\"\"\n    print(\n        \"%s %s at %5.0f%%\"\n        % (\n            action,\n            \"... \" if status == 0 else \"done\",\n            (total - remaining) / total * 100,\n        )\n    )\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.query","title":"<code>query(sqlQuery, params=None)</code>","text":"<p>run the given sqlQuery and return a list of Dicts</p> <p>Args:</p> <pre><code>sqlQuery(string): the SQL query to be executed\nparams(tuple): the query params, if any\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <p>a list of Dicts</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def query(self, sqlQuery, params=None):\n    \"\"\"\n    run the given sqlQuery and return a list of Dicts\n\n    Args:\n\n        sqlQuery(string): the SQL query to be executed\n        params(tuple): the query params, if any\n\n    Returns:\n        list: a list of Dicts\n    \"\"\"\n    resultList = []\n    for record in self.queryGen(sqlQuery, params):\n        resultList.append(record)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.queryAll","title":"<code>queryAll(entityInfo, fixDates=True)</code>","text":"<p>query all records for the given entityName/tableName</p> <p>Parameters:</p> Name Type Description Default <code>entityName(string)</code> <p>name of the entity/table to qury</p> required <code>fixDates(boolean)</code> <p>True if date entries should be returned as such and not as strings</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def queryAll(self, entityInfo, fixDates=True):\n    \"\"\"\n    query all records for the given entityName/tableName\n\n    Args:\n       entityName(string): name of the entity/table to qury\n       fixDates(boolean): True if date entries should be returned as such and not as strings\n    \"\"\"\n    sqlQuery = \"SELECT * FROM %s\" % entityInfo.name\n    resultList = self.query(sqlQuery)\n    if fixDates:\n        entityInfo.fixDates(resultList)\n    return resultList\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.queryGen","title":"<code>queryGen(sqlQuery, params=None)</code>","text":"<p>run the given sqlQuery a a generator for dicts</p> <p>Args:</p> <pre><code>sqlQuery(string): the SQL query to be executed\nparams(tuple): the query params, if any\n</code></pre> <p>Returns:</p> Type Description <p>a generator of dicts</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def queryGen(self, sqlQuery, params=None):\n    \"\"\"\n    run the given sqlQuery a a generator for dicts\n\n    Args:\n\n        sqlQuery(string): the SQL query to be executed\n        params(tuple): the query params, if any\n\n    Returns:\n        a generator of dicts\n    \"\"\"\n    if self.debug:\n        print(sqlQuery)\n        if params is not None:\n            print(params)\n    # https://stackoverflow.com/a/13735506/1497139\n    cur = self.c.cursor()\n    if params is not None:\n        query = cur.execute(sqlQuery, params)\n    else:\n        query = cur.execute(sqlQuery)\n    colname = [d[0] for d in query.description]\n    try:\n        # loop over all rows\n        for row in query:\n            record = dict(zip(colname, row))\n            yield record\n    except Exception as ex:\n        msg = str(ex)\n        self.logError(msg)\n        pass\n    cur.close()\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.restore","title":"<code>restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False)</code>  <code>staticmethod</code>","text":"<p>restore the restoreDB from the given backup DB</p> <p>Parameters:</p> Name Type Description Default <code>backupDB(string)</code> <p>path to the backupDB e.g. backup.db</p> required <code>restoreDB(string)</code> <p>path to the restoreDB or in Memory SQLDB.RAM</p> required <code>profile(boolean)</code> <p>True if timing information should be shown</p> required <code>showProgress(int)</code> <p>show progress at each showProgress page (0=show no progress)</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>@staticmethod\ndef restore(backupDB, restoreDB, profile=False, showProgress=200, debug=False):\n    \"\"\"\n    restore the restoreDB from the given backup DB\n\n    Args:\n        backupDB(string): path to the backupDB e.g. backup.db\n        restoreDB(string): path to the restoreDB or in Memory SQLDB.RAM\n        profile(boolean): True if timing information should be shown\n        showProgress(int): show progress at each showProgress page (0=show no progress)\n    \"\"\"\n    backupSQLDB = SQLDB(backupDB)\n    connection = backupSQLDB.backup(\n        restoreDB,\n        action=\"Restore\",\n        profile=profile,\n        showProgress=showProgress,\n        doClose=False,\n    )\n    restoreSQLDB = SQLDB(restoreDB, connection=connection, debug=debug)\n    return restoreSQLDB\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.showDump","title":"<code>showDump(dump, limit=10)</code>","text":"<p>show the given dump up to the given limit</p> <p>Parameters:</p> Name Type Description Default <code>dump(string)</code> <p>the SQL dump to show</p> required <code>limit(int)</code> <p>the maximum number of lines to display</p> required Source code in <code>lodstorage/sql.py</code> <pre><code>def showDump(self, dump, limit=10):\n    \"\"\"\n    show the given dump up to the given limit\n\n    Args:\n        dump(string): the SQL dump to show\n        limit(int): the maximum number of lines to display\n    \"\"\"\n    s = io.StringIO(dump)\n    index = 0\n    for line in s:\n        if index &lt;= limit:\n            print(line)\n            index += 1\n        else:\n            break\n</code></pre>"},{"location":"#lodstorage.sql.SQLDB.store","title":"<code>store(listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False)</code>","text":"<p>store the given list of records based on the given entityInfo</p> <p>Args:</p> <p>listOfRecords(list): the list of Dicts to be stored    entityInfo(EntityInfo): the meta data to be used for storing    executeMany(bool): if True the insert command is done with many/all records at once    fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values    replace(bool): if True allow replace for insert</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def store(\n    self, listOfRecords, entityInfo, executeMany=False, fixNone=False, replace=False\n):\n    \"\"\"\n    store the given list of records based on the given entityInfo\n\n    Args:\n\n       listOfRecords(list): the list of Dicts to be stored\n       entityInfo(EntityInfo): the meta data to be used for storing\n       executeMany(bool): if True the insert command is done with many/all records at once\n       fixNone(bool): if True make sure empty columns in the listOfDict are filled with \"None\" values\n       replace(bool): if True allow replace for insert\n    \"\"\"\n    insertCmd = entityInfo.getInsertCmd(replace=replace)\n    record = None\n    index = 0\n    try:\n        if executeMany:\n            if fixNone:\n                LOD.setNone4List(listOfRecords, entityInfo.typeMap.keys())\n            self.c.executemany(insertCmd, listOfRecords)\n        else:\n            for record in listOfRecords:\n                index += 1\n                if fixNone:\n                    LOD.setNone(record, entityInfo.typeMap.keys())\n                self.c.execute(insertCmd, record)\n        self.c.commit()\n    except sqlite3.ProgrammingError as pe:\n        msg = pe.args[0]\n        if \"You did not supply a value for binding\" in msg:\n            if \":\" in msg:\n                # sqlite now returns the parameter name not the number\n                # You did not supply a value for binding parameter :type.\n                columnName = re.findall(r\":([a-zA-Z][a-zA-Z0-9_]*)\", msg)[0]\n                columnName = columnName.replace(\":\", \"\")\n            else:\n                # pre python 3.10\n                # You did not supply a value for binding 2.\n                columnIndex = int(re.findall(r\"\\d+\", msg)[0])\n                columnName = list(entityInfo.typeMap.keys())[columnIndex - 1]\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            raise Exception(\n                \"%s\\nfailed: no value supplied for column '%s'%s\"\n                % (insertCmd, columnName, debugInfo)\n            )\n        else:\n            raise pe\n    except sqlite3.InterfaceError as ie:\n        msg = ie.args[0]\n        if \"Error binding parameter\" in msg:\n            columnName = re.findall(r\":[_a-zA-Z]\\w*\", msg)[0]\n            debugInfo = self.getDebugInfo(record, index, executeMany)\n            raise Exception(\n                \"%s\\nfailed: error binding column '%s'%s\"\n                % (insertCmd, columnName, debugInfo)\n            )\n        else:\n            raise ie\n    except Exception as ex:\n        debugInfo = self.getDebugInfo(record, index, executeMany)\n        msg = \"%s\\nfailed:%s%s\" % (insertCmd, str(ex), debugInfo)\n        raise Exception(msg)\n</code></pre>"},{"location":"#lodstorage.sql.adapt_boolean","title":"<code>adapt_boolean(val)</code>","text":"<p>Adapt boolean to int</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def adapt_boolean(val: bool):\n    \"\"\"Adapt boolean to int\"\"\"\n    return 1 if val else 0\n</code></pre>"},{"location":"#lodstorage.sql.adapt_date_iso","title":"<code>adapt_date_iso(val)</code>","text":"<p>Adapt datetime.date to ISO 8601 date.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def adapt_date_iso(val: datetime.date):\n    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n    return val.isoformat()\n</code></pre>"},{"location":"#lodstorage.sql.adapt_datetime_epoch","title":"<code>adapt_datetime_epoch(val)</code>","text":"<p>Adapt datetime.datetime to Unix timestamp.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def adapt_datetime_epoch(val: datetime.datetime):\n    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n    return float(val.timestamp()) * 10**6\n</code></pre>"},{"location":"#lodstorage.sql.adapt_datetime_iso","title":"<code>adapt_datetime_iso(val)</code>","text":"<p>Adapt datetime.datetime to timezone-naive ISO 8601 date.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def adapt_datetime_iso(val: datetime.datetime):\n    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n    return val.isoformat()\n</code></pre>"},{"location":"#lodstorage.sql.convert_boolean","title":"<code>convert_boolean(val)</code>","text":"<p>Convert 0 or 1 to boolean</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_boolean(val: bytes):\n    \"\"\"\n    Convert 0 or 1 to boolean\n    \"\"\"\n    return True if int(val) == 1 else False\n</code></pre>"},{"location":"#lodstorage.sql.convert_date","title":"<code>convert_date(val)</code>","text":"<p>Convert byte string to date using the DatetimeAdapter.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_date(val: bytes) -&gt; datetime.date:\n    \"\"\"Convert byte string to date using the DatetimeAdapter.\"\"\"\n    adapter = DatetimeAdapter()\n    return adapter.convert_date(val)\n</code></pre>"},{"location":"#lodstorage.sql.convert_datetime","title":"<code>convert_datetime(val)</code>","text":"<p>Convert byte string to datetime using the DatetimeAdapter.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_datetime(val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert byte string to datetime using the DatetimeAdapter.\"\"\"\n    adapter = DatetimeAdapter()\n    return adapter.convert_datetime(val)\n</code></pre>"},{"location":"#lodstorage.sql.convert_timestamp","title":"<code>convert_timestamp(val)</code>","text":"<p>Convert byte string to timestamp using the DatetimeAdapter.</p> Source code in <code>lodstorage/sql.py</code> <pre><code>def convert_timestamp(val: bytes) -&gt; datetime.datetime:\n    \"\"\"Convert byte string to timestamp using the DatetimeAdapter.\"\"\"\n    adapter = DatetimeAdapter()\n    return adapter.convert_timestamp(val)\n</code></pre>"},{"location":"#lodstorage.sql_cache","title":"<code>sql_cache</code>","text":"<p>Created on 2024-03-16</p> <p>@author: wf</p>"},{"location":"#lodstorage.sql_cache.Cached","title":"<code>Cached</code>","text":"<p>Manage cached entities.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>class Cached:\n    \"\"\"\n    Manage cached entities.\n    \"\"\"\n\n    def __init__(\n        self,\n        clazz: Type[Any],\n        sparql: SPARQL,\n        sql_db: str,\n        query_name: str,\n        max_errors: int = 0,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initializes the Manager with class reference, SPARQL endpoint URL, SQL database connection string,\n        query name, and an optional debug flag.\n\n        Args:\n            clazz (Type[Any]): The class reference for the type of objects managed by this manager.\n            sparql (SPARQL): a SPARQL endpoint.\n            sql_db (str): The connection string for the SQL database.\n            query_name (str): The name of the query to be executed.\n            debug (bool, optional): Flag to enable debug mode. Defaults to False.\n        \"\"\"\n        self.clazz = clazz\n        self.sparql = sparql\n        self.sql_db = sql_db\n        self.query_name = query_name\n        self.max_errors = max_errors\n        self.debug = debug\n        self.entities = []\n        self.errors = []\n        self.fetched = False\n        # Ensure the table for the class exists\n        clazz.metadata.create_all(self.sql_db.engine)\n\n    def fetch_or_query(self, qm, force_query=False) -&gt; List[Dict]:\n        \"\"\"\n        Fetches data from the local cache if available.\n        If the data is not in the cache or if force_query is True,\n        it queries via SPARQL and caches the results.\n\n        Args:\n            qm (QueryManager): The query manager object used for making SPARQL queries.\n            force_query (bool, optional): A flag to force querying via SPARQL even if the data exists in the local cache. Defaults to False.\n        Returns:\n            List: list of records from the SQL database\n        \"\"\"\n        if not force_query and self.check_local_cache():\n            lod = self.fetch_from_local()\n        else:\n            lod = self.get_lod(qm)\n            self.store()\n        return lod\n\n    def check_local_cache(self) -&gt; bool:\n        \"\"\"\n        Checks if there is data in the local cache (SQL database).\n\n        Returns:\n            bool: True if  there is at least one record in the local SQL cache table\n        \"\"\"\n        with self.sql_db.get_session() as session:\n            result = session.exec(select(self.clazz)).first()\n            return result is not None\n\n    def fetch_from_local(self) -&gt; List[Dict]:\n        \"\"\"\n        Fetches data from the local SQL database as list of dicts and entities.\n\n        Returns:\n            List[Dict]: List of records from the SQL database in dictionary form.\n        \"\"\"\n        profiler = Profiler(f\"fetch {self.query_name} from local\", profile=self.debug)\n        with self.sql_db.get_session() as session:\n            self.entities = session.exec(select(self.clazz)).all()\n            self.lod = [entity.dict() for entity in self.entities]\n            if self.debug:\n                print(f\"Loaded {len(self.entities)} records from local cache\")\n        profiler.time()\n        return self.lod\n\n    def get_lod(self, qm: QueryManager) -&gt; List[Dict]:\n        \"\"\"\n        Fetches data using the SPARQL query specified by my query_name.\n\n        Args:\n            qm (QueryManager): The query manager object used for making SPARQL queries.\n\n        Returns:\n            List[Dict]: A list of dictionaries representing the data fetched.\n        \"\"\"\n        profiler = Profiler(\n            f\"fetch {self.query_name} from SPARQL endpoint {self.sparql.url}\",\n            profile=self.debug,\n        )\n        query = qm.queriesByName[self.query_name]\n        self.lod = self.sparql.queryAsListOfDicts(query.query)\n        profiler.time()\n        if self.debug:\n            print(f\"Found {len(self.lod)} records for {self.query_name}\")\n        return self.lod\n\n    def to_entities(self, max_errors: int = None, cached: bool = True) -&gt; List[Any]:\n        \"\"\"\n        Converts records fetched from the LOD into entity instances, applying validation.\n\n        Args:\n            max_errors (int, optional): Maximum allowed validation errors. Defaults to 0.\n            cached(bool): if True use existing entries\n        Returns:\n            List[Any]: A list of entity instances that have passed validation.\n        \"\"\"\n        if not cached:\n            self.entities = []\n            self.errors = []\n        elif self.fetched:\n            return self.entities\n\n        error_records = []\n        if max_errors is None:\n            max_errors = self.max_errors\n        for record in self.lod:\n            try:\n                entity = self.clazz.model_validate(record)\n                self.entities.append(entity)\n            except Exception as e:\n                self.errors.append(e)\n                error_records.append(record)\n        error_count = len(self.errors)\n        if error_count &gt; max_errors:\n            msg = f\"found {error_count} errors &gt; maximum allowed {max_errors} errors\"\n            if self.debug:\n                print(msg)\n                for i, e in enumerate(self.errors):\n                    print(f\"{i}:{str(e)} for \\n{error_records[i]}\")\n            raise Exception(msg)\n        self.fetched = True\n        return self.entities\n\n    def store(self, max_errors: int = None) -&gt; List[Any]:\n        \"\"\"\n        Stores the fetched data into the local SQL database.\n\n        Args:\n            max_errors (int, optional): Maximum allowed validation errors. Defaults to 0.\n\n        Returns:\n            List[Any]: A list of entity instances that were stored in the database.\n\n        \"\"\"\n        profiler = Profiler(f\"store {self.query_name}\", profile=self.debug)\n        self.to_entities(max_errors=max_errors, cached=False)\n        with self.sql_db.get_session() as session:\n            session.add_all(self.entities)\n            session.commit()\n            if self.debug:\n                print(f\"Stored {len(self.entities)} records in local cache\")\n        profiler.time()\n        return self.entities\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.__init__","title":"<code>__init__(clazz, sparql, sql_db, query_name, max_errors=0, debug=False)</code>","text":"<p>Initializes the Manager with class reference, SPARQL endpoint URL, SQL database connection string, query name, and an optional debug flag.</p> <p>Parameters:</p> Name Type Description Default <code>clazz</code> <code>Type[Any]</code> <p>The class reference for the type of objects managed by this manager.</p> required <code>sparql</code> <code>SPARQL</code> <p>a SPARQL endpoint.</p> required <code>sql_db</code> <code>str</code> <p>The connection string for the SQL database.</p> required <code>query_name</code> <code>str</code> <p>The name of the query to be executed.</p> required <code>debug</code> <code>bool</code> <p>Flag to enable debug mode. Defaults to False.</p> <code>False</code> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def __init__(\n    self,\n    clazz: Type[Any],\n    sparql: SPARQL,\n    sql_db: str,\n    query_name: str,\n    max_errors: int = 0,\n    debug: bool = False,\n):\n    \"\"\"\n    Initializes the Manager with class reference, SPARQL endpoint URL, SQL database connection string,\n    query name, and an optional debug flag.\n\n    Args:\n        clazz (Type[Any]): The class reference for the type of objects managed by this manager.\n        sparql (SPARQL): a SPARQL endpoint.\n        sql_db (str): The connection string for the SQL database.\n        query_name (str): The name of the query to be executed.\n        debug (bool, optional): Flag to enable debug mode. Defaults to False.\n    \"\"\"\n    self.clazz = clazz\n    self.sparql = sparql\n    self.sql_db = sql_db\n    self.query_name = query_name\n    self.max_errors = max_errors\n    self.debug = debug\n    self.entities = []\n    self.errors = []\n    self.fetched = False\n    # Ensure the table for the class exists\n    clazz.metadata.create_all(self.sql_db.engine)\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.check_local_cache","title":"<code>check_local_cache()</code>","text":"<p>Checks if there is data in the local cache (SQL database).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if  there is at least one record in the local SQL cache table</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def check_local_cache(self) -&gt; bool:\n    \"\"\"\n    Checks if there is data in the local cache (SQL database).\n\n    Returns:\n        bool: True if  there is at least one record in the local SQL cache table\n    \"\"\"\n    with self.sql_db.get_session() as session:\n        result = session.exec(select(self.clazz)).first()\n        return result is not None\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.fetch_from_local","title":"<code>fetch_from_local()</code>","text":"<p>Fetches data from the local SQL database as list of dicts and entities.</p> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: List of records from the SQL database in dictionary form.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def fetch_from_local(self) -&gt; List[Dict]:\n    \"\"\"\n    Fetches data from the local SQL database as list of dicts and entities.\n\n    Returns:\n        List[Dict]: List of records from the SQL database in dictionary form.\n    \"\"\"\n    profiler = Profiler(f\"fetch {self.query_name} from local\", profile=self.debug)\n    with self.sql_db.get_session() as session:\n        self.entities = session.exec(select(self.clazz)).all()\n        self.lod = [entity.dict() for entity in self.entities]\n        if self.debug:\n            print(f\"Loaded {len(self.entities)} records from local cache\")\n    profiler.time()\n    return self.lod\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.fetch_or_query","title":"<code>fetch_or_query(qm, force_query=False)</code>","text":"<p>Fetches data from the local cache if available. If the data is not in the cache or if force_query is True, it queries via SPARQL and caches the results.</p> <p>Parameters:</p> Name Type Description Default <code>qm</code> <code>QueryManager</code> <p>The query manager object used for making SPARQL queries.</p> required <code>force_query</code> <code>bool</code> <p>A flag to force querying via SPARQL even if the data exists in the local cache. Defaults to False.</p> <code>False</code> <p>Returns:     List: list of records from the SQL database</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def fetch_or_query(self, qm, force_query=False) -&gt; List[Dict]:\n    \"\"\"\n    Fetches data from the local cache if available.\n    If the data is not in the cache or if force_query is True,\n    it queries via SPARQL and caches the results.\n\n    Args:\n        qm (QueryManager): The query manager object used for making SPARQL queries.\n        force_query (bool, optional): A flag to force querying via SPARQL even if the data exists in the local cache. Defaults to False.\n    Returns:\n        List: list of records from the SQL database\n    \"\"\"\n    if not force_query and self.check_local_cache():\n        lod = self.fetch_from_local()\n    else:\n        lod = self.get_lod(qm)\n        self.store()\n    return lod\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.get_lod","title":"<code>get_lod(qm)</code>","text":"<p>Fetches data using the SPARQL query specified by my query_name.</p> <p>Parameters:</p> Name Type Description Default <code>qm</code> <code>QueryManager</code> <p>The query manager object used for making SPARQL queries.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: A list of dictionaries representing the data fetched.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def get_lod(self, qm: QueryManager) -&gt; List[Dict]:\n    \"\"\"\n    Fetches data using the SPARQL query specified by my query_name.\n\n    Args:\n        qm (QueryManager): The query manager object used for making SPARQL queries.\n\n    Returns:\n        List[Dict]: A list of dictionaries representing the data fetched.\n    \"\"\"\n    profiler = Profiler(\n        f\"fetch {self.query_name} from SPARQL endpoint {self.sparql.url}\",\n        profile=self.debug,\n    )\n    query = qm.queriesByName[self.query_name]\n    self.lod = self.sparql.queryAsListOfDicts(query.query)\n    profiler.time()\n    if self.debug:\n        print(f\"Found {len(self.lod)} records for {self.query_name}\")\n    return self.lod\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.store","title":"<code>store(max_errors=None)</code>","text":"<p>Stores the fetched data into the local SQL database.</p> <p>Parameters:</p> Name Type Description Default <code>max_errors</code> <code>int</code> <p>Maximum allowed validation errors. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: A list of entity instances that were stored in the database.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def store(self, max_errors: int = None) -&gt; List[Any]:\n    \"\"\"\n    Stores the fetched data into the local SQL database.\n\n    Args:\n        max_errors (int, optional): Maximum allowed validation errors. Defaults to 0.\n\n    Returns:\n        List[Any]: A list of entity instances that were stored in the database.\n\n    \"\"\"\n    profiler = Profiler(f\"store {self.query_name}\", profile=self.debug)\n    self.to_entities(max_errors=max_errors, cached=False)\n    with self.sql_db.get_session() as session:\n        session.add_all(self.entities)\n        session.commit()\n        if self.debug:\n            print(f\"Stored {len(self.entities)} records in local cache\")\n    profiler.time()\n    return self.entities\n</code></pre>"},{"location":"#lodstorage.sql_cache.Cached.to_entities","title":"<code>to_entities(max_errors=None, cached=True)</code>","text":"<p>Converts records fetched from the LOD into entity instances, applying validation.</p> <p>Parameters:</p> Name Type Description Default <code>max_errors</code> <code>int</code> <p>Maximum allowed validation errors. Defaults to 0.</p> <code>None</code> <code>cached(bool)</code> <p>if True use existing entries</p> required <p>Returns:     List[Any]: A list of entity instances that have passed validation.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def to_entities(self, max_errors: int = None, cached: bool = True) -&gt; List[Any]:\n    \"\"\"\n    Converts records fetched from the LOD into entity instances, applying validation.\n\n    Args:\n        max_errors (int, optional): Maximum allowed validation errors. Defaults to 0.\n        cached(bool): if True use existing entries\n    Returns:\n        List[Any]: A list of entity instances that have passed validation.\n    \"\"\"\n    if not cached:\n        self.entities = []\n        self.errors = []\n    elif self.fetched:\n        return self.entities\n\n    error_records = []\n    if max_errors is None:\n        max_errors = self.max_errors\n    for record in self.lod:\n        try:\n            entity = self.clazz.model_validate(record)\n            self.entities.append(entity)\n        except Exception as e:\n            self.errors.append(e)\n            error_records.append(record)\n    error_count = len(self.errors)\n    if error_count &gt; max_errors:\n        msg = f\"found {error_count} errors &gt; maximum allowed {max_errors} errors\"\n        if self.debug:\n            print(msg)\n            for i, e in enumerate(self.errors):\n                print(f\"{i}:{str(e)} for \\n{error_records[i]}\")\n        raise Exception(msg)\n    self.fetched = True\n    return self.entities\n</code></pre>"},{"location":"#lodstorage.sql_cache.SqlDB","title":"<code>SqlDB</code>","text":"<p>general SQL database access using SQL Alchemy</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>class SqlDB:\n    \"\"\"\n    general SQL database access using SQL Alchemy\n    \"\"\"\n\n    def __init__(self, sqlite_file_path: str, debug: bool = False):\n        self.debug = debug\n        sqlite_url = f\"sqlite:///{sqlite_file_path}\"\n        connect_args = {\"check_same_thread\": False}\n        self.engine = create_engine(sqlite_url, echo=debug, connect_args=connect_args)\n\n    def get_session(self) -&gt; Session:\n        \"\"\"\n        Provide a session for database operations.\n\n        Returns:\n            Session: A SQLAlchemy Session object bound to the engine for database operations.\n        \"\"\"\n        return Session(bind=self.engine)\n</code></pre>"},{"location":"#lodstorage.sql_cache.SqlDB.get_session","title":"<code>get_session()</code>","text":"<p>Provide a session for database operations.</p> <p>Returns:</p> Name Type Description <code>Session</code> <code>Session</code> <p>A SQLAlchemy Session object bound to the engine for database operations.</p> Source code in <code>lodstorage/sql_cache.py</code> <pre><code>def get_session(self) -&gt; Session:\n    \"\"\"\n    Provide a session for database operations.\n\n    Returns:\n        Session: A SQLAlchemy Session object bound to the engine for database operations.\n    \"\"\"\n    return Session(bind=self.engine)\n</code></pre>"},{"location":"#lodstorage.storageconfig","title":"<code>storageconfig</code>","text":"<p>Created on 2020-08-29</p> <p>@author: wf</p>"},{"location":"#lodstorage.storageconfig.StorageConfig","title":"<code>StorageConfig</code>","text":"<p>               Bases: <code>object</code></p> <p>a storage configuration</p> Source code in <code>lodstorage/storageconfig.py</code> <pre><code>class StorageConfig(object):\n    \"\"\"\n    a storage configuration\n    \"\"\"\n\n    def getCachePath(self, ensureExists=True) -&gt; str:\n        \"\"\"\n        get the path to the default cache\n\n        Args:\n            name(str): the name of the cache to use\n        \"\"\"\n\n        cachedir = f\"{self.cacheRootDir}/.{self.cacheDirName}\"\n\n        if ensureExists:\n            if not os.path.exists(cachedir):\n                os.makedirs(cachedir)\n        return cachedir\n\n    def __init__(\n        self,\n        mode=StoreMode.SQL,\n        cacheRootDir: str = None,\n        cacheDirName: str = \"lodstorage\",\n        cacheFile=None,\n        withShowProgress=True,\n        profile=True,\n        debug=False,\n        errorDebug=True,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            mode(StoreMode): the storage mode e.g. sql\n            cacheRootDir(str): the cache root directory to use - if None the home directory will be used\n            cacheFile(string): the common cacheFile to use (if any)\n            withShowProgress(boolean): True if progress should be shown\n            profile(boolean): True if timing / profiling information should be shown\n            debug(boolean): True if debugging information should be shown\n            errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n        \"\"\"\n        if cacheRootDir is None:\n            home = str(Path.home())\n            self.cacheRootDir = f\"{home}\"\n        else:\n            self.cacheRootDir = cacheRootDir\n        self.cacheDirName = cacheDirName\n        self.mode = mode\n        self.cacheFile = cacheFile\n        self.profile = profile\n        self.withShowProgress = withShowProgress\n        self.debug = debug\n        self.errorDebug = errorDebug\n\n    @staticmethod\n    def getDefault(debug=False):\n        return StorageConfig.getSQL(debug)\n\n    @staticmethod\n    def getSQL(debug=False):\n        config = StorageConfig(mode=StoreMode.SQL, debug=debug)\n        config.tableName = None\n        return config\n\n    @staticmethod\n    def getJSON(debug=False):\n        config = StorageConfig(mode=StoreMode.JSON, debug=debug)\n        return config\n\n    @staticmethod\n    def getJsonPickle(debug=False):\n        config = StorageConfig(mode=StoreMode.JSONPICKLE, debug=debug)\n        return config\n\n    @staticmethod\n    def getSPARQL(prefix, endpoint, host, debug=False):\n        config = StorageConfig(mode=StoreMode.SPARQL, debug=debug)\n        config.prefix = prefix\n        config.host = host\n        config.endpoint = endpoint\n        return config\n\n    @staticmethod\n    def getYaml(debug=False):\n        config = StorageConfig(mode=StoreMode.YAML, debug=debug)\n        return config\n</code></pre>"},{"location":"#lodstorage.storageconfig.StorageConfig.__init__","title":"<code>__init__(mode=StoreMode.SQL, cacheRootDir=None, cacheDirName='lodstorage', cacheFile=None, withShowProgress=True, profile=True, debug=False, errorDebug=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>mode(StoreMode)</code> <p>the storage mode e.g. sql</p> required <code>cacheRootDir(str)</code> <p>the cache root directory to use - if None the home directory will be used</p> required <code>cacheFile(string)</code> <p>the common cacheFile to use (if any)</p> required <code>withShowProgress(boolean)</code> <p>True if progress should be shown</p> required <code>profile(boolean)</code> <p>True if timing / profiling information should be shown</p> required <code>debug(boolean)</code> <p>True if debugging information should be shown</p> required <code>errorDebug(boolean)</code> <p>True if debug info should be provided on errors (should not be used for production since it might reveal data)</p> required Source code in <code>lodstorage/storageconfig.py</code> <pre><code>def __init__(\n    self,\n    mode=StoreMode.SQL,\n    cacheRootDir: str = None,\n    cacheDirName: str = \"lodstorage\",\n    cacheFile=None,\n    withShowProgress=True,\n    profile=True,\n    debug=False,\n    errorDebug=True,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        mode(StoreMode): the storage mode e.g. sql\n        cacheRootDir(str): the cache root directory to use - if None the home directory will be used\n        cacheFile(string): the common cacheFile to use (if any)\n        withShowProgress(boolean): True if progress should be shown\n        profile(boolean): True if timing / profiling information should be shown\n        debug(boolean): True if debugging information should be shown\n        errorDebug(boolean): True if debug info should be provided on errors (should not be used for production since it might reveal data)\n    \"\"\"\n    if cacheRootDir is None:\n        home = str(Path.home())\n        self.cacheRootDir = f\"{home}\"\n    else:\n        self.cacheRootDir = cacheRootDir\n    self.cacheDirName = cacheDirName\n    self.mode = mode\n    self.cacheFile = cacheFile\n    self.profile = profile\n    self.withShowProgress = withShowProgress\n    self.debug = debug\n    self.errorDebug = errorDebug\n</code></pre>"},{"location":"#lodstorage.storageconfig.StorageConfig.getCachePath","title":"<code>getCachePath(ensureExists=True)</code>","text":"<p>get the path to the default cache</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of the cache to use</p> required Source code in <code>lodstorage/storageconfig.py</code> <pre><code>def getCachePath(self, ensureExists=True) -&gt; str:\n    \"\"\"\n    get the path to the default cache\n\n    Args:\n        name(str): the name of the cache to use\n    \"\"\"\n\n    cachedir = f\"{self.cacheRootDir}/.{self.cacheDirName}\"\n\n    if ensureExists:\n        if not os.path.exists(cachedir):\n            os.makedirs(cachedir)\n    return cachedir\n</code></pre>"},{"location":"#lodstorage.storageconfig.StoreMode","title":"<code>StoreMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>possible supported storage modes</p> Source code in <code>lodstorage/storageconfig.py</code> <pre><code>class StoreMode(Enum):\n    \"\"\"\n    possible supported storage modes\n    \"\"\"\n\n    JSONPICKLE = 1  # JSON Pickle\n    JSON = 2\n    SQL = 3\n    SPARQL = 4\n    YAML = 5\n</code></pre>"},{"location":"#lodstorage.sync","title":"<code>sync</code>","text":"<p>Created on 2023-12-27</p> <p>@author: wf</p>"},{"location":"#lodstorage.sync.Sync","title":"<code>Sync</code>","text":"<p>A class to help with synchronization between two sets of data, each represented as a list of dictionaries.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>class Sync:\n    \"\"\"\n    A class to help with synchronization between two sets of data, each represented as a list of dictionaries.\n    \"\"\"\n\n    def __init__(self, pair: SyncPair):\n        \"\"\"\n        Initialize the Sync class with the given Synchronization Pair.\n        \"\"\"\n        self.pair = pair\n        self.sync_dict = self._create_sync_dict()\n        self.directions = [\"\u2190\", \"\u2194\", \"\u2192\"]\n        self.sides = {\"left\": [\"\u2190\", \"l\", \"left\"], \"right\": [\"\u2192\", \"r\", \"right\"]}\n\n    def handle_direction_error(self, direction: str):\n        invalid_direction_msg = (\n            f\"Invalid direction '{direction}'. Use {', '.join(self.directions)}.\"\n        )\n        raise ValueError(invalid_direction_msg)\n\n    def handle_side_error(self, side: str):\n        invalid_side_msg = f\"Invalid side '{side}'. Use {', '.join(self.sides['left'])} for left or {', '.join(self.sides['right'])} for right.\"\n        raise ValueError(invalid_side_msg)\n\n    def _create_sync_dict(self) -&gt; dict:\n        \"\"\"\n        Create a dictionary representing the synchronization state between left and right data sources.\n        \"\"\"\n        l_keys = {d[self.pair.l_key] for d in self.pair.l_data if self.pair.l_key in d}\n        r_keys = {d[self.pair.r_key] for d in self.pair.r_data if self.pair.r_key in d}\n\n        sync_dict = {\n            \"\u2190\": r_keys - l_keys,  # Present in right but not in left\n            \"\u2194\": l_keys.intersection(r_keys),  # Present in both\n            \"\u2192\": l_keys - r_keys,  # Present in left but not in right\n        }\n        return sync_dict\n\n    def get_record_by_pkey(self, side: str, pkey: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieves a record by primary key from the appropriate data source as specified by direction.\n\n        Args:\n            side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n            pkey (str): The primary key of the record to retrieve.\n\n        Returns:\n            Optional[Dict[str, Any]]: The record if found, otherwise None.\n        \"\"\"\n        record = None\n        if side in self.sides[\"left\"]:  # retrieve from left\n            record = self.pair.l_by_pkey.get(pkey)\n        elif side in self.sides[\"right\"]:  # retrieve from right\n            record = self.pair.r_by_pkey.get(pkey)\n        else:\n            self.handle_side_error(side)\n        return record\n\n    def get_record_by_key(self, side: str, key: str) -&gt; dict:\n        \"\"\"\n        Retrieves a record by the given unique key from the appropriate data source as specified by direction.\n\n        Args:\n            side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n            key (str): The unique key of the record to retrieve.\n\n        Returns:\n            Optional[Dict[str, Any]]: The record if found, otherwise None.\n\n        Raises:\n            ValueError: If the provided direction is invalid.\n        \"\"\"\n        record = None\n        if side in [\"\u2190\", \"l\", \"left\"]:\n            record = next(\n                (item for item in self.pair.l_data if item[self.pair.l_key] == key),\n                None,\n            )\n        elif side in [\"\u2192\", \"r\", \"right\"]:\n            record = next(\n                (item for item in self.pair.r_data if item[self.pair.r_key] == key),\n                None,\n            )\n        else:\n            self.handle_side_error(side)\n        return record\n\n    def get_keys(self, direction: str) -&gt; set:\n        \"\"\"\n        Get the keys for a given direction of synchronization.\n        \"\"\"\n        if direction in self.sync_dict:\n            return self.sync_dict[direction]\n        else:\n            self.handle_direction_error(direction)\n\n    def status_table(self, tablefmt: str = \"grid\") -&gt; str:\n        \"\"\"\n        Create a table representing the synchronization status.\n        \"\"\"\n        total_records = sum(len(keys) for keys in self.sync_dict.values())\n        if total_records == 0:  # Avoid division by zero\n            total_records = 1\n\n        table_data = []\n        for direction, keys in self.sync_dict.items():\n            num_records = len(keys)\n            percentage = (num_records / total_records) * 100\n            table_data.append(\n                {\n                    \"left\": self.pair.l_name,\n                    \"\u2194\": direction,\n                    \"right\": self.pair.r_name,\n                    \"#\": num_records,\n                    \"%\": f\"{percentage:7.2f}%\",\n                }\n            )\n\n        markup = tabulate(\n            table_data,\n            headers=\"keys\",\n            tablefmt=tablefmt,\n            colalign=(\"right\", \"center\", \"left\", \"right\", \"right\"),\n        )\n        return markup\n</code></pre>"},{"location":"#lodstorage.sync.Sync.__init__","title":"<code>__init__(pair)</code>","text":"<p>Initialize the Sync class with the given Synchronization Pair.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def __init__(self, pair: SyncPair):\n    \"\"\"\n    Initialize the Sync class with the given Synchronization Pair.\n    \"\"\"\n    self.pair = pair\n    self.sync_dict = self._create_sync_dict()\n    self.directions = [\"\u2190\", \"\u2194\", \"\u2192\"]\n    self.sides = {\"left\": [\"\u2190\", \"l\", \"left\"], \"right\": [\"\u2192\", \"r\", \"right\"]}\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_keys","title":"<code>get_keys(direction)</code>","text":"<p>Get the keys for a given direction of synchronization.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_keys(self, direction: str) -&gt; set:\n    \"\"\"\n    Get the keys for a given direction of synchronization.\n    \"\"\"\n    if direction in self.sync_dict:\n        return self.sync_dict[direction]\n    else:\n        self.handle_direction_error(direction)\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_record_by_key","title":"<code>get_record_by_key(side, key)</code>","text":"<p>Retrieves a record by the given unique key from the appropriate data source as specified by direction.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>str</code> <p>The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.</p> required <code>key</code> <code>str</code> <p>The unique key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Optional[Dict[str, Any]]: The record if found, otherwise None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided direction is invalid.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_record_by_key(self, side: str, key: str) -&gt; dict:\n    \"\"\"\n    Retrieves a record by the given unique key from the appropriate data source as specified by direction.\n\n    Args:\n        side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n        key (str): The unique key of the record to retrieve.\n\n    Returns:\n        Optional[Dict[str, Any]]: The record if found, otherwise None.\n\n    Raises:\n        ValueError: If the provided direction is invalid.\n    \"\"\"\n    record = None\n    if side in [\"\u2190\", \"l\", \"left\"]:\n        record = next(\n            (item for item in self.pair.l_data if item[self.pair.l_key] == key),\n            None,\n        )\n    elif side in [\"\u2192\", \"r\", \"right\"]:\n        record = next(\n            (item for item in self.pair.r_data if item[self.pair.r_key] == key),\n            None,\n        )\n    else:\n        self.handle_side_error(side)\n    return record\n</code></pre>"},{"location":"#lodstorage.sync.Sync.get_record_by_pkey","title":"<code>get_record_by_pkey(side, pkey)</code>","text":"<p>Retrieves a record by primary key from the appropriate data source as specified by direction.</p> <p>Parameters:</p> Name Type Description Default <code>side</code> <code>str</code> <p>The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.</p> required <code>pkey</code> <code>str</code> <p>The primary key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Optional[Dict[str, Any]]: The record if found, otherwise None.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def get_record_by_pkey(self, side: str, pkey: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a record by primary key from the appropriate data source as specified by direction.\n\n    Args:\n        side (str): The side of data source, \"\u2190\",\"l\" or \"left\" for left and \"\u2192\",\"r\" or \"right\" for right.\n        pkey (str): The primary key of the record to retrieve.\n\n    Returns:\n        Optional[Dict[str, Any]]: The record if found, otherwise None.\n    \"\"\"\n    record = None\n    if side in self.sides[\"left\"]:  # retrieve from left\n        record = self.pair.l_by_pkey.get(pkey)\n    elif side in self.sides[\"right\"]:  # retrieve from right\n        record = self.pair.r_by_pkey.get(pkey)\n    else:\n        self.handle_side_error(side)\n    return record\n</code></pre>"},{"location":"#lodstorage.sync.Sync.status_table","title":"<code>status_table(tablefmt='grid')</code>","text":"<p>Create a table representing the synchronization status.</p> Source code in <code>lodstorage/sync.py</code> <pre><code>def status_table(self, tablefmt: str = \"grid\") -&gt; str:\n    \"\"\"\n    Create a table representing the synchronization status.\n    \"\"\"\n    total_records = sum(len(keys) for keys in self.sync_dict.values())\n    if total_records == 0:  # Avoid division by zero\n        total_records = 1\n\n    table_data = []\n    for direction, keys in self.sync_dict.items():\n        num_records = len(keys)\n        percentage = (num_records / total_records) * 100\n        table_data.append(\n            {\n                \"left\": self.pair.l_name,\n                \"\u2194\": direction,\n                \"right\": self.pair.r_name,\n                \"#\": num_records,\n                \"%\": f\"{percentage:7.2f}%\",\n            }\n        )\n\n    markup = tabulate(\n        table_data,\n        headers=\"keys\",\n        tablefmt=tablefmt,\n        colalign=(\"right\", \"center\", \"left\", \"right\", \"right\"),\n    )\n    return markup\n</code></pre>"},{"location":"#lodstorage.sync.SyncPair","title":"<code>SyncPair</code>  <code>dataclass</code>","text":"<p>A class to represent a pair of data sources for synchronization.</p> <p>Attributes:        title (str): The title of the synchronization pair.        l_name (str): Name of the left data source (e.g., 'local').        r_name (str): Name of the right data source (e.g., 'wikidata').        l_data (List[Dict[str, Any]]): A list of dictionaries from the left data source.        r_data (List[Dict[str, Any]]): A list of dictionaries from the right data source.        l_key (str): The field name in the left data source dictionaries used as a unique identifier for synchronization.        r_key (str): The field name in the right data source dictionaries used as a unique identifier for synchronization.        l_pkey(str): the primary key field of the left data source        r_pkey(str): the primary key field of the right data source</p> <p>Example usage: l_data = [{'id_l': '1', 'value': 'a'}, {'id_l': '2', 'value': 'b'}] r_data = [{'id_r': '2', 'value': 'b'}, {'id_r': '3', 'value': 'c'}] pair = SyncPair(\"Title\", \"local\", \"wikidata\", l_data, r_data, 'id_l', 'id_r') sync = Sync(pair) print(sync.status_table())</p> Source code in <code>lodstorage/sync.py</code> <pre><code>@dataclass\nclass SyncPair:\n    \"\"\"\n       A class to represent a pair of data sources for synchronization.\n\n       Attributes:\n           title (str): The title of the synchronization pair.\n           l_name (str): Name of the left data source (e.g., 'local').\n           r_name (str): Name of the right data source (e.g., 'wikidata').\n           l_data (List[Dict[str, Any]]): A list of dictionaries from the left data source.\n           r_data (List[Dict[str, Any]]): A list of dictionaries from the right data source.\n           l_key (str): The field name in the left data source dictionaries used as a unique identifier for synchronization.\n           r_key (str): The field name in the right data source dictionaries used as a unique identifier for synchronization.\n           l_pkey(str): the primary key field of the left data source\n           r_pkey(str): the primary key field of the right data source\n\n    Example usage:\n    l_data = [{'id_l': '1', 'value': 'a'}, {'id_l': '2', 'value': 'b'}]\n    r_data = [{'id_r': '2', 'value': 'b'}, {'id_r': '3', 'value': 'c'}]\n    pair = SyncPair(\"Title\", \"local\", \"wikidata\", l_data, r_data, 'id_l', 'id_r')\n    sync = Sync(pair)\n    print(sync.status_table())\n    \"\"\"\n\n    title: str\n    l_name: str\n    r_name: str\n    l_data: List[Dict[str, Any]]\n    r_data: List[Dict[str, Any]]\n    l_key: str\n    r_key: str\n    l_pkey: Optional[str] = None\n    r_pkey: Optional[str] = None\n    # Add dictionaries for quick primary key access\n    l_by_pkey: Dict[str, Dict[str, Any]] = field(init=False)\n    r_by_pkey: Dict[str, Dict[str, Any]] = field(init=False)\n\n    def __post_init__(self):\n        # Set the l_pkey to l_key if not provided\n        if self.l_pkey is None:\n            self.l_pkey = self.l_key\n        # Set the r_pkey to r_key if not provided\n        if self.r_pkey is None:\n            self.r_pkey = self.r_key\n        self.l_by_pkey = {d[self.l_pkey]: d for d in self.l_data if self.l_pkey in d}\n        self.r_by_pkey = {d[self.r_pkey]: d for d in self.r_data if self.r_pkey in d}\n</code></pre>"},{"location":"#lodstorage.tabulateCounter","title":"<code>tabulateCounter</code>","text":"<p>Created on 2021-06-13</p> <p>@author: wf</p>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter","title":"<code>TabulateCounter</code>","text":"<p>               Bases: <code>object</code></p> <p>helper for tabulating Counters</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>class TabulateCounter(object):\n    \"\"\"\n    helper for tabulating Counters\n    \"\"\"\n\n    def __init__(self, counter):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.counter = counter\n\n    def mostCommonTable(\n        self, headers=[\"#\", \"key\", \"count\", \"%\"], tablefmt=\"pretty\", limit=50\n    ):\n        \"\"\"\n        get the most common Table\n        \"\"\"\n        bins = len(self.counter.keys())\n        limit = min(bins, limit)\n        total = sum(self.counter.values())\n        binTable = [(\"total\", bins, total)]\n        for i, bintuple in enumerate(self.counter.most_common(limit)):\n            key, count = bintuple\n            binTable.append((i + 1, key, count, count / total * 100.0))\n\n        table = tabulate(binTable, headers=headers, tablefmt=tablefmt, floatfmt=\".2f\")\n        return table\n</code></pre>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter.__init__","title":"<code>__init__(counter)</code>","text":"<p>Constructor</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>def __init__(self, counter):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.counter = counter\n</code></pre>"},{"location":"#lodstorage.tabulateCounter.TabulateCounter.mostCommonTable","title":"<code>mostCommonTable(headers=['#', 'key', 'count', '%'], tablefmt='pretty', limit=50)</code>","text":"<p>get the most common Table</p> Source code in <code>lodstorage/tabulateCounter.py</code> <pre><code>def mostCommonTable(\n    self, headers=[\"#\", \"key\", \"count\", \"%\"], tablefmt=\"pretty\", limit=50\n):\n    \"\"\"\n    get the most common Table\n    \"\"\"\n    bins = len(self.counter.keys())\n    limit = min(bins, limit)\n    total = sum(self.counter.values())\n    binTable = [(\"total\", bins, total)]\n    for i, bintuple in enumerate(self.counter.most_common(limit)):\n        key, count = bintuple\n        binTable.append((i + 1, key, count, count / total * 100.0))\n\n    table = tabulate(binTable, headers=headers, tablefmt=tablefmt, floatfmt=\".2f\")\n    return table\n</code></pre>"},{"location":"#lodstorage.uml","title":"<code>uml</code>","text":"<p>Created on 2020-09-04</p> <p>@author: wf</p>"},{"location":"#lodstorage.uml.UML","title":"<code>UML</code>","text":"<p>               Bases: <code>object</code></p> <p>UML diagrams via plantuml</p> Source code in <code>lodstorage/uml.py</code> <pre><code>class UML(object):\n    \"\"\"\n    UML diagrams via plantuml\n\n    \"\"\"\n\n    skinparams = \"\"\"\n' BITPlan Corporate identity skin params\n' Copyright (c) 2015-2020 BITPlan GmbH\n' see http://wiki.bitplan.com/PlantUmlSkinParams#BITPlanCI\n' skinparams generated by com.bitplan.restmodelmanager\nskinparam note {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam component {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam package {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam usecase {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam activity {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam classAttribute {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam interface {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam class {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam object {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nhide Circle\n' end of skinparams '\n\"\"\"\n\n    def __init__(self, debug=False):\n        \"\"\"\n        Constructor\n        Args:\n            debug(boolean): True if debug information should be shown\n        \"\"\"\n        self.debug = debug\n\n    def tableListToPlantUml(\n        self, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True\n    ):\n        \"\"\"\n        convert tableList to PlantUml notation\n\n        Args:\n            tableList(list): the tableList list of Dicts from getTableList() to convert\n            title(string): optional title to be added\n            packageName(string): optional packageName to be added\n            generalizeTo(string): optional name of a general table to be derived\n            withSkin(boolean): if True add default BITPlan skin parameters\n\n        Returns:\n            string: the Plantuml notation for the entities in columns of the given tablelist\n        \"\"\"\n        uml = \"\"\n        indent = \"\"\n        inherit = \"\"\n        if title is not None:\n            uml += \"title\\n%s\\nend title\\n\" % title\n        if packageName is not None:\n            uml += \"package %s {\\n\" % packageName\n            indent = \"  \"\n        if generalizeTo is not None:\n            generalTable = Schema.getGeneral(tableList, generalizeTo)\n            for table in tableList:\n                inherit += \"%s%s &lt;|-- %s\\n\" % (indent, generalizeTo, table[\"name\"])\n            tableList.insert(0, generalTable)\n        for table in tableList:\n            colUml = \"\"\n            sortedColumns = sorted(table[\"columns\"], key=lambda col: col[\"name\"])\n            for col in sortedColumns:\n                mandatory = \"*\" if col[\"notnull\"] == 1 else \"\"\n                pk = \"&lt;&lt;PK&gt;&gt;\" if col[\"pk\"] == 1 else \"\"\n                colName = col[\"name\"]\n                colType = col[\"type\"]\n                if \"link\" in col:\n                    colName = col[\"link\"]\n                colUml += \"%s %s%s : %s %s\\n\" % (\n                    indent,\n                    mandatory,\n                    colName,\n                    colType,\n                    pk,\n                )\n            tableName = table[\"name\"]\n            if \"notes\" in table:\n                uml += \"Note top of %s\\n%s\\nEnd note\\n\" % (tableName, table[\"notes\"])\n            uml += \"%sclass %s &lt;&lt; Entity &gt;&gt; {\\n%s%s}\\n\" % (\n                indent,\n                tableName,\n                colUml,\n                indent,\n            )\n        uml += inherit\n        if packageName is not None:\n            uml += \"}\\n\"\n        if withSkin:\n            uml += UML.skinparams\n        return uml\n\n    def mergeSchema(\n        self,\n        schemaManager,\n        tableList,\n        title=None,\n        packageName=None,\n        generalizeTo=None,\n        withSkin=True,\n    ):\n        \"\"\"\n        merge Schema and tableList to PlantUml notation\n\n        Args:\n            schemaManager(SchemaManager): a schema manager to be used\n            tableList(list): the tableList list of Dicts from getTableList() to convert\n            title(string): optional title to be added\n            packageName(string): optional packageName to be added\n            generalizeTo(string): optional name of a general table to be derived\n            withSkin(boolean): if True add default BITPlan skin parameters\n\n        Returns:\n            string: the Plantuml notation for the entities in columns of the given tablelist\n\n        \"\"\"\n        if schemaManager is not None:\n            for table in tableList:\n                if \"schema\" in table:\n                    schema = schemaManager.schemasByName[table[\"schema\"]]\n                    url = \"%s/%s\" % (schemaManager.baseUrl, schema.name)\n                    url = url.replace(\" \", \"_\")  # mediawiki\n                    instanceNote = \"\"\n                    if \"instances\" in table:\n                        instanceNote = \"\\n%d instances \" % (table[\"instances\"])\n                    table[\"notes\"] = \"\"\"[[%s %s]]%s\"\"\" % (\n                        url,\n                        schema.name,\n                        instanceNote,\n                    )\n                    for col in table[\"columns\"]:\n                        colName = col[\"name\"]\n                        if colName in schema.propsByName:\n                            prop = schema.propsByName[colName]\n                            if prop.iri is not None:\n                                tooltip = \"\"\n                                if prop.definition is not None:\n                                    tooltip = \"{%s}\" % prop.definition\n                                col[\"link\"] = \"[[%s%s %s]]\" % (\n                                    prop.iri,\n                                    tooltip,\n                                    colName,\n                                )\n                                col[\"special\"] = True  # keep column even if generalized\n                    pass\n        plantuml = self.tableListToPlantUml(\n            tableList,\n            title=title,\n            packageName=packageName,\n            generalizeTo=generalizeTo,\n            withSkin=withSkin,\n        )\n        return plantuml\n</code></pre>"},{"location":"#lodstorage.uml.UML.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>Constructor Args:     debug(boolean): True if debug information should be shown</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def __init__(self, debug=False):\n    \"\"\"\n    Constructor\n    Args:\n        debug(boolean): True if debug information should be shown\n    \"\"\"\n    self.debug = debug\n</code></pre>"},{"location":"#lodstorage.uml.UML.mergeSchema","title":"<code>mergeSchema(schemaManager, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True)</code>","text":"<p>merge Schema and tableList to PlantUml notation</p> <p>Parameters:</p> Name Type Description Default <code>schemaManager(SchemaManager)</code> <p>a schema manager to be used</p> required <code>tableList(list)</code> <p>the tableList list of Dicts from getTableList() to convert</p> required <code>title(string)</code> <p>optional title to be added</p> required <code>packageName(string)</code> <p>optional packageName to be added</p> required <code>generalizeTo(string)</code> <p>optional name of a general table to be derived</p> required <code>withSkin(boolean)</code> <p>if True add default BITPlan skin parameters</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the Plantuml notation for the entities in columns of the given tablelist</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def mergeSchema(\n    self,\n    schemaManager,\n    tableList,\n    title=None,\n    packageName=None,\n    generalizeTo=None,\n    withSkin=True,\n):\n    \"\"\"\n    merge Schema and tableList to PlantUml notation\n\n    Args:\n        schemaManager(SchemaManager): a schema manager to be used\n        tableList(list): the tableList list of Dicts from getTableList() to convert\n        title(string): optional title to be added\n        packageName(string): optional packageName to be added\n        generalizeTo(string): optional name of a general table to be derived\n        withSkin(boolean): if True add default BITPlan skin parameters\n\n    Returns:\n        string: the Plantuml notation for the entities in columns of the given tablelist\n\n    \"\"\"\n    if schemaManager is not None:\n        for table in tableList:\n            if \"schema\" in table:\n                schema = schemaManager.schemasByName[table[\"schema\"]]\n                url = \"%s/%s\" % (schemaManager.baseUrl, schema.name)\n                url = url.replace(\" \", \"_\")  # mediawiki\n                instanceNote = \"\"\n                if \"instances\" in table:\n                    instanceNote = \"\\n%d instances \" % (table[\"instances\"])\n                table[\"notes\"] = \"\"\"[[%s %s]]%s\"\"\" % (\n                    url,\n                    schema.name,\n                    instanceNote,\n                )\n                for col in table[\"columns\"]:\n                    colName = col[\"name\"]\n                    if colName in schema.propsByName:\n                        prop = schema.propsByName[colName]\n                        if prop.iri is not None:\n                            tooltip = \"\"\n                            if prop.definition is not None:\n                                tooltip = \"{%s}\" % prop.definition\n                            col[\"link\"] = \"[[%s%s %s]]\" % (\n                                prop.iri,\n                                tooltip,\n                                colName,\n                            )\n                            col[\"special\"] = True  # keep column even if generalized\n                pass\n    plantuml = self.tableListToPlantUml(\n        tableList,\n        title=title,\n        packageName=packageName,\n        generalizeTo=generalizeTo,\n        withSkin=withSkin,\n    )\n    return plantuml\n</code></pre>"},{"location":"#lodstorage.uml.UML.tableListToPlantUml","title":"<code>tableListToPlantUml(tableList, title=None, packageName=None, generalizeTo=None, withSkin=True)</code>","text":"<p>convert tableList to PlantUml notation</p> <p>Parameters:</p> Name Type Description Default <code>tableList(list)</code> <p>the tableList list of Dicts from getTableList() to convert</p> required <code>title(string)</code> <p>optional title to be added</p> required <code>packageName(string)</code> <p>optional packageName to be added</p> required <code>generalizeTo(string)</code> <p>optional name of a general table to be derived</p> required <code>withSkin(boolean)</code> <p>if True add default BITPlan skin parameters</p> required <p>Returns:</p> Name Type Description <code>string</code> <p>the Plantuml notation for the entities in columns of the given tablelist</p> Source code in <code>lodstorage/uml.py</code> <pre><code>def tableListToPlantUml(\n    self, tableList, title=None, packageName=None, generalizeTo=None, withSkin=True\n):\n    \"\"\"\n    convert tableList to PlantUml notation\n\n    Args:\n        tableList(list): the tableList list of Dicts from getTableList() to convert\n        title(string): optional title to be added\n        packageName(string): optional packageName to be added\n        generalizeTo(string): optional name of a general table to be derived\n        withSkin(boolean): if True add default BITPlan skin parameters\n\n    Returns:\n        string: the Plantuml notation for the entities in columns of the given tablelist\n    \"\"\"\n    uml = \"\"\n    indent = \"\"\n    inherit = \"\"\n    if title is not None:\n        uml += \"title\\n%s\\nend title\\n\" % title\n    if packageName is not None:\n        uml += \"package %s {\\n\" % packageName\n        indent = \"  \"\n    if generalizeTo is not None:\n        generalTable = Schema.getGeneral(tableList, generalizeTo)\n        for table in tableList:\n            inherit += \"%s%s &lt;|-- %s\\n\" % (indent, generalizeTo, table[\"name\"])\n        tableList.insert(0, generalTable)\n    for table in tableList:\n        colUml = \"\"\n        sortedColumns = sorted(table[\"columns\"], key=lambda col: col[\"name\"])\n        for col in sortedColumns:\n            mandatory = \"*\" if col[\"notnull\"] == 1 else \"\"\n            pk = \"&lt;&lt;PK&gt;&gt;\" if col[\"pk\"] == 1 else \"\"\n            colName = col[\"name\"]\n            colType = col[\"type\"]\n            if \"link\" in col:\n                colName = col[\"link\"]\n            colUml += \"%s %s%s : %s %s\\n\" % (\n                indent,\n                mandatory,\n                colName,\n                colType,\n                pk,\n            )\n        tableName = table[\"name\"]\n        if \"notes\" in table:\n            uml += \"Note top of %s\\n%s\\nEnd note\\n\" % (tableName, table[\"notes\"])\n        uml += \"%sclass %s &lt;&lt; Entity &gt;&gt; {\\n%s%s}\\n\" % (\n            indent,\n            tableName,\n            colUml,\n            indent,\n        )\n    uml += inherit\n    if packageName is not None:\n        uml += \"}\\n\"\n    if withSkin:\n        uml += UML.skinparams\n    return uml\n</code></pre>"},{"location":"#lodstorage.version","title":"<code>version</code>","text":"<p>Created on 2022-03-06</p> <p>@author: wf</p>"},{"location":"#lodstorage.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyLoDStorage</p> Source code in <code>lodstorage/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyLoDStorage\n    \"\"\"\n\n    name = \"pylodstorage\"\n    version = lodstorage.__version__\n    date = \"2020-09-10\"\n    updated = \"2024-08-02\"\n    description = \"python List of Dict (Table) Storage library\"\n</code></pre>"},{"location":"#lodstorage.xml","title":"<code>xml</code>","text":"<p>Created on 2022-06-20</p> <p>see     https://github.com/tyleradams/json-toolkit     https://stackoverflow.com/questions/36021526/converting-an-array-dict-to-xml-in-python</p> <p>@author: tyleradams @author: wf</p>"},{"location":"#lodstorage.xml.Lod2Xml","title":"<code>Lod2Xml</code>","text":"<p>convert a list of dicts to XML</p> Source code in <code>lodstorage/xml.py</code> <pre><code>class Lod2Xml:\n    \"\"\"\n    convert a list of dicts to XML\n    \"\"\"\n\n    def __init__(\n        self, lod, root: str = \"root\", node_name: callable = (lambda x: \"node\")\n    ):\n        \"\"\"\n        construct me with the given list of dicts\n\n        Args:\n            lod(list): the list of dicts to convert to XML\n            root(str): the name of the root nod\n            item_name(func): the function to use to calculate node names\n        \"\"\"\n        self.lod = lod\n        self.root = root\n        self.item_name = node_name\n\n    def asXml(self, pretty: bool = True):\n        \"\"\"\n        convert result to XML\n\n        Args:\n            pretty(bool): if True pretty print the result\n\n        \"\"\"\n        xml = dicttoxml(\n            self.lod, custom_root=self.root, item_func=self.item_name, attr_type=False\n        )\n        if pretty:\n            dom = parseString(xml)\n            prettyXml = dom.toprettyxml()\n        else:\n            prettyXml = xml\n        return prettyXml\n</code></pre>"},{"location":"#lodstorage.xml.Lod2Xml.__init__","title":"<code>__init__(lod, root='root', node_name=lambda x: 'node')</code>","text":"<p>construct me with the given list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>lod(list)</code> <p>the list of dicts to convert to XML</p> required <code>root(str)</code> <p>the name of the root nod</p> required <code>item_name(func)</code> <p>the function to use to calculate node names</p> required Source code in <code>lodstorage/xml.py</code> <pre><code>def __init__(\n    self, lod, root: str = \"root\", node_name: callable = (lambda x: \"node\")\n):\n    \"\"\"\n    construct me with the given list of dicts\n\n    Args:\n        lod(list): the list of dicts to convert to XML\n        root(str): the name of the root nod\n        item_name(func): the function to use to calculate node names\n    \"\"\"\n    self.lod = lod\n    self.root = root\n    self.item_name = node_name\n</code></pre>"},{"location":"#lodstorage.xml.Lod2Xml.asXml","title":"<code>asXml(pretty=True)</code>","text":"<p>convert result to XML</p> <p>Parameters:</p> Name Type Description Default <code>pretty(bool)</code> <p>if True pretty print the result</p> required Source code in <code>lodstorage/xml.py</code> <pre><code>def asXml(self, pretty: bool = True):\n    \"\"\"\n    convert result to XML\n\n    Args:\n        pretty(bool): if True pretty print the result\n\n    \"\"\"\n    xml = dicttoxml(\n        self.lod, custom_root=self.root, item_func=self.item_name, attr_type=False\n    )\n    if pretty:\n        dom = parseString(xml)\n        prettyXml = dom.toprettyxml()\n    else:\n        prettyXml = xml\n    return prettyXml\n</code></pre>"},{"location":"#lodstorage.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.     Use 'samples 2' example from pyLoDStorage     https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference. </li> <li>Ensure tests cover YAML/JSON serialization, deserialization,     and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json      prerequisite behavior to a class</li> </ol>"},{"location":"#lodstorage.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; datetime.date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(\n            obj_dict, ignore_none, ignore_underscore\n        )\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            yaml_str: str = file.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(yaml_content)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\", encoding=\"utf-8\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if (\n                    isinstance(v, Iterable)\n                    and not isinstance(v, (str, bytes))\n                    and not v\n                ):\n                    return (\n                        False  # Empty list, set, tuple, etc., but not string or bytes\n                    )\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: Union[str, Path]) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\", encoding=\"utf-8\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        yaml_str: str = file.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>lodstorage/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if (\n                isinstance(v, Iterable)\n                and not isinstance(v, (str, bytes))\n                and not v\n            ):\n                return (\n                    False  # Empty list, set, tuple, etc., but not string or bytes\n                )\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>lodstorage/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>lodstorage/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(yaml_content)\n</code></pre>"},{"location":"#lodstorage.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(\n        obj_dict, ignore_none, ignore_underscore\n    )\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#lodstorage.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>lodstorage/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"},{"location":"#lodstorage.yamlablemixin","title":"<code>yamlablemixin</code>","text":""},{"location":"#lodstorage.yamlablemixin.YamlAbleMixin","title":"<code>YamlAbleMixin</code>","text":"<p>               Bases: <code>object</code></p> <p>allow reading and writing derived objects from a yaml file</p> Source code in <code>lodstorage/yamlablemixin.py</code> <pre><code>class YamlAbleMixin(object):\n    \"\"\"allow reading and writing derived objects from a yaml file\"\"\"\n\n    debug = False\n\n    # read me from a yaml file\n    @staticmethod\n    def readYaml(name):\n        yamlFile = name\n        if not yamlFile.endswith(\".yaml\"):\n            yamlFile = yamlFile + \".yaml\"\n        # is there a yamlFile for the given name\n        if os.path.isfile(yamlFile):\n            with io.open(yamlFile, \"r\") as stream:\n                if YamlAbleMixin.debug:\n                    print(\"reading %s\" % (yamlFile))\n                result = yaml.load(stream, Loader=yaml.Loader)\n                if YamlAbleMixin.debug:\n                    print(result)\n                return result\n        else:\n            return None\n\n    # write me to my yaml file\n    def writeYaml(self, name):\n        yamlFile = name\n        if not yamlFile.endswith(\".yaml\"):\n            yamlFile = yamlFile + \".yaml\"\n        with io.open(yamlFile, \"w\", encoding=\"utf-8\") as stream:\n            yaml.dump(self, stream)\n            if YamlAbleMixin.debug:\n                print(yaml.dump(self))\n</code></pre>"}]}