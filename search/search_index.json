{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Documentation","text":""},{"location":"#sidif.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#sidif.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>sidif/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        self.starttime = time.time()\n        if profile:\n            print(f\"Starting {msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#sidif.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>sidif/profiler.py</code> <pre><code>def __init__(self, msg, profile=True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    self.starttime = time.time()\n    if profile:\n        print(f\"Starting {msg} ...\")\n</code></pre>"},{"location":"#sidif.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>sidif/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#sidif.sidif","title":"<code>sidif</code>","text":"<p>Created on 2020-11-06</p> <p>@author: wf</p>"},{"location":"#sidif.sidif.Comment","title":"<code>Comment</code>","text":"<p>a comment with it's location</p> Source code in <code>sidif/sidif.py</code> <pre><code>class Comment:\n    \"\"\"\n    a comment with it's location\n    \"\"\"\n\n    def __init__(self, comment, location):\n        self.comment = comment\n        self.location = location\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange","title":"<code>DataInterchange</code>","text":"<p>a data interchange</p> Source code in <code>sidif/sidif.py</code> <pre><code>class DataInterchange:\n    \"\"\"\n    a data interchange\n    \"\"\"\n\n    def __init__(self):\n        self.triples = []\n        self.comments = []\n        pass\n\n    @staticmethod\n    def ofDict(pDict, context=\"context\"):\n        dif = DataInterchange()\n        dif.addTriple(Triple(context, \"isA\", \"Context\"))\n        dif.addTriple(Triple(context, \"name\", \"it\"))\n        dif.addSchemaFromDict(pDict, context, context, \"context\")\n        return dif\n\n    def addLink(\n        self,\n        name,\n        source,\n        target,\n        sourceRole,\n        targetRole,\n        sourceMultiple,\n        targetMultiple,\n    ):\n        self.addTriple(Triple(name, \"isA\", \"TopicLink\"))\n        self.addTriple(Triple(name, \"name\", \"it\"))\n        self.addTriple(Triple(target, \"target\", \"it\"))\n        self.addTriple(Triple(source, \"source\", \"it\"))\n        self.addTriple(Triple(targetRole, \"targetRole\", \"it\"))\n        self.addTriple(Triple(sourceRole, \"sourceRole\", \"it\"))\n        self.addTriple(Triple(sourceMultiple, \"sourceMultiple\", \"it\"))\n        self.addTriple(Triple(targetMultiple, \"targetMultiple\", \"it\"))\n\n    def addTopic(self, name, context):\n        topicId = self.fixId(name)\n        self.addTriple(Triple(topicId, \"isA\", \"Topic\"))\n        self.addTriple(Triple(name, \"name\", \"it\"))\n        self.addTriple(Triple(context, \"context\", \"it\"))\n\n    def fixId(self, name):\n        fixed = re.sub(r\"[#@]\", \"\", name)\n        return fixed\n\n    def addSchemaFromDict(self, pDict, context, parent, parentName):\n        \"\"\"\n        add schema information from the given dict\n        \"\"\"\n        if not isinstance(pDict, dict):\n            return\n        # make sure we work on properties first then other topics\n        sortedKeys = sorted(pDict.keys(), key=lambda x: isinstance(pDict[x], dict))\n        # loop over nodes\n        for key in sortedKeys:\n            value = pDict[key]\n            # is the subnode a Topic or a Property?\n            if isinstance(value, dict):\n                # if there is an intermediate node\n                # then there is a topic link\n                # eg. workshop - events - event\n                # https://stackoverflow.com/questions/21062781/shortest-way-to-get-first-item-of-ordereddict-in-python-3\n                if len(value) == 1 and isinstance(list(value.values())[0], list):\n                    listNode = list(value.values())[0]\n                    firstListNode = listNode[0]\n                    listKey = list(value.keys())[0]\n                    self.addTopic(listKey, context)\n                    self.addSchemaFromDict(firstListNode, context, listKey, \"Topic\")\n                    self.addLink(\n                        key, parent, listKey, \"\", key, False, len(listNode) &gt; 1\n                    )\n                else:\n                    # standalone topic\n                    linkKey = \"%s%s\" % (parent, key)\n                    self.addTopic(key, context)\n                    self.addSchemaFromDict(value, context, key, \"Topic\")\n                    if parentName != \"context\":\n                        self.addLink(linkKey, parent, key, \"\", \"\", False, False)\n            else:\n                propId = self.fixId(key)\n                self.addTriple(Triple(propId, \"isA\", \"Property\"))\n                self.addTriple(Triple(key, \"name\", \"it\"))\n                valueType = type(value).__name__\n                self.addTriple(Triple(valueType, \"type\", \"it\"))\n                self.addTriple(Triple(parent, parentName, \"it\"))\n\n    def addTriple(self, triple):\n        \"\"\"\n        add the given triple\n\n        Args:\n            triple(Triple): the triple to add\n        \"\"\"\n        self.triples.append(triple)\n\n    def addComment(self, comment):\n        \"\"\"\n        add the given comment\n        \"\"\"\n        self.comments.append(comment)\n\n    def asSiDIF(self):\n        \"\"\"\n        convert me to SiDIF notation\n        \"\"\"\n        sidifStr = \"\"\n        for triple in self.triples:\n            sidif = triple.asSiDIF()\n            sidifStr += f\"{sidif}\\n\"\n        return sidifStr\n\n    def toDictOfDicts(self):\n        \"\"\"\n        convert me to a dict of dicts\n        following the \"it\" semantics\n\n        e.g.\n\n        .. code-block:: python\n\n               JohnDoe isA Person\n               \"John\" is firstName of it\n               \"Doe\"  is lastName of it\n               35 is age of it\n\n        will have a pseudo - triple representation of\n\n        .. code-block:: python\n\n            JohnDoe isA Person\n            John firstName it\n            Doe lastName it\n            35 age it\n\n        leading to a dict\n\n        .. code-block:: python\n\n            {\n               'JohnDoe': {\n                  'isA': Person,\n                  'firstName': John,\n                   'lastName': 'Doe'\n                  'age': 35\n                }\n            }\n\n        Returns:\n            dict: the dict of dicts representation of the triples found\n        \"\"\"\n        # the dict of dicts\n        dod = {}\n        # we start with not \"it\" reference\n        it = None\n        # loop over all triples\n        for triple in self.triples:\n            # if this is an \"it\" reference\n            if triple.o == \"it\":\n                if it is None:\n                    raise Exception(\n                        \"Invalid it reference %s at location %d\"\n                        % (triple, triple.location)\n                    )\n                o = triple.s\n            else:\n                o = triple.o\n                if triple.s in dod:\n                    it = dod[triple.s]\n                else:\n                    it = {}\n                    dod[triple.s] = it\n            it[triple.p] = o\n        return dod\n\n    def __str__(self):\n        text = \"%d triples, %d comments\" % (len(self.triples), len(self.comments))\n        return text\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange.addComment","title":"<code>addComment(comment)</code>","text":"<p>add the given comment</p> Source code in <code>sidif/sidif.py</code> <pre><code>def addComment(self, comment):\n    \"\"\"\n    add the given comment\n    \"\"\"\n    self.comments.append(comment)\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange.addSchemaFromDict","title":"<code>addSchemaFromDict(pDict, context, parent, parentName)</code>","text":"<p>add schema information from the given dict</p> Source code in <code>sidif/sidif.py</code> <pre><code>def addSchemaFromDict(self, pDict, context, parent, parentName):\n    \"\"\"\n    add schema information from the given dict\n    \"\"\"\n    if not isinstance(pDict, dict):\n        return\n    # make sure we work on properties first then other topics\n    sortedKeys = sorted(pDict.keys(), key=lambda x: isinstance(pDict[x], dict))\n    # loop over nodes\n    for key in sortedKeys:\n        value = pDict[key]\n        # is the subnode a Topic or a Property?\n        if isinstance(value, dict):\n            # if there is an intermediate node\n            # then there is a topic link\n            # eg. workshop - events - event\n            # https://stackoverflow.com/questions/21062781/shortest-way-to-get-first-item-of-ordereddict-in-python-3\n            if len(value) == 1 and isinstance(list(value.values())[0], list):\n                listNode = list(value.values())[0]\n                firstListNode = listNode[0]\n                listKey = list(value.keys())[0]\n                self.addTopic(listKey, context)\n                self.addSchemaFromDict(firstListNode, context, listKey, \"Topic\")\n                self.addLink(\n                    key, parent, listKey, \"\", key, False, len(listNode) &gt; 1\n                )\n            else:\n                # standalone topic\n                linkKey = \"%s%s\" % (parent, key)\n                self.addTopic(key, context)\n                self.addSchemaFromDict(value, context, key, \"Topic\")\n                if parentName != \"context\":\n                    self.addLink(linkKey, parent, key, \"\", \"\", False, False)\n        else:\n            propId = self.fixId(key)\n            self.addTriple(Triple(propId, \"isA\", \"Property\"))\n            self.addTriple(Triple(key, \"name\", \"it\"))\n            valueType = type(value).__name__\n            self.addTriple(Triple(valueType, \"type\", \"it\"))\n            self.addTriple(Triple(parent, parentName, \"it\"))\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange.addTriple","title":"<code>addTriple(triple)</code>","text":"<p>add the given triple</p> <p>Parameters:</p> Name Type Description Default <code>triple(Triple)</code> <p>the triple to add</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def addTriple(self, triple):\n    \"\"\"\n    add the given triple\n\n    Args:\n        triple(Triple): the triple to add\n    \"\"\"\n    self.triples.append(triple)\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange.asSiDIF","title":"<code>asSiDIF()</code>","text":"<p>convert me to SiDIF notation</p> Source code in <code>sidif/sidif.py</code> <pre><code>def asSiDIF(self):\n    \"\"\"\n    convert me to SiDIF notation\n    \"\"\"\n    sidifStr = \"\"\n    for triple in self.triples:\n        sidif = triple.asSiDIF()\n        sidifStr += f\"{sidif}\\n\"\n    return sidifStr\n</code></pre>"},{"location":"#sidif.sidif.DataInterchange.toDictOfDicts","title":"<code>toDictOfDicts()</code>","text":"<p>convert me to a dict of dicts following the \"it\" semantics</p> <p>e.g.</p> <p>.. code-block:: python</p> <pre><code>   JohnDoe isA Person\n   \"John\" is firstName of it\n   \"Doe\"  is lastName of it\n   35 is age of it\n</code></pre> <p>will have a pseudo - triple representation of</p> <p>.. code-block:: python</p> <pre><code>JohnDoe isA Person\nJohn firstName it\nDoe lastName it\n35 age it\n</code></pre> <p>leading to a dict</p> <p>.. code-block:: python</p> <pre><code>{\n   'JohnDoe': {\n      'isA': Person,\n      'firstName': John,\n       'lastName': 'Doe'\n      'age': 35\n    }\n}\n</code></pre> <p>Returns:</p> Name Type Description <code>dict</code> <p>the dict of dicts representation of the triples found</p> Source code in <code>sidif/sidif.py</code> <pre><code>def toDictOfDicts(self):\n    \"\"\"\n    convert me to a dict of dicts\n    following the \"it\" semantics\n\n    e.g.\n\n    .. code-block:: python\n\n           JohnDoe isA Person\n           \"John\" is firstName of it\n           \"Doe\"  is lastName of it\n           35 is age of it\n\n    will have a pseudo - triple representation of\n\n    .. code-block:: python\n\n        JohnDoe isA Person\n        John firstName it\n        Doe lastName it\n        35 age it\n\n    leading to a dict\n\n    .. code-block:: python\n\n        {\n           'JohnDoe': {\n              'isA': Person,\n              'firstName': John,\n               'lastName': 'Doe'\n              'age': 35\n            }\n        }\n\n    Returns:\n        dict: the dict of dicts representation of the triples found\n    \"\"\"\n    # the dict of dicts\n    dod = {}\n    # we start with not \"it\" reference\n    it = None\n    # loop over all triples\n    for triple in self.triples:\n        # if this is an \"it\" reference\n        if triple.o == \"it\":\n            if it is None:\n                raise Exception(\n                    \"Invalid it reference %s at location %d\"\n                    % (triple, triple.location)\n                )\n            o = triple.s\n        else:\n            o = triple.o\n            if triple.s in dod:\n                it = dod[triple.s]\n            else:\n                it = {}\n                dod[triple.s] = it\n        it[triple.p] = o\n    return dod\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser","title":"<code>SiDIFParser</code>","text":"<p>               Bases: <code>object</code></p> <p>Parser for SiDIF Simple Data Interchange Format see http://wiki.bitplan.com/index.php/SiDIF</p> Source code in <code>sidif/sidif.py</code> <pre><code>class SiDIFParser(object):\n    \"\"\"\n    Parser for SiDIF Simple Data Interchange Format\n    see http://wiki.bitplan.com/index.php/SiDIF\n    \"\"\"\n\n    def __init__(self, showErrors=True, debug=False):\n        \"\"\"\n        Constructor\n        Args:\n            showErrors(bool): True if errors should be shown/printed\n            debug(bool): True if debugging should be enabled\n        \"\"\"\n        self.showError = showErrors\n        self.debug = debug\n        self.grammar = None\n        ParserElement.setDefaultWhitespaceChars(\" \\t\")\n\n    @staticmethod\n    def getUriRegexp():\n        \"\"\"\n        get a regular expression for an URI\n        \"\"\"\n        # https://mathiasbynens.be/demo/url-regex\n        # https://gist.github.com/dperini/729294\n        uriRegexp = (\n            # protocol identifier\n            r\"(?:(?:(?:https?|ftp|file):)//|(mailto|news|nntp|telnet):)\"\n            # user:pass authentication\n            r\"(?:\\S+(?::\\S*)?@)?\"\n            r\"(?:\"\n            # IP address exclusion\n            # private &amp; local networks\n            r\"(?!(?:10|127)(?:\\.\\d{1,3}){3})\"\n            r\"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})\"\n            r\"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})\"\n            # IP address dotted notation octets\n            # excludes loopback network 0.0.0.0\n            # excludes reserved space &gt;= 224.0.0.0\n            # excludes network &amp; broadcast addresses\n            # (first &amp; last IP address of each class)\n            r\"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])\"\n            r\"(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}\"\n            r\"(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))\"\n            r\"|\"\n            # host &amp; domain names, may end with dot\n            # can be replaced by a shortest alternative\n            # r\"(?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+\"\n            # r\"(?:(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9]+)\"\n            # # domain name\n            # r\"(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9]+)*\"\n            r\"(?:\"\n            r\"(?:\"\n            r\"[a-z0-9\\u00a1-\\uffff]\"\n            r\"[a-z0-9\\u00a1-\\uffff_-]{0,62}\"\n            r\")?\"\n            r\"[a-z0-9\\u00a1-\\uffff]\\.\"\n            r\")+\"\n            # TLD identifier name, may end with dot\n            r\"(?:[a-z\\u00a1-\\uffff]{2,}\\.?)\"\n            r\")\"\n            # port number (optional)\n            r\"(?::\\d{2,5})?\"\n            # resource path (optional)\n            r\"(?:[/?#]\\S*)?\"\n        )\n        compiled = re.compile(uriRegexp, re.IGNORECASE | re.UNICODE)\n        return compiled\n\n    def convertToTime(self, tokenStr, location, token):\n        \"\"\"\n        convert a timeLiteral to a time\n        \"\"\"\n        try:\n            timestr = token[0]\n            fmt = \"%H:%M:%S\" if len(timestr) == 8 else \"%H:%M\"\n            dt = datetime.datetime.strptime(timestr, fmt)\n            timeResult = dt.time()\n            return timeResult\n        except ValueError as ve:\n            raise ParseFatalException(tokenStr, location, str(ve))\n\n    def convertToBoolean(self, tokenStr: str, location, token):\n        \"\"\"\n        convert the given token to a boolean\n        \"\"\"\n        try:\n            tokenStr = token[0]\n            if tokenStr == \"true\":\n                return True\n            elif tokenStr == \"false\":\n                return False\n        except Exception as pe:\n            msg = str(pe)\n        # https://stackoverflow.com/questions/13393432/raise-a-custom-exception-in-pyparsing\n        raise ParseFatalException(\n            tokenStr, location, \"invalid boolean %s:%s\" % (tokenStr, msg)\n        )\n\n    def handleDateTimeLiteral(self, tokenStr: str, location, group):\n        \"\"\"\n        handle a date time literal\n        \"\"\"\n        token = group[0]\n        if len(token) == 1:\n            date = token[0]\n            return date\n        elif len(token) == 2:\n            date = token[0]\n            time = token[1]\n            dt = datetime.datetime(\n                date.year, date.month, date.day, time.hour, time.minute, time.second\n            )\n            return dt\n        else:\n            raise ParseFatalException(\n                tokenStr, location, \"invalid DateTimeLiteral %s\" % tokenStr\n            )\n\n    def handleStringLiteral(self, _tokenStr, _location, tokens):\n        \"\"\"\n        handle string literals\n\n        Args:\n            tokens(ParseResults): the tokens for the literal\n        \"\"\"\n        token = tokens[0]\n        if len(token) &gt; 0:\n            text = token[0]\n        else:\n            text = \"\"\n        return text\n\n    def handleIdentifier(self, _tokenStr, _location, tokens):\n        \"\"\"\n        handle identifiers\n        \"\"\"\n        identifier = tokens[\"identifier\"][0]\n        return identifier\n\n    def handleComment(self, location, tokens):\n        \"\"\"\n        handle the comment given comment tokens\n        \"\"\"\n        # tokenName=tokens.getName()\n        # count=len(tokens)\n        commentText = \"\"\n        for token in tokens:\n            commentText += \"\".join(token)\n        comment = Comment(commentText, location)\n        return comment\n\n    def handleGroup(self, _tokenStr, _location, tokens):\n        \"\"\"\n        handle a Group\n        \"\"\"\n        _tokenName = tokens.getName()\n        token = tokens[0]\n        _innerName = token.getName()\n        inner = token[0]\n        return inner\n\n    def addContent(self, di: DataInterchange, token, tokenName: str):\n        \"\"\"\n        add Content to the given DataInterchange\n\n        Args:\n            di(DataInterchange): the datainterchange\n            token: the  token to add the content for\n            tokenName(str): the name of the token\n        \"\"\"\n        if isinstance(token, ParseResults):\n            if tokenName == \"links\" or tokenName == \"comment\" or tokenName == \"line\":\n                if self.debug:\n                    self.warn(f\"{tokenName}: {len(token)}\")\n                tokenName = token.getName()\n                for subtoken in token:\n                    self.addContent(di, subtoken, tokenName)\n            else:\n                self.warn(f\"parseResult {tokenName} not handled\")\n        elif isinstance(token, Triple):\n            di.addTriple(token)\n        elif isinstance(token, Comment):\n            di.addComment(token)\n        else:\n            if self.debug:\n                if not token.isspace():\n                    token_type = type(token).__name__\n                    self.warn(\n                        f\"plain subtoken of {tokenName} type {token_type} not handled\"\n                    )\n            pass\n\n    def handleLines(self, _tokenStr, _location, tokens):\n        \"\"\"\n        handle the line derived\n        \"\"\"\n        di = DataInterchange()\n        self.addContent(di, tokens, tokens.getName())\n        return di\n\n    def convertToTriple(self, tokenStr, location, group):\n        \"\"\"\n        convert the given token to a triple\n\n        Args:\n            tokenStr(str): the token string\n            location(object): location of the parse process\n            group(ParseResults): the expected triple defining group\n        \"\"\"\n        tripleKind = group.getName()\n        tokens = group[0]\n        tokenCount = len(tokens)\n        if tokenCount != 3:\n            raise ParseException(\n                tokenStr,\n                location,\n                \"invalid triple %s: %d tokens found 3 expected\"\n                % (tripleKind, tokenCount),\n            )\n        e1 = tokens[0]\n        e2 = tokens[1]\n        e3 = tokens[2]\n        if tripleKind == \"isValue\":\n            #'\"Paris\" is capital of France'\n            triple = Triple(e1, e2, e3, location)\n        elif tripleKind == \"idLink\":\n            #'Paris capital France'\n            triple = Triple(e1, e2, e3, location)\n        elif tripleKind == \"isLink\":\n            #'Paris is capital of France'\n            triple = Triple(e1, e2, e3, location)\n        elif tripleKind == \"hasLink\":\n            #'France has capital Paris'\n            triple = Triple(e3, e2, e1, location)\n        else:\n            raise ParseFatalException(\n                tokenStr, location, \"invalid tripleKind %s\" % tripleKind\n            )\n        return triple\n\n    def getLiteral(self):\n        \"\"\"\n        get the literal sub Grammar\n        \"\"\"\n        uri = Regex(SiDIFParser.getUriRegexp())(\"uri\")\n        booleanLiteral = oneOf([\"true\", \"false\"]).setParseAction(self.convertToBoolean)(\n            \"boolean\"\n        )\n        hexLiteral = (\n            Suppress(\"0x\") + (Word(hexnums).setParseAction(tokenMap(int, 16)))\n        )(\"hexLiteral\")\n        integerLiteral = pyparsing_common.signed_integer(\"integerLiteral\")\n        floatingPointLiteral = Group(\n            pyparsing_common.sci_real | pyparsing_common.real\n        ).setParseAction(self.handleGroup)(\"floatingPointLiteral\")\n        timeLiteral = Regex(r\"[0-9]{2}:[0-9]{2}(:[0-9]{2})?\").setParseAction(\n            self.convertToTime\n        )(\"timeLiteral\")\n        dateLiteral = pyparsing_common.iso8601_date.copy().setParseAction(\n            pyparsing_common.convertToDate()\n        )(\"dateLiteral\")\n        dateTimeLiteral = Group(dateLiteral + Optional(timeLiteral)).setParseAction(\n            self.handleDateTimeLiteral\n        )(\"dateTimeLiteral\")\n        stringLiteral = Group(\n            Suppress('\"') + ZeroOrMore(CharsNotIn('\"') | LineEnd()) + Suppress('\"')\n        ).setParseAction(self.handleStringLiteral)(\"stringLiteral\")\n        literal = Group(\n            uri\n            | stringLiteral\n            | booleanLiteral\n            | hexLiteral\n            | dateTimeLiteral\n            | timeLiteral\n            | floatingPointLiteral\n            | integerLiteral\n        ).setParseAction(self.handleGroup)(\"literal\")\n        return literal\n\n    def getIdentifier(self):\n        \"\"\"\n        identifier definition\n        \"\"\"\n        identifier = Group(pyparsing_common.identifier).setParseAction(\n            self.handleIdentifier\n        )(\"identifier\")\n        return identifier\n\n    def getValueGrammar(self):\n        \"\"\"\n        sub grammar for value definition\n        \"\"\"\n        literal = self.getLiteral()\n        identifier = self.getIdentifier()\n        value = Group(\n            literal + Suppress(\"is\") + identifier + Suppress(\"of\") + identifier\n        ).setParseAction(self.convertToTriple)(\"isValue\")\n        return value\n\n    def getGrammar(self):\n        \"\"\"\n        get the grammar\n        \"\"\"\n        if self.grammar is None:\n            value = self.getValueGrammar()\n            identifier = self.getIdentifier()\n\n            idlink = Group(identifier + identifier + identifier).setParseAction(\n                self.convertToTriple\n            )(\"idLink\")\n            islink = Group(\n                identifier + Suppress(\"is\") + identifier + Suppress(\"of\") + identifier\n            ).setParseAction(self.convertToTriple)(\"isLink\")\n            haslink = Group(\n                identifier + Suppress(\"has\") + identifier + identifier\n            ).setParseAction(self.convertToTriple)(\"hasLink\")\n            link = Group(islink | haslink | idlink).setParseAction(self.handleGroup)(\n                \"link\"\n            )\n            comment = Group(\n                Suppress(\"#\")\n                + ZeroOrMore(Word(pp.pyparsing_unicode.Latin1.printables))\n                + OneOrMore(LineEnd())\n                | OneOrMore(LineEnd())\n            ).setParseAction(self.handleComment)(\"comment*\")\n            line = Group(value | link).setParseAction(self.handleGroup)(\"line\")\n            links = Group(OneOrMore(line + LineEnd() | comment)).setParseAction(\n                self.handleLines\n            )(\"links*\")\n            self.grammar = links\n        return self.grammar\n\n    def parseUrl(self, url, title=None):\n        \"\"\"\n        parse the sidif text from the given url\n\n        Args:\n            url(str): the url to read the SiDIF text from\n        \"\"\"\n        sidif = urlopen(url).read().decode()\n        if title is None:\n            title = url\n        return self.parseText(sidif, title=title)\n\n    def parseWithGrammar(self, grammar, text, title=None, depth: int = None):\n        \"\"\"\n        parse the given text with the given grammar optionally\n        labeling the parse with the given title\n\n        Args:\n            grammar(object): a pyparsing grammar\n            text(str): the text to be parsed\n            title(str): optional title\n            depth(int): the explain depth to show for the errorMessage\n        \"\"\"\n        result = None\n        error = None\n        if title is None:\n            title = \"?\"\n        try:\n            result = grammar.parseString(text, parseAll=True)\n        except ParseException as pe:\n            if self.showError:\n                errMsg = SiDIFParser.errorMessage(title, pe, depth=depth)\n                print(errMsg, file=sys.stderr)\n            error = pe\n        return result, error\n\n    @classmethod\n    def errorMessage(cls, title: str, pe: ParseException, depth: int = None) -&gt; str:\n        \"\"\"\n        Args:\n            title(str): the title\n            pe(ParseException): the exception to get the error message for\n            depth(int): the explain depth to show for the errorMessage\n        Returns:\n            str: an error message with the explanation\n        \"\"\"\n        msg = \"%s: error in line %d col %d: \\n%s\" % (title, pe.lineno, pe.col, pe.line)\n        msg += \"\\n\" + pe.explain(depth=depth)\n        return msg\n\n    def parseText(self, sidif, title=None, depth: int = None):\n        \"\"\"\n        parse the given sidif text\n\n        Args:\n            sidif(str): the SiDIF text to be parsed\n            depth(int): the explain depth to show for the errorMessage\n\n        Return:\n            tuple: ParseResult from pyParsing and error - one of these should be None\n        \"\"\"\n        return self.parseWithGrammar(self.getGrammar(), sidif, title, depth=depth)\n\n    def warn(self, msg):\n        \"\"\"\n        show a warning with the given message\n\n        Args:\n            msg(str): the warning message\n        \"\"\"\n        print(msg, file=sys.stderr)\n\n    def printResult(self, pr, indent=\"\"):\n        \"\"\"\n        print the given parseResult recursively\n\n        Args:\n            pr(object): the ParseResult to print\n            indent(str): initial indentation\n        \"\"\"\n        if isinstance(pr, ParseResults):\n            print(\"%s%s:\" % (indent, pr.getName()))\n            for subpr in pr:\n                self.printResult(subpr, indent + \"  \")\n        else:\n            print(\"%s %s=%s\" % (indent, type(pr).__name__, pr))\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.__init__","title":"<code>__init__(showErrors=True, debug=False)</code>","text":"<p>Constructor Args:     showErrors(bool): True if errors should be shown/printed     debug(bool): True if debugging should be enabled</p> Source code in <code>sidif/sidif.py</code> <pre><code>def __init__(self, showErrors=True, debug=False):\n    \"\"\"\n    Constructor\n    Args:\n        showErrors(bool): True if errors should be shown/printed\n        debug(bool): True if debugging should be enabled\n    \"\"\"\n    self.showError = showErrors\n    self.debug = debug\n    self.grammar = None\n    ParserElement.setDefaultWhitespaceChars(\" \\t\")\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.addContent","title":"<code>addContent(di, token, tokenName)</code>","text":"<p>add Content to the given DataInterchange</p> <p>Parameters:</p> Name Type Description Default <code>di(DataInterchange)</code> <p>the datainterchange</p> required <code>token</code> <p>the  token to add the content for</p> required <code>tokenName(str)</code> <p>the name of the token</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def addContent(self, di: DataInterchange, token, tokenName: str):\n    \"\"\"\n    add Content to the given DataInterchange\n\n    Args:\n        di(DataInterchange): the datainterchange\n        token: the  token to add the content for\n        tokenName(str): the name of the token\n    \"\"\"\n    if isinstance(token, ParseResults):\n        if tokenName == \"links\" or tokenName == \"comment\" or tokenName == \"line\":\n            if self.debug:\n                self.warn(f\"{tokenName}: {len(token)}\")\n            tokenName = token.getName()\n            for subtoken in token:\n                self.addContent(di, subtoken, tokenName)\n        else:\n            self.warn(f\"parseResult {tokenName} not handled\")\n    elif isinstance(token, Triple):\n        di.addTriple(token)\n    elif isinstance(token, Comment):\n        di.addComment(token)\n    else:\n        if self.debug:\n            if not token.isspace():\n                token_type = type(token).__name__\n                self.warn(\n                    f\"plain subtoken of {tokenName} type {token_type} not handled\"\n                )\n        pass\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.convertToBoolean","title":"<code>convertToBoolean(tokenStr, location, token)</code>","text":"<p>convert the given token to a boolean</p> Source code in <code>sidif/sidif.py</code> <pre><code>def convertToBoolean(self, tokenStr: str, location, token):\n    \"\"\"\n    convert the given token to a boolean\n    \"\"\"\n    try:\n        tokenStr = token[0]\n        if tokenStr == \"true\":\n            return True\n        elif tokenStr == \"false\":\n            return False\n    except Exception as pe:\n        msg = str(pe)\n    # https://stackoverflow.com/questions/13393432/raise-a-custom-exception-in-pyparsing\n    raise ParseFatalException(\n        tokenStr, location, \"invalid boolean %s:%s\" % (tokenStr, msg)\n    )\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.convertToTime","title":"<code>convertToTime(tokenStr, location, token)</code>","text":"<p>convert a timeLiteral to a time</p> Source code in <code>sidif/sidif.py</code> <pre><code>def convertToTime(self, tokenStr, location, token):\n    \"\"\"\n    convert a timeLiteral to a time\n    \"\"\"\n    try:\n        timestr = token[0]\n        fmt = \"%H:%M:%S\" if len(timestr) == 8 else \"%H:%M\"\n        dt = datetime.datetime.strptime(timestr, fmt)\n        timeResult = dt.time()\n        return timeResult\n    except ValueError as ve:\n        raise ParseFatalException(tokenStr, location, str(ve))\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.convertToTriple","title":"<code>convertToTriple(tokenStr, location, group)</code>","text":"<p>convert the given token to a triple</p> <p>Parameters:</p> Name Type Description Default <code>tokenStr(str)</code> <p>the token string</p> required <code>location(object)</code> <p>location of the parse process</p> required <code>group(ParseResults)</code> <p>the expected triple defining group</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def convertToTriple(self, tokenStr, location, group):\n    \"\"\"\n    convert the given token to a triple\n\n    Args:\n        tokenStr(str): the token string\n        location(object): location of the parse process\n        group(ParseResults): the expected triple defining group\n    \"\"\"\n    tripleKind = group.getName()\n    tokens = group[0]\n    tokenCount = len(tokens)\n    if tokenCount != 3:\n        raise ParseException(\n            tokenStr,\n            location,\n            \"invalid triple %s: %d tokens found 3 expected\"\n            % (tripleKind, tokenCount),\n        )\n    e1 = tokens[0]\n    e2 = tokens[1]\n    e3 = tokens[2]\n    if tripleKind == \"isValue\":\n        #'\"Paris\" is capital of France'\n        triple = Triple(e1, e2, e3, location)\n    elif tripleKind == \"idLink\":\n        #'Paris capital France'\n        triple = Triple(e1, e2, e3, location)\n    elif tripleKind == \"isLink\":\n        #'Paris is capital of France'\n        triple = Triple(e1, e2, e3, location)\n    elif tripleKind == \"hasLink\":\n        #'France has capital Paris'\n        triple = Triple(e3, e2, e1, location)\n    else:\n        raise ParseFatalException(\n            tokenStr, location, \"invalid tripleKind %s\" % tripleKind\n        )\n    return triple\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.errorMessage","title":"<code>errorMessage(title, pe, depth=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title(str)</code> <p>the title</p> required <code>pe(ParseException)</code> <p>the exception to get the error message for</p> required <code>depth(int)</code> <p>the explain depth to show for the errorMessage</p> required <p>Returns:     str: an error message with the explanation</p> Source code in <code>sidif/sidif.py</code> <pre><code>@classmethod\ndef errorMessage(cls, title: str, pe: ParseException, depth: int = None) -&gt; str:\n    \"\"\"\n    Args:\n        title(str): the title\n        pe(ParseException): the exception to get the error message for\n        depth(int): the explain depth to show for the errorMessage\n    Returns:\n        str: an error message with the explanation\n    \"\"\"\n    msg = \"%s: error in line %d col %d: \\n%s\" % (title, pe.lineno, pe.col, pe.line)\n    msg += \"\\n\" + pe.explain(depth=depth)\n    return msg\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.getGrammar","title":"<code>getGrammar()</code>","text":"<p>get the grammar</p> Source code in <code>sidif/sidif.py</code> <pre><code>def getGrammar(self):\n    \"\"\"\n    get the grammar\n    \"\"\"\n    if self.grammar is None:\n        value = self.getValueGrammar()\n        identifier = self.getIdentifier()\n\n        idlink = Group(identifier + identifier + identifier).setParseAction(\n            self.convertToTriple\n        )(\"idLink\")\n        islink = Group(\n            identifier + Suppress(\"is\") + identifier + Suppress(\"of\") + identifier\n        ).setParseAction(self.convertToTriple)(\"isLink\")\n        haslink = Group(\n            identifier + Suppress(\"has\") + identifier + identifier\n        ).setParseAction(self.convertToTriple)(\"hasLink\")\n        link = Group(islink | haslink | idlink).setParseAction(self.handleGroup)(\n            \"link\"\n        )\n        comment = Group(\n            Suppress(\"#\")\n            + ZeroOrMore(Word(pp.pyparsing_unicode.Latin1.printables))\n            + OneOrMore(LineEnd())\n            | OneOrMore(LineEnd())\n        ).setParseAction(self.handleComment)(\"comment*\")\n        line = Group(value | link).setParseAction(self.handleGroup)(\"line\")\n        links = Group(OneOrMore(line + LineEnd() | comment)).setParseAction(\n            self.handleLines\n        )(\"links*\")\n        self.grammar = links\n    return self.grammar\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.getIdentifier","title":"<code>getIdentifier()</code>","text":"<p>identifier definition</p> Source code in <code>sidif/sidif.py</code> <pre><code>def getIdentifier(self):\n    \"\"\"\n    identifier definition\n    \"\"\"\n    identifier = Group(pyparsing_common.identifier).setParseAction(\n        self.handleIdentifier\n    )(\"identifier\")\n    return identifier\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.getLiteral","title":"<code>getLiteral()</code>","text":"<p>get the literal sub Grammar</p> Source code in <code>sidif/sidif.py</code> <pre><code>def getLiteral(self):\n    \"\"\"\n    get the literal sub Grammar\n    \"\"\"\n    uri = Regex(SiDIFParser.getUriRegexp())(\"uri\")\n    booleanLiteral = oneOf([\"true\", \"false\"]).setParseAction(self.convertToBoolean)(\n        \"boolean\"\n    )\n    hexLiteral = (\n        Suppress(\"0x\") + (Word(hexnums).setParseAction(tokenMap(int, 16)))\n    )(\"hexLiteral\")\n    integerLiteral = pyparsing_common.signed_integer(\"integerLiteral\")\n    floatingPointLiteral = Group(\n        pyparsing_common.sci_real | pyparsing_common.real\n    ).setParseAction(self.handleGroup)(\"floatingPointLiteral\")\n    timeLiteral = Regex(r\"[0-9]{2}:[0-9]{2}(:[0-9]{2})?\").setParseAction(\n        self.convertToTime\n    )(\"timeLiteral\")\n    dateLiteral = pyparsing_common.iso8601_date.copy().setParseAction(\n        pyparsing_common.convertToDate()\n    )(\"dateLiteral\")\n    dateTimeLiteral = Group(dateLiteral + Optional(timeLiteral)).setParseAction(\n        self.handleDateTimeLiteral\n    )(\"dateTimeLiteral\")\n    stringLiteral = Group(\n        Suppress('\"') + ZeroOrMore(CharsNotIn('\"') | LineEnd()) + Suppress('\"')\n    ).setParseAction(self.handleStringLiteral)(\"stringLiteral\")\n    literal = Group(\n        uri\n        | stringLiteral\n        | booleanLiteral\n        | hexLiteral\n        | dateTimeLiteral\n        | timeLiteral\n        | floatingPointLiteral\n        | integerLiteral\n    ).setParseAction(self.handleGroup)(\"literal\")\n    return literal\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.getUriRegexp","title":"<code>getUriRegexp()</code>  <code>staticmethod</code>","text":"<p>get a regular expression for an URI</p> Source code in <code>sidif/sidif.py</code> <pre><code>@staticmethod\ndef getUriRegexp():\n    \"\"\"\n    get a regular expression for an URI\n    \"\"\"\n    # https://mathiasbynens.be/demo/url-regex\n    # https://gist.github.com/dperini/729294\n    uriRegexp = (\n        # protocol identifier\n        r\"(?:(?:(?:https?|ftp|file):)//|(mailto|news|nntp|telnet):)\"\n        # user:pass authentication\n        r\"(?:\\S+(?::\\S*)?@)?\"\n        r\"(?:\"\n        # IP address exclusion\n        # private &amp; local networks\n        r\"(?!(?:10|127)(?:\\.\\d{1,3}){3})\"\n        r\"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})\"\n        r\"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})\"\n        # IP address dotted notation octets\n        # excludes loopback network 0.0.0.0\n        # excludes reserved space &gt;= 224.0.0.0\n        # excludes network &amp; broadcast addresses\n        # (first &amp; last IP address of each class)\n        r\"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])\"\n        r\"(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}\"\n        r\"(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))\"\n        r\"|\"\n        # host &amp; domain names, may end with dot\n        # can be replaced by a shortest alternative\n        # r\"(?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+\"\n        # r\"(?:(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9]+)\"\n        # # domain name\n        # r\"(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-?)*[a-z\\u00a1-\\uffff0-9]+)*\"\n        r\"(?:\"\n        r\"(?:\"\n        r\"[a-z0-9\\u00a1-\\uffff]\"\n        r\"[a-z0-9\\u00a1-\\uffff_-]{0,62}\"\n        r\")?\"\n        r\"[a-z0-9\\u00a1-\\uffff]\\.\"\n        r\")+\"\n        # TLD identifier name, may end with dot\n        r\"(?:[a-z\\u00a1-\\uffff]{2,}\\.?)\"\n        r\")\"\n        # port number (optional)\n        r\"(?::\\d{2,5})?\"\n        # resource path (optional)\n        r\"(?:[/?#]\\S*)?\"\n    )\n    compiled = re.compile(uriRegexp, re.IGNORECASE | re.UNICODE)\n    return compiled\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.getValueGrammar","title":"<code>getValueGrammar()</code>","text":"<p>sub grammar for value definition</p> Source code in <code>sidif/sidif.py</code> <pre><code>def getValueGrammar(self):\n    \"\"\"\n    sub grammar for value definition\n    \"\"\"\n    literal = self.getLiteral()\n    identifier = self.getIdentifier()\n    value = Group(\n        literal + Suppress(\"is\") + identifier + Suppress(\"of\") + identifier\n    ).setParseAction(self.convertToTriple)(\"isValue\")\n    return value\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleComment","title":"<code>handleComment(location, tokens)</code>","text":"<p>handle the comment given comment tokens</p> Source code in <code>sidif/sidif.py</code> <pre><code>def handleComment(self, location, tokens):\n    \"\"\"\n    handle the comment given comment tokens\n    \"\"\"\n    # tokenName=tokens.getName()\n    # count=len(tokens)\n    commentText = \"\"\n    for token in tokens:\n        commentText += \"\".join(token)\n    comment = Comment(commentText, location)\n    return comment\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleDateTimeLiteral","title":"<code>handleDateTimeLiteral(tokenStr, location, group)</code>","text":"<p>handle a date time literal</p> Source code in <code>sidif/sidif.py</code> <pre><code>def handleDateTimeLiteral(self, tokenStr: str, location, group):\n    \"\"\"\n    handle a date time literal\n    \"\"\"\n    token = group[0]\n    if len(token) == 1:\n        date = token[0]\n        return date\n    elif len(token) == 2:\n        date = token[0]\n        time = token[1]\n        dt = datetime.datetime(\n            date.year, date.month, date.day, time.hour, time.minute, time.second\n        )\n        return dt\n    else:\n        raise ParseFatalException(\n            tokenStr, location, \"invalid DateTimeLiteral %s\" % tokenStr\n        )\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleGroup","title":"<code>handleGroup(_tokenStr, _location, tokens)</code>","text":"<p>handle a Group</p> Source code in <code>sidif/sidif.py</code> <pre><code>def handleGroup(self, _tokenStr, _location, tokens):\n    \"\"\"\n    handle a Group\n    \"\"\"\n    _tokenName = tokens.getName()\n    token = tokens[0]\n    _innerName = token.getName()\n    inner = token[0]\n    return inner\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleIdentifier","title":"<code>handleIdentifier(_tokenStr, _location, tokens)</code>","text":"<p>handle identifiers</p> Source code in <code>sidif/sidif.py</code> <pre><code>def handleIdentifier(self, _tokenStr, _location, tokens):\n    \"\"\"\n    handle identifiers\n    \"\"\"\n    identifier = tokens[\"identifier\"][0]\n    return identifier\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleLines","title":"<code>handleLines(_tokenStr, _location, tokens)</code>","text":"<p>handle the line derived</p> Source code in <code>sidif/sidif.py</code> <pre><code>def handleLines(self, _tokenStr, _location, tokens):\n    \"\"\"\n    handle the line derived\n    \"\"\"\n    di = DataInterchange()\n    self.addContent(di, tokens, tokens.getName())\n    return di\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.handleStringLiteral","title":"<code>handleStringLiteral(_tokenStr, _location, tokens)</code>","text":"<p>handle string literals</p> <p>Parameters:</p> Name Type Description Default <code>tokens(ParseResults)</code> <p>the tokens for the literal</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def handleStringLiteral(self, _tokenStr, _location, tokens):\n    \"\"\"\n    handle string literals\n\n    Args:\n        tokens(ParseResults): the tokens for the literal\n    \"\"\"\n    token = tokens[0]\n    if len(token) &gt; 0:\n        text = token[0]\n    else:\n        text = \"\"\n    return text\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.parseText","title":"<code>parseText(sidif, title=None, depth=None)</code>","text":"<p>parse the given sidif text</p> <p>Parameters:</p> Name Type Description Default <code>sidif(str)</code> <p>the SiDIF text to be parsed</p> required <code>depth(int)</code> <p>the explain depth to show for the errorMessage</p> required Return <p>tuple: ParseResult from pyParsing and error - one of these should be None</p> Source code in <code>sidif/sidif.py</code> <pre><code>def parseText(self, sidif, title=None, depth: int = None):\n    \"\"\"\n    parse the given sidif text\n\n    Args:\n        sidif(str): the SiDIF text to be parsed\n        depth(int): the explain depth to show for the errorMessage\n\n    Return:\n        tuple: ParseResult from pyParsing and error - one of these should be None\n    \"\"\"\n    return self.parseWithGrammar(self.getGrammar(), sidif, title, depth=depth)\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.parseUrl","title":"<code>parseUrl(url, title=None)</code>","text":"<p>parse the sidif text from the given url</p> <p>Parameters:</p> Name Type Description Default <code>url(str)</code> <p>the url to read the SiDIF text from</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def parseUrl(self, url, title=None):\n    \"\"\"\n    parse the sidif text from the given url\n\n    Args:\n        url(str): the url to read the SiDIF text from\n    \"\"\"\n    sidif = urlopen(url).read().decode()\n    if title is None:\n        title = url\n    return self.parseText(sidif, title=title)\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.parseWithGrammar","title":"<code>parseWithGrammar(grammar, text, title=None, depth=None)</code>","text":"<p>parse the given text with the given grammar optionally labeling the parse with the given title</p> <p>Parameters:</p> Name Type Description Default <code>grammar(object)</code> <p>a pyparsing grammar</p> required <code>text(str)</code> <p>the text to be parsed</p> required <code>title(str)</code> <p>optional title</p> required <code>depth(int)</code> <p>the explain depth to show for the errorMessage</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def parseWithGrammar(self, grammar, text, title=None, depth: int = None):\n    \"\"\"\n    parse the given text with the given grammar optionally\n    labeling the parse with the given title\n\n    Args:\n        grammar(object): a pyparsing grammar\n        text(str): the text to be parsed\n        title(str): optional title\n        depth(int): the explain depth to show for the errorMessage\n    \"\"\"\n    result = None\n    error = None\n    if title is None:\n        title = \"?\"\n    try:\n        result = grammar.parseString(text, parseAll=True)\n    except ParseException as pe:\n        if self.showError:\n            errMsg = SiDIFParser.errorMessage(title, pe, depth=depth)\n            print(errMsg, file=sys.stderr)\n        error = pe\n    return result, error\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.printResult","title":"<code>printResult(pr, indent='')</code>","text":"<p>print the given parseResult recursively</p> <p>Parameters:</p> Name Type Description Default <code>pr(object)</code> <p>the ParseResult to print</p> required <code>indent(str)</code> <p>initial indentation</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def printResult(self, pr, indent=\"\"):\n    \"\"\"\n    print the given parseResult recursively\n\n    Args:\n        pr(object): the ParseResult to print\n        indent(str): initial indentation\n    \"\"\"\n    if isinstance(pr, ParseResults):\n        print(\"%s%s:\" % (indent, pr.getName()))\n        for subpr in pr:\n            self.printResult(subpr, indent + \"  \")\n    else:\n        print(\"%s %s=%s\" % (indent, type(pr).__name__, pr))\n</code></pre>"},{"location":"#sidif.sidif.SiDIFParser.warn","title":"<code>warn(msg)</code>","text":"<p>show a warning with the given message</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the warning message</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def warn(self, msg):\n    \"\"\"\n    show a warning with the given message\n\n    Args:\n        msg(str): the warning message\n    \"\"\"\n    print(msg, file=sys.stderr)\n</code></pre>"},{"location":"#sidif.sidif.Triple","title":"<code>Triple</code>","text":"<p>a pseudo - triple (subject,predicate,object) with it's location</p> <p>due to the \"it\" syntax the subject may contain the object and the real subject is the latest non it-reference</p> Source code in <code>sidif/sidif.py</code> <pre><code>class Triple:\n    \"\"\"\n    a pseudo - triple (subject,predicate,object)\n    with it's location\n\n    due to the \"it\" syntax the subject may contain the object and the real\n    subject is the latest non it-reference\n    \"\"\"\n\n    def __init__(self, pSubject, pPredicate, pObject, location=0):\n        \"\"\"\n        constructor\n\n        Args:\n            pSubject(object): subject\n            pPredicate(object): predicate\n            pObject(object): object\n            location(int): the location in the source text\n\n        \"\"\"\n        self.s = pSubject\n        self.p = pPredicate\n        self.o = pObject\n        self.location = location\n\n    def dump(self, value):\n        d = \"%s(%s)\" % (value, type(value).__name__)\n        return d\n\n    def asLiteral(self, value):\n        if isinstance(value, str):\n            return '\"%s\"' % value\n        elif isinstance(value, bool):\n            return \"true\" if value else \"false\"\n        else:\n            return \"%s\" % value\n\n    def asSiDIF(self):\n        if self.o == \"it\":\n            literal = self.asLiteral(self.s)\n            line = \"%s is %s of it\" % (literal, self.p)\n        else:\n            line = \"%s %s %s\" % (self.s, self.p, self.o)\n        return line\n\n    def __str__(self):\n        text = \"{%s,%s,%s}\" % (self.dump(self.s), self.dump(self.p), self.dump(self.o))\n        return text\n</code></pre>"},{"location":"#sidif.sidif.Triple.__init__","title":"<code>__init__(pSubject, pPredicate, pObject, location=0)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>pSubject(object)</code> <p>subject</p> required <code>pPredicate(object)</code> <p>predicate</p> required <code>pObject(object)</code> <p>object</p> required <code>location(int)</code> <p>the location in the source text</p> required Source code in <code>sidif/sidif.py</code> <pre><code>def __init__(self, pSubject, pPredicate, pObject, location=0):\n    \"\"\"\n    constructor\n\n    Args:\n        pSubject(object): subject\n        pPredicate(object): predicate\n        pObject(object): object\n        location(int): the location in the source text\n\n    \"\"\"\n    self.s = pSubject\n    self.p = pPredicate\n    self.o = pObject\n    self.location = location\n</code></pre>"}]}